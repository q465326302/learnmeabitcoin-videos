00:00:00,640 --> 00:00:01,520
好的，

00:00:01,520 --> 00:00:02,720
在这个演示中，

00:00:02,720 -->  00:00:06,720
我将向大家介绍比特币挖矿的工作原理。

00:00:06,720 --> 00:00:08,480
我会解释什么是挖矿，

00:00:08,480 --> 00:00:11,200
以及它存在的原因。

00:00:11,200 --> 00:00:12,240
然后，

00:00:12,240 --> 00:00:14,559
我会详细介绍挖矿的工作过程。

00:00:14,559 --> 00:00:16,640
在此之前，

00:00:16,640 --> 00:00:19,119
我需要先解释哈希函数是什么，

00:00:19,119 --> 00:00:23,279
因为它是比特币工作的重要组成部分。

00:00:23,279 --> 00:00:25,119
我会先从基本的工作原理讲起，

00:00:25,119 --> 00:00:30,240
然后再以更专业的角度进行解释。

00:00:30,240 --> 00:00:31,599
那么，

00:00:31,599 --> 00:00:33,360
如果你是一名程序员，

00:00:33,360 --> 00:00:35,120
你可能会觉得这个过程更有趣。

00:00:35,120 --> 00:00:37,280
我会通过一些实例，

00:00:37,280 --> 00:00:39,760
尝试向大家展示如何在只有少量代码的情况下，

00:00:39,760 --> 00:00:44,879
实际进行比特币挖矿。

00:00:44,879 --> 00:00:47,440
那么，什么是挖矿呢？

00:00:47,440 --> 00:00:53,120
假设这就是比特币网络，

00:00:53,120 --> 00:00:59,039
这些都是运行着比特币程序并相互连接的计算机，

00:00:59,039 --> 00:01:01,840
它们共享一个文件，

00:01:01,840 --> 00:01:04,000
也就是区块链。

00:01:04,000 --> 00:01:06,400
比特币的工作方式是，

00:01:06,400 --> 00:01:09,040
如果你想向别人发送比特币，

00:01:09,040 --> 00:01:13,040
或者将比特币的所有权转让给别人，

00:01:13,040 --> 00:01:14,320
你需要创建一笔交易，

00:01:14,320 --> 00:01:17,280
这只是一行数据，

00:01:17,280 --> 00:01:23,840
然后你将其发送到网络上的一个节点。

00:01:23,840 --> 00:01:27,840
如果没有挖矿的过程，

00:01:27,840 --> 00:01:31,840
这台计算机会直接将这笔交易写入区块链，

00:01:31,840 --> 00:01:34,960
然后将这笔交易传递给与其相连的其他节点，

00:01:34,960 --> 00:01:38,960
这些节点也会将交易写入自己的文件。

00:01:38,960 --> 00:01:40,640
这个过程会一直持续下去，

00:01:40,640 --> 00:01:48,320
直到这笔交易在整个网络中传播开，

00:01:48,320 --> 00:01:50,159
并被写入所有节点的共享文件中，

00:01:50,159 --> 00:01:56,079
这是一种共享文件或交易的简单方式。

00:01:56,079 --> 00:01:57,439
你知道的，

00:01:57,439 --> 00:02:01,200
当每个人都更新了他们的文件副本后，

00:02:01,200 --> 00:02:06,719
比特币的所有权就会从一个人转移到另一个人，

00:02:06,719 --> 00:02:09,038
这就是一次简单的交易。

00:02:09,038 --> 00:02:11,120
但是，如果你这样做，

00:02:11,120 --> 00:02:14,000
会有产生一个问题需要解决。

00:02:14,000 --> 00:02:17,440
我们将接收比特币的人标记为绿色，

00:02:17,440 --> 00:02:20,959
你需要创建一个交易，

00:02:20,959 --> 00:02:22,560
将比特币发送给这个绿色的人，

00:02:22,560 --> 00:02:25,440
并将这个交易插入到网络的这一侧的节点。

00:02:25,440 --> 00:02:29,599
但是，因为这是一个连接的计算机网络，

00:02:29,599 --> 00:02:32,720
你要创建第二个交易，

00:02:32,720 --> 00:02:38,160
将同样的比特币发送给另一个人。

00:02:38,160 --> 00:02:39,200
这样，

00:02:38,160 --> 00:02:46,080
你就在网络中插入了两个试图使用同一比特币的交易。

00:02:46,080 --> 00:02:47,360
你可以这样做，

00:02:47,360 --> 00:02:49,200
因为这是一个网络。

00:02:49,200 --> 00:02:50,959
接下来会发生的是，

00:02:53,280 --> 00:02:55,200
这两个交易将开始在网络中传播。

00:02:55,200 --> 00:02:57,280
你会发现，

00:02:57,280 --> 00:03:01,599
一部分计算机已经收到了这个红色的交易和第二个交易，

00:03:01,599 --> 00:03:04,640
而另一部分计算机已经收到了绿色的交易。

00:03:04,640 --> 00:03:08,239
当一台已经收到红色交易的计算机试图接收绿色的交易时，

00:03:08,239 --> 00:03:15,440
它会因为已经收到了使用这个比特币的红色交易

00:03:15,440 --> 00:03:17,840
而拒绝接收绿色的交易，

00:03:17,840 --> 00:03:19,360
这是正确的。

00:03:19,360 --> 00:03:20,239
但是，

00:03:20,239 --> 00:03:22,800
仍有一个问题，

00:03:22,800 --> 00:03:24,800
网络中仍然存在这两个冲突的交易，

00:03:24,800 --> 00:03:28,720
那么你从整个网络或者这个文件的角度来看，

00:03:28,720 --> 00:03:31,360
这个比特币现在究竟属于谁。

00:03:31,360 --> 00:03:34,640
因此，如果你以这种方式运行比特币，

00:03:34,640 --> 00:03:38,720
并直接将交易写入文件，

00:03:38,720 --> 00:03:42,400
你可能会遇到双重支付问题。

00:03:42,400 --> 00:03:45,360
但实际上，比特币已经基本解决了这个问题，

00:03:45,360 --> 00:03:51,599
它不会将冲突的交易写入区块链或共享文件，

00:03:51,599 --> 00:03:53,280
这就是挖矿的含义。

00:03:53,280 --> 00:03:56,319
比特币解决这个双重支付问题的方式，

00:03:56,319 --> 00:03:58,239
是其独特之处，这很有趣，

00:03:58,239 --> 00:04:02,000
因为我们之前就有过这种技术，

00:04:02,000 --> 00:04:21,199
*麦克风有问题，稍等*

00:04:21,199 --> 00:04:30,880
比特币解决了在共享文件中写入两个冲突交易的问题。

00:04:30,880 --> 00:04:33,199
这就是比特币的有趣之处，

00:04:33,199 --> 00:04:37,199
也是我认为比特币的“发明”成功的原因。

00:04:37,199 --> 00:04:42,800
比特币解决这个问题的方式是，

00:04:42,800 --> 00:04:47,280
它为运行比特币程序的每台计算机提供一些临时内存，

00:04:47,280 --> 00:04:50,960
称为内存池。

00:04:50,960 --> 00:04:53,280
你无法阻止这种双重支付攻击，

00:04:53,280 --> 00:04:56,000
接下来会发生的是，

00:04:56,000 --> 00:04:57,759
这个人会在这台计算机中插入一个交易，

00:04:57,759 --> 00:05:02,400
这个绿色的交易，

00:05:02,400 --> 00:05:05,680
然后他们可以在另一台计算机上进行同样的攻击，

00:05:05,680 --> 00:05:08,400
再次将这个第二个红色交易插入这台计算机。

00:05:08,400 --> 00:05:11,199
但显然，

00:05:11,199 --> 00:05:12,880
这两个交易并没有直接写入文件，

00:05:12,880 --> 00:05:15,759
它们首先被存储在临时内存中。

00:05:15,759 --> 00:05:16,479
然后，

00:05:16,479 --> 00:05:18,400
同样的事情再次发生，

00:05:18,400 --> 00:05:20,560
两个交易在网络中传播，

00:05:20,560 --> 00:05:23,039
有的节点会拒绝绿色交易，

00:05:23,039 --> 00:05:25,919
因为他们已经接收到了红色交易。

00:05:25,919 --> 00:05:28,800
所以我们看到，

00:05:28,800 --> 00:05:30,639
两个交易都在网络中，

00:05:30,639 --> 00:05:32,000
但它们还没有写入文件，

00:05:32,000 --> 00:05:34,560
所以文件仍然是安全的。

00:05:34,560 --> 00:05:36,880
然后接下来会发生的是，

00:05:36,880 --> 00:05:44,880
所有的计算机都会努力从他们的内存池中获取交易，

00:05:44,880 --> 00:05:46,720
并尝试将其添加到文件中。

00:05:46,720 --> 00:05:49,120
他们实际上都在竞争，

00:05:49,120 --> 00:05:53,199
希望成为第一个将内存池中的交易添加到文件中的节点。

00:05:53,199 --> 00:05:56,880
假设有一个节点成功做到了这一点，

00:05:56,880 --> 00:05:58,800
他们将内存池中的交易添加到文件中，

00:05:58,800 --> 00:06:00,400
就像这样……

00:06:00,400 --> 00:06:03,360
在他们完成这个操作的时候，

00:06:03,360 --> 00:06:08,880
他们会将更新后的文件副本传递给他们连接的所有其他节点，

00:06:08,880 --> 00:06:11,039
然后这些节点会更新他们的副本。

00:06:11,039 --> 00:06:13,280
这个节点，

00:06:13,280 --> 00:06:16,560
因为他们的内存池中有这个冲突的绿色交易，

00:06:16,560 --> 00:06:19,680
但他们刚刚接收到这个红色交易，

00:06:19,680 --> 00:06:22,000
消费了同样的比特币，

00:06:22,000 --> 00:06:28,880
他们会将这个绿色交易从他们的内存池中剔除。

00:06:28,880 --> 00:06:30,880
这个内存池就像一个等待区域或者一个清算所，

00:06:30,880 --> 00:06:33,120
他们接收到了这个红色交易在更新的文件中，

00:06:33,120 --> 00:06:35,360
然后他们会剔除这个冲突的交易。

00:06:35,360 --> 00:06:39,520
这个节点会将更新的副本传递给这些节点，

00:06:39,520 --> 00:06:41,199
其他节点也会做同样的事情，

00:06:41,199 --> 00:06:46,000
他们会从他们的内存池中剔除任何冲突的交易。

00:06:46,000 --> 00:06:50,080
这就是解决网络中有双重支付问题的方法，

00:06:50,080 --> 00:06:54,080
你只需要有一个等待区域，

00:06:54,080 --> 00:06:56,720
所有的节点都在竞争，

00:06:56,720 --> 00:07:01,039
试图将他们的交易添加到文件中，

00:07:01,039 --> 00:07:04,560
那么现在完成了，

00:07:04,560 --> 00:07:06,080
这个人获得了比特币。

00:07:06,080 --> 00:07:07,759
所以基本上，

00:07:07,759 --> 00:07:10,800
每个节点都在竞争，

00:07:10,800 --> 00:07:14,240
试图从他们的内存池中获取交易，

00:07:14,240 --> 00:07:15,759
然后添加到文件中，

00:07:15,759 --> 00:07:17,280
这就叫做挖矿，

00:07:17,280 --> 00:07:18,639
这就是我现在要解释的。

00:07:18,639 --> 00:07:20,800
到目前为止，

00:07:20,800 --> 00:07:23,039
有没有什么问题呢？

00:07:23,039 --> 00:07:25,759
这里需要注意的是，

00:07:25,759 --> 00:07:29,840
并非网络中的每个节点都在挖矿。

00:07:29,840 --> 00:07:32,240
是的，

00:07:32,240 --> 00:07:37,280
我做了一个简单的图表来解释这个问题。

00:07:37,280 --> 00:07:39,360
有些节点可能只是用来传递区块和交易信息，

00:07:39,360 --> 00:07:43,360
并不参与挖矿。

00:07:43,360 --> 00:07:47,680
但在这个简化的图表中，

00:07:47,680 --> 00:07:50,400
我们假设每个节点都在尝试挖矿。

00:07:50,400 --> 00:07:53,360
我们也可以设想，

00:07:53,360 --> 00:07:58,479
如果一个不挖矿的节点收到了一个包含交易信息的区块，

00:07:58,720 --> 00:08:01,280
而它的内存池中有一个与之冲突的交易，

00:08:01,280 --> 00:08:03,039
它会将冲突的交易移除。

00:08:03,039 --> 00:08:05,520
是的，

00:08:05,520 --> 00:08:09,360
所有的节点都会进行区块和交易信息的传递，

00:08:09,360 --> 00:08:15,599
但只有矿工会从内存池中添加交易信息，

00:08:15,599 --> 00:08:17,759
这就是矿工的工作，

00:08:17,759 --> 00:08:21,440
你可以选择成为一个节点，

00:08:21,440 --> 00:08:25,639
但并不一定要挖矿。

00:08:26,319 --> 00:08:29,599
我的介绍到这里还算清楚吗？

00:08:29,599 --> 00:08:33,519
接下来我要解释的是哈希函数，

00:08:33,519 --> 00:08:38,880
然后我会讲解比特币挖矿是如何工作的。

00:08:38,880 --> 00:08:41,279
好的，

00:08:41,279 --> 00:08:48,320
哈希函数其实就是一个小型的计算机程序，

00:08:48,320 --> 00:08:53,360
你可以将一些数据输入到哈希函数中，

00:08:53,360 --> 00:09:06,160
它会将数据打乱并产生一个随机的数据字符串作为结果。

00:09:06,320 --> 00:09:08,800
哈希函数的一个重要特性是，

00:09:08,800 --> 00:09:12,640
无论何时你输入相同的数据，

00:09:12,640 --> 00:09:16,480
它都会输出相同的结果。

00:09:16,480 --> 00:09:22,080
它会以相同的方式混淆它，以产生这个随机的数据字符串。

00:09:22,080 --> 00:09:23,600
并且这个字符串的长度总是固定的，

00:09:23,600 --> 00:09:26,880
为32字节或64个字符，

00:09:26,880 --> 00:09:32,560
每个字节由两个字符组成。

00:09:32,560 --> 00:09:38,160
如果你对输入到哈希函数中的数据做一个微小的调整，

00:09:38,160 --> 00:09:43,200
比如从a1变为a2，

00:09:43,200 --> 00:09:45,519
结果会完全不同。

00:09:45,519 --> 00:09:47,600
这只是一个微小的改变，

00:09:47,600 --> 00:09:51,440
但哈希函数的输出结果却发生了巨大的变化。

00:09:51,440 --> 00:09:54,399
同样，再次输入a3，

00:09:54,399 --> 00:09:55,839
即使只是微小的调整，

00:09:55,839 --> 00:09:57,440
输出结果仍然会完全不同。

00:09:57,440 --> 00:10:01,839
哈希函数的另一个重要特性是，

00:10:01,839 --> 00:10:06,880
如果你事先不知道结果，

00:10:06,880 --> 00:10:11,200
就无法预测a2会输出什么。

00:10:11,200 --> 00:10:11,920
所以结论是，

00:10:11,920 --> 00:10:15,760
哈希函数有不可逆性，

00:10:15,760 --> 00:10:19,440
从结果的哈希值不能推导出原始输入。

00:10:19,440 --> 00:10:22,959
这个特性非常有用，

00:10:22,959 --> 00:10:24,160
我们稍后会进一步讨论。

00:10:24,160 --> 00:10:25,760
最后，

00:10:25,760 --> 00:10:30,079
尽管这看起来像一个随机的数据字符串，

00:10:30,079 --> 00:10:31,440
它包含了字母f、e、a，

00:10:31,440 --> 00:10:34,959
基本上是a、b、c、d、e和f，

00:10:34,959 --> 00:10:37,760
但它们实际上可以转换成数字。

00:10:37,760 --> 00:10:44,839
这是因为我们习惯于使用十进制格式的数字，

00:10:44,839 --> 00:10:48,320
它使用0到9的数字，

00:10:48,320 --> 00:10:52,880
但你也有一种叫做十六进制的数字格式，

00:10:52,880 --> 00:10:55,760
它使用相同的数字，

00:10:55,760 --> 00:10:59,360
但也包括a、b、c、d、e和f，

00:10:59,360 --> 00:11:01,680
当你转换它们时，

00:11:01,680 --> 00:11:04,240
它们就像这样。

00:11:04,480 --> 00:11:05,519
所以，

00:11:05,519 --> 00:11:07,279
这被称为十进制，

00:11:07,279 --> 00:11:08,160
因为它使用10，

00:11:08,160 --> 00:11:12,720
deci在拉丁语中意思是10。

00:11:12,720 --> 00:11:15,040
十六进制，也叫做hexa，

00:11:15,040 --> 00:11:18,800
hexa就像六边形一样有六个边，

00:11:18,800 --> 00:11:19,519
deci代表10，

00:11:19,519 --> 00:11:21,920
所以6和10加起来就是16。

00:11:21,920 --> 00:11:23,920
这是我们人类常用的表示方式，

00:11:23,920 --> 00:11:26,560
但计算机更喜欢以十六进制的格式来读取数字。

00:11:26,560 --> 00:11:28,560
简单来说，

00:11:28,560 --> 00:11:30,800
你只需要将数据输入到哈希函数中，

00:11:30,800 --> 00:11:36,000
它会输出一个随机数作为结果。

00:11:36,000 --> 00:11:43,760
如果你看到一个十六进制格式的字符串，

00:11:43,760 --> 00:11:46,480
你只需要记住这其实就是一个随机数。

00:11:46,480 --> 00:11:49,680
这个概念很容易理解了吧？

00:11:49,680 --> 00:11:51,360
好的，

00:11:51,360 --> 00:11:52,240
这就是哈希函数的基本概念，

00:11:52,240 --> 00:11:54,399
它只是一个能够输出随机数据的小工具。

00:11:54,399 --> 00:11:58,240
让我给你们快速演示一下，

00:11:58,240 --> 00:11:59,760
我不确定你们是否能看清楚，

00:11:59,760 --> 00:12:03,760
或者是否能理解，

00:12:03,760 --> 00:12:06,959
但如果你能明白，

00:12:06,959 --> 00:12:08,720
哈希函数在很多编程语言中都有。

00:12:08,720 --> 00:12:11,360
例如，在PHP中，

00:12:11,360 --> 00:12:16,720
有一个叫做hash()的函数，

00:12:16,720 --> 00:12:20,560
你可以指定你想要使用的哈希函数，

00:12:20,560 --> 00:12:22,079
比如sha256，

00:12:22,079 --> 00:12:23,920
这是比特币中使用的一种哈希函数。

00:12:23,920 --> 00:12:29,959
sha256代表的是简单哈希算法256位，

00:12:29,959 --> 00:12:34,480
表示它的输出结果的大小。

00:12:34,480 --> 00:12:36,560
然后你只需要将你想要哈希的内容输入进去。

00:12:36,560 --> 00:12:38,800
好了。

00:12:38,800 --> 00:12:41,440
这就是结果，

00:12:51,200 --> 00:12:57,440
哈希函数可以在任何编程语言中使用。

00:12:57,440 --> 00:12:59,920
我刚刚向你们展示了如何在PHP中使用它，

00:12:59,920 --> 00:13:04,000
现在我将在Ruby中展示。

00:13:04,000 --> 00:13:08,240
在Ruby中，

00:13:08,240 --> 00:13:10,160
哈希函数包含在'digest'库中，

00:13:10,160 --> 00:13:18,480
你可以输入'puts digest::SHA56'，

00:13:18,480 --> 00:13:21,839
然后我们需要一个十六进制摘要。

00:13:21,839 --> 00:13:26,000
这里的“摘要”只是从哈希函数中得到的结果的另一个名称。

00:13:26,000 --> 00:13:28,560
我将“a1”作为输入，

00:13:28,560 --> 00:13:30,639
得到的结果与之前是一样的。

00:13:30,639 --> 00:13:31,839
因此，

00:13:31,839 --> 00:13:39,279
哈希函数在许多编程语言中都是可用的。

00:13:39,279 --> 00:13:44,079
现在我将介绍挖矿的基本原理，

00:13:44,079 --> 00:13:49,360
我将给出一个简单的例子，

00:13:49,360 --> 00:13:53,040
并通过一个简单的例子来说明

00:13:53,040 --> 00:13:58,639
如何从内存池中获取交易并将其添加到区块链中。

00:13:58,639 --> 00:14:00,320
挖矿的基本原理是，

00:14:00,320 --> 00:14:02,079
所有的交易都存储在内存池中。

00:14:02,079 --> 00:14:16,399
*调整麦克风*

00:14:16,399 --> 00:14:19,199
我们继续，假设这台计算机是一个节点，

00:14:19,199 --> 00:14:20,880
也就是一个矿工，

00:14:20,880 --> 00:14:22,800
我们来看看它的内部，

00:14:22,800 --> 00:14:27,600
看看它是如何从内存池中获取交易并将其添加到文件中的。

00:14:28,480 --> 00:14:41,680
*他调整麦克风*

00:14:41,680 --> 00:14:46,079
我们继续，查看比特币矿工的内部情况。

00:14:46,079 --> 00:14:47,680
这是内存池，

00:14:47,680 --> 00:14:49,680
其中红色部分表示交易。

00:14:49,680 --> 00:14:52,240
交易存储在内存池中，

00:14:52,240 --> 00:14:56,639
而一个内存池可以存储多个交易。

00:14:56,639 --> 00:15:00,959
假设这个内存池已经存储了很多交易。

00:15:00,959 --> 00:15:08,079
矿工会创建一个叫做候选块的容器，

00:15:08,079 --> 00:15:12,240
这只是一个存储交易的容器。

00:15:12,240 --> 00:15:18,800
他们会从内存池中取出交易，

00:15:18,800 --> 00:15:21,519
填充到这个候选块中，

00:15:21,519 --> 00:15:26,480
然后他们会试图将这个交易块添加到区块链上。

00:15:26,480 --> 00:15:36,880
那么，他们是如何将自己构建的候选块添加到区块链上的呢？

00:15:36,880 --> 00:15:38,880
首先，

00:15:38,880 --> 00:15:41,839
他们会构建一个被称为区块头的东西，

00:15:41,839 --> 00:15:44,000
这其实就是块内所有数据的摘要，

00:15:44,000 --> 00:15:47,839
包括所有区块内的交易。

00:15:47,839 --> 00:15:49,680
在这个区块头中，

00:15:49,680 --> 00:15:51,199
你会看到一个被称为版本的东西，

00:15:51,199 --> 00:15:54,800
这其实就是数据结构的版本号，

00:15:54,800 --> 00:15:56,639
假设这个版本号是1。

00:15:56,639 --> 00:15:59,199
此外，还会有一些

00:15:59,199 --> 00:16:03,680
被称为前一个区块或前一个区块哈希的信息。

00:16:03,680 --> 00:16:05,600
这个工作原理是，

00:16:05,600 --> 00:16:08,800
假设这是区块链，

00:16:08,800 --> 00:16:14,320
他们正在构建的这个候选块必须建立在这些区块之一的顶部。

00:16:14,320 --> 00:16:20,160
所以挖矿者会做的是，

00:16:20,160 --> 00:16:25,040
他们会包含他们想要建立在其顶部的区块的哈希或区块哈希，

00:16:25,040 --> 00:16:28,079
这就像是一个区块的ID号。

00:16:28,079 --> 00:16:29,360
所以在这里，

00:16:29,360 --> 00:16:32,800
这是这个区块的区块哈希。

00:16:32,800 --> 00:16:37,360
这其实就是表明他们想要在哪个区块的顶部建立新的区块，

00:16:37,360 --> 00:16:43,279
因为每个挖矿者基本上都想要在区块链的顶部进行建立。

00:16:43,279 --> 00:16:47,040
接下来我来解释一下什么是“默克尔根”，

00:16:47,040 --> 00:16:48,720
如果你把所有的交易ID一起哈希，

00:16:48,720 --> 00:16:52,639
然后反复的哈希，

00:16:52,639 --> 00:16:55,199
你最后会得到一个单独的哈希，

00:16:55,199 --> 00:16:59,120
这就叫做默克尔根。

00:16:59,120 --> 00:17:00,240
就像这样，

00:17:00,240 --> 00:17:02,639
这就像一个指纹，

00:17:02,639 --> 00:17:04,959
一个数字指纹，

00:17:04,959 --> 00:17:12,160
总结了区块中的所有交易。

00:17:12,160 --> 00:17:14,319
所以，

00:17:14,319 --> 00:17:17,119
这个区块头，

00:17:17,119 --> 00:17:18,720
它创建了一个独特的指纹，

00:17:18,720 --> 00:17:21,839
用于表示所有的区块数据，

00:17:21,839 --> 00:17:24,160
但使用的数据比所有的交易数据组合起来要少得多。

00:17:24,160 --> 00:17:28,720
或许你能谈一谈默克尔树？

00:17:28,720 --> 00:17:34,160
因为我对他不是太了解。

00:17:34,160 --> 00:17:36,400
你是在哈希每一笔交易，

00:17:36,400 --> 00:17:40,640
然后哈希那些结果吗？

00:17:40,640 --> 00:17:42,960
是的，我会在后面的技术部分详细介绍这个，

00:17:42,960 --> 00:17:44,720
但现在你只需要知道，

00:17:50,799 --> 00:17:52,720
默克尔树是对所有区块交易的一个总结。

00:17:52,720 --> 00:17:54,720
默克尔树的存在非常有意义。

00:17:54,720 --> 00:17:57,520
稍后我会解释默克尔树是如何工作的，

00:17:57,520 --> 00:18:00,000
以及为什么要使用默克尔树，

00:18:00,000 --> 00:18:02,240
你提了一个好问题。

00:18:02,240 --> 00:18:04,000
接下来是区块头，

00:18:04,000 --> 00:18:07,600
我并没有详细介绍区块头数据的所有，

00:18:07,600 --> 00:18:09,520
那么这就是是最重要的东西。

00:18:09,520 --> 00:18:14,880
现在我们有了一个区块头，

00:18:14,880 --> 00:18:19,919
下一步就是将这个区块头数据放入哈希函数，

00:18:19,919 --> 00:18:23,200
也就是SHA-256哈希函数，

00:18:23,200 --> 00:18:27,600
这将产生一个随机的结果，

00:18:27,600 --> 00:18:31,919
这就是我们所说的区块哈希。

00:18:32,000 --> 00:18:34,480
你到现在为止有任何问题吗？

00:18:34,480 --> 00:18:35,919
好的，

00:18:35,919 --> 00:18:38,559
这很好，我们继续，

00:18:38,559 --> 00:18:43,760
那么，为什么矿工要这么做呢？

00:18:43,760 --> 00:18:46,240
或者说，这如何帮助他们将区块挖掘到区块链上呢？

00:18:46,240 --> 00:18:47,600
如果这个区块哈希，

00:18:47,600 --> 00:18:54,960
也就是将区块头输入哈希函数产生的结果，

00:18:54,960 --> 00:19:00,160
生成的哈希值低于“目标值”，

00:19:00,160 --> 00:19:02,320
就像这样，

00:19:02,320 --> 00:19:06,640
假设这是当前的目标值，

00:19:07,200 --> 00:19:15,120
这是每个比特币节点内部的一个数字，

00:19:15,120 --> 00:19:19,600
他们都有一个共享的目标值，

00:19:19,600 --> 00:19:23,840
这个目标值会与其他节点同步计算。

00:19:23,840 --> 00:19:28,720
他们能让他们的区块哈希值低于这个目标值，

00:19:28,720 --> 00:19:30,320
那么这个区块就可以被添加到区块链上。

00:19:30,320 --> 00:19:32,480
那么这个问题基本上已经解决了。

00:19:32,480 --> 00:19:34,320
所以，

00:19:34,320 --> 00:19:35,919
到目前为止，

00:19:35,919 --> 00:19:38,480
这是我们的第一次尝试，

00:19:38,480 --> 00:19:40,160
你们可以看到，

00:19:40,160 --> 00:19:43,840
这个数字明显大于目标值，

00:19:43,840 --> 00:19:45,600
因此，它并没有达到目标。

00:19:45,600 --> 00:19:48,160
所以，

00:19:48,160 --> 00:19:55,039
这第一次尝试将区块添加到区块链上失败了。

00:19:55,039 --> 00:19:59,200
然而，矿工并没有因此而放弃。

00:19:59,200 --> 00:20:00,880
在区块头中，

00:20:00,880 --> 00:20:06,480
有一个额外的字段叫做nonce，

00:20:06,480 --> 00:20:12,400
这是一个一次性使用的数字。

00:20:12,400 --> 00:20:16,240
这是一个开放的字段，

00:20:16,240 --> 00:20:20,240
矿工可以自由地放入他们自己的数字或数据。

00:20:20,240 --> 00:20:22,960
所以，

00:20:22,960 --> 00:20:24,480
如果区块头的第一次尝试失败，

00:20:24,480 --> 00:20:28,559
他们可以改变nonce值或改变nonce中的数据。

00:20:28,559 --> 00:20:31,120
例如，

00:20:31,120 --> 00:20:33,520
第一次尝试可能他们在那里放了数字零，

00:20:33,520 --> 00:20:35,600
如果那失败了，

00:20:35,600 --> 00:20:37,840
他们会改变nonce，

00:20:37,840 --> 00:20:39,600
然后再次将区块头通过哈希函数。

00:20:39,600 --> 00:20:41,919
因为我们只做了一点小的调整

00:20:41,919 --> 00:20:44,880
就像我之前给你们展示的哈希函数，

00:20:44,880 --> 00:20:50,080
小的调整可以产生完全不同的结果。

00:20:50,080 --> 00:20:54,720
因此，矿工会构造一个区块头，

00:20:54,720 --> 00:20:58,720
并不断改变这个nonce值，

00:20:58,720 --> 00:21:04,159
希望结果会产生一个低于目标值的区块哈希。

00:21:04,159 --> 00:21:08,080
所以，矿工实际上是创建一个区块头，

00:21:08,080 --> 00:21:09,919
然后在末尾添加一个nonce，

00:21:09,919 --> 00:21:12,400
如果不成功，

00:21:12,400 --> 00:21:14,840
他们会不断增加尝试，

00:21:14,840 --> 00:21:17,679
这完全是随机的，

00:21:17,679 --> 00:21:19,200
…这只是纯粹的随机性和纯粹的运气…

00:21:19,200 --> 00:21:25,440
他们有可能能够猜到一个有效的随机数，

00:21:25,440 --> 00:21:30,400
产生一个低于目标的区块哈希。

00:21:30,400 --> 00:21:32,640
如果，

00:21:32,640 --> 00:21:38,000
这个特定的非常高的随机数成功地产生了一个区块哈希结果。

00:21:38,000 --> 00:21:39,280
然后，

00:21:39,280 --> 00:21:43,120
这个节点会将该区块添加到他们的区块链中，

00:21:43,120 --> 00:21:50,640
并将这个已经解决的候选区块传递给他们所连接的所有节点。

00:21:50,640 --> 00:21:58,000
他们会检查并验证区块头确实产生了一个低于目标的区块哈希，

00:21:58,000 --> 00:22:00,880
然后将其添加到文件中，

00:22:00,880 --> 00:22:05,360
剔除包含在该区块中的任何冲突交易，

00:22:05,360 --> 00:22:08,240
然后像这样传递区块。

00:22:08,240 --> 00:22:09,360
他们也会做同样的事情。

00:22:09,360 --> 00:22:13,679
这就是挖矿在基本层面上的工作方式。

00:22:13,679 --> 00:22:19,440
我有个问题，

00:22:19,440 --> 00:22:24,559
你说的目标值，

00:22:24,840 --> 00:22:28,559
每个节点都有自己的目标值，对吗？

00:22:28,559 --> 00:22:30,480
我想过这个问题，

00:22:30,480 --> 00:22:37,919
但是有可能我挖到的区块低于我的目标值，

00:22:37,919 --> 00:22:40,960
然后我把它给我的相邻节点，

00:22:40,960 --> 00:22:44,400
可能目标值已经改变了，

00:22:44,400 --> 00:22:46,799
或者出于某种原因，

00:22:46,799 --> 00:22:49,039
其他节点的目标值不同。

00:22:49,039 --> 00:22:51,600
是的，

00:22:51,600 --> 00:22:53,760
我明白你的问题。

00:22:53,760 --> 00:22:59,360
我想我已经解释过目标值了，

00:22:59,360 --> 00:23:02,159
可能我没有解释清楚，

00:23:02,159 --> 00:23:11,919
我再解释一下。

00:23:11,919 --> 00:23:17,440
目标值的存在是为了确保每10分钟会有一个新的区块被挖出。

00:23:17,520 --> 00:23:19,760
然而，

00:23:19,760 --> 00:23:29,600
如果有更多的计算机以更快的速度进行哈希运算，

00:23:29,600 --> 00:23:32,880
那么一个区块可能会在10分钟内被挖出。

00:23:32,880 --> 00:23:34,240
因此，

00:23:34,240 --> 00:23:38,559
这个目标值会根据实际情况进行调整，

00:23:38,559 --> 00:23:44,480
以确保每10分钟挖出一个新的区块。

00:23:44,480 --> 00:23:48,080
当你首次运行比特币并挖出第一个区块时，

00:23:48,080 --> 00:23:53,919
目标值是硬编码在这个值中的。

00:23:53,919 --> 00:23:57,039
然后，每过2016个区块，

00:23:59,200 --> 00:24:02,000
或者大约每两周，

00:24:02,000 --> 00:24:09,120
每个节点都会查看挖出最后2016个区块所需的时间。

00:24:09,120 --> 00:24:14,559
理想情况下，这个时间应该是20160分钟，

00:24:14,559 --> 00:24:18,880
但如果实际挖出这些区块的时间少于这个时间，

00:24:18,880 --> 00:24:21,120
那么目标值就会进行调整。

00:24:21,120 --> 00:24:25,200
目标值的调整是按照一定的比例进行的。

00:24:25,200 --> 00:24:26,000
比如，

00:24:26,000 --> 00:24:29,679
如果所有的区块都被挖掘得更快，

00:24:29,679 --> 00:24:32,960
那么这个比例就是0.9。

00:24:32,960 --> 00:24:34,880
你将看到，

00:24:34,880 --> 00:24:36,720
这个目标值会向下调整。

00:24:36,720 --> 00:24:38,880
每个节点在接收到一个新的区块后，

00:24:38,880 --> 00:24:41,279
每2016个区块，

00:24:41,279 --> 00:24:45,360
他们都会做这个精确的计算。

00:24:45,360 --> 00:24:47,520
虽然每个节点都从这个值开始，

00:24:47,520 --> 00:24:49,520
但是如果每个人都在同一个区块，

00:24:49,520 --> 00:24:53,840
他们都会计算出同样的目标值。

00:24:53,840 --> 00:24:59,840
所以，虽然每个人都有自己的计算目标，

00:24:59,840 --> 00:25:02,000
但是因为他们都接收到同样的区块，

00:25:02,000 --> 00:25:04,159
他们都会计算出同样的目标值。

00:25:04,159 --> 00:25:07,520
所以每个人的目标值并不会有所不同，

00:25:07,520 --> 00:25:10,799
他们都有同样的计算目标。

00:25:10,799 --> 00:25:13,360
所以再次强调，

00:25:13,360 --> 00:25:14,880
这每2016个区块就会发生一次，

00:25:14,880 --> 00:25:18,240
之前我说的事情会发生，

00:25:18,240 --> 00:25:19,440
他们花了多长时间，

00:25:19,440 --> 00:25:22,720
比例是多少，如果挖掘速度更快，

00:25:23,360 --> 00:25:24,240
那么难度就会再次向下调整，

00:25:24,240 --> 00:25:26,559
就像这样。

00:25:26,960 --> 00:25:29,120
那么，

00:25:29,120 --> 00:25:31,279
这就是目标值（Target）的工作原理。

00:25:31,279 --> 00:25:36,159
到目前为止，

00:25:36,159 --> 00:25:39,520
我一直将区块链描述为一个共享文件，

00:25:39,520 --> 00:25:41,919
这个共享文件就是由一系列区块构成的链。

00:25:41,919 --> 00:25:45,440
基本上，这个共享文件充满了交易记录，

00:25:45,440 --> 00:25:48,559
因为交易是以区块的形式添加进去的，

00:25:48,559 --> 00:25:50,240
每个区块都在前一个区块的基础上构建，

00:25:50,240 --> 00:25:52,480
因此这个文件被称为区块链。

00:25:52,480 --> 00:25:54,559
对于比特币来说，

00:25:54,559 --> 00:25:56,240
它就是一个这样的共享文件，

00:25:56,240 --> 00:25:57,919
我们称之为区块链。

00:25:57,919 --> 00:26:00,320
所以如果我更新这个图，

00:26:00,320 --> 00:26:06,000
你可以把这个共享文件想象成一堆堆叠在一起的区块。

00:26:06,000 --> 00:26:07,520
最后，

00:26:07,520 --> 00:26:09,679
为什么有人会挖矿呢？

00:26:09,679 --> 00:26:11,279
对于矿工来说，

00:26:11,279 --> 00:26:15,679
他们为什么愿意使用电脑的全部算力，

00:26:15,679 --> 00:26:20,799
尝试从内存池中挖掘交易并添加到区块链中呢？

00:26:20,799 --> 00:26:25,520
这是因为每次矿工成功挖掘一个区块，

00:26:25,520 --> 00:26:27,919
们都会得到一个叫做区块奖励的东西。

00:26:27,919 --> 00:26:30,159
最初的区块奖励是50比特币，

00:26:30,159 --> 00:26:34,559
但大约每四年就会减半。

00:26:34,799 --> 00:26:37,600
这就是挖掘区块的激励。

00:26:37,600 --> 00:26:40,640
当矿工构建候选区块时，

00:26:40,640 --> 00:26:45,120
他们会得到这个区块奖励。

00:26:45,120 --> 00:26:49,440
而且第一笔交易是他们自己的。

00:26:49,440 --> 00:26:55,600
矿工会把他们自己的交易放在最顶部，

00:26:55,600 --> 00:26:57,039
这被称为coinbase交易。

00:26:57,039 --> 00:27:01,440
这是一种特殊的交易方式，

00:27:01,440 --> 00:27:07,440
允许他们向自己发送一定数量的比特币，

00:27:07,440 --> 00:27:12,240
而这些比特币在之前并不存在。

00:27:12,240 --> 00:27:13,039
因此，

00:27:13,039 --> 00:27:16,320
如果这个区块被挖掘到区块链上，

00:27:16,320 --> 00:27:19,600
他们可以通过这种coinbase交易来接收新的比特币。

00:27:19,600 --> 00:27:21,440
他们在这里放置自己的比特币地址，

00:27:21,440 --> 00:27:25,360
以便接收区块奖励，

00:27:25,360 --> 00:27:28,960
这都得益于coinbase交易。

00:27:28,960 --> 00:27:30,640
简单总结一下挖矿的基本步骤，

00:27:30,640 --> 00:27:34,480
矿工会从内存池中获取交易，

00:27:34,480 --> 00:27:37,200
然后在顶部放置他们的coinbase交易，

00:27:37,200 --> 00:27:40,080
这样如果他们成功将这个区块挖掘到区块链上，

00:27:40,080 --> 00:27:41,600
就可以接收到区块奖励。

00:27:41,600 --> 00:27:45,679
接下来，他们会创建一个区块头并对其进行哈希运算。

00:27:45,679 --> 00:27:48,000
他们希望哈希值低于目标值，

00:27:48,000 --> 00:27:49,679
如果不是，

00:27:49,679 --> 00:27:52,000
他们会不断调整nonce，

00:27:52,000 --> 00:27:58,159
直到找到一个nonce使得区块哈希值低于目标值，

00:27:58,159 --> 00:28:01,440
然后将区块添加到区块链上。

00:28:01,440 --> 00:28:03,840
像这样。

00:28:04,080 --> 00:28:06,320
你明白了吗？

00:28:06,320 --> 00:28:08,159
好的，

00:28:08,159 --> 00:28:16,240
接下来我将向你展示一个小型的挖矿模拟器。

00:28:16,240 --> 00:28:27,279
这就是比特币矿机在内部的运作方式。

00:28:27,279 --> 00:28:31,600
他们会进入内存池，

00:28:31,600 --> 00:28:34,080
从中获取交易。

00:28:34,080 --> 00:28:40,000
这个挖矿模拟器正在挖掘一个已经被挖掘过的区块，

00:28:40,000 --> 00:28:41,679
这是很久以前的事情，

00:28:41,679 --> 00:28:43,279
当时内存池中只有13个交易。

00:28:43,279 --> 00:28:45,440
现在显然交易数量已经增加了。

00:28:45,440 --> 00:28:46,720
接下来他们会做什么呢？

00:28:46,720 --> 00:28:48,240
它们会构建区块头，

00:28:48,240 --> 00:28:52,399
我还没有介绍区块头的最后两部分，

00:28:52,399 --> 00:28:53,679
不过别担心，

00:28:53,679 --> 00:28:54,640
我马上就会介绍。

00:28:54,640 --> 00:29:00,640
这些数据包括前一个区块的默克尔根和版本号等信息。

00:29:00,640 --> 00:29:03,440
然后他们会做的是，

00:29:03,440 --> 00:29:06,720
所有这些数据会被压缩成一行。

00:29:06,720 --> 00:29:08,480
我在这里预留了一些空间用于nonce，

00:29:08,480 --> 00:29:11,520
这是区块头数据，

00:29:11,520 --> 00:29:13,840
这是目标值。

00:29:13,840 --> 00:29:18,080
接下来，矿工们会取这个区块头，

00:29:18,080 --> 00:29:19,760
并在其中放入一个nonce，

00:29:19,760 --> 00:29:22,640
然后不断增加它，

00:29:22,640 --> 00:29:24,399
正如你现在看到的。

00:29:24,399 --> 00:29:26,240
这是一个非常慢的矿工，

00:29:26,240 --> 00:29:30,720
你可以看到左边的随机数值，

00:29:30,720 --> 00:29:33,919
这些是区块头正在产生的不同的哈希值。

00:29:33,919 --> 00:29:35,760
好的，

00:29:35,760 --> 00:29:39,120
所以当你在顶部创建那个字符串时，

00:29:39,120 --> 00:29:42,080
那并没有包括交易，

00:29:42,080 --> 00:29:45,440
只包括了区块头？

00:29:45,440 --> 00:29:46,159
是的

00:29:46,159 --> 00:29:51,279
你说得对。

00:29:51,279 --> 00:29:55,600
交易实际上是包含在默克尔根中的，

00:29:55,600 --> 00:29:58,720
默克尔根是所有交易的摘要，

00:29:58,720 --> 00:30:03,039
它指向区块中的所有交易。

00:30:03,039 --> 00:30:05,760
这里是矿工的代码，

00:30:05,760 --> 00:30:11,600
它只是挖掘一个区块头，

00:30:11,600 --> 00:30:15,200
我已经在网站上提供了这个代码，

00:30:15,200 --> 00:30:17,200
稍后我会给你一个链接。

00:30:17,200 --> 00:30:21,440
对于这个特定的矿工，

00:30:21,440 --> 00:30:29,200
我知道成功的哈希是什么。

00:30:29,520 --> 00:30:34,000
让我们把这个减少100。

00:30:34,000 --> 00:30:37,200
如果我再次启动这个，

00:30:37,200 --> 00:30:41,520
我已经增加了开始的nonce值，

00:30:41,520 --> 00:30:43,840
所以再次强调，这是区块头。

00:30:43,840 --> 00:30:45,200
这次，我们的随机数不是从0开始，

00:30:45,200 --> 00:30:47,360
而是从一个更大的数字开始。

00:30:47,360 --> 00:30:49,679
如果我现在启动程序，

00:30:49,679 --> 00:30:53,919
它会在大约100次尝试后

00:30:53,919 --> 00:30:55,919
找到一个低于目标值的区块哈希时，

00:30:55,919 --> 00:30:57,760
然后停止运行。

00:30:57,919 --> 00:31:01,200
让我们来看看，

00:31:01,200 --> 00:31:02,880
如果你看到这个，

00:31:02,880 --> 00:31:04,480
那就说明区块已经被成功挖出来了。

00:31:04,480 --> 00:31:08,000
这个特定的区块哈希完全是随机的，

00:31:08,000 --> 00:31:12,320
纯粹是运气使得它以这么多个零开头，

00:31:12,320 --> 00:31:14,240
这个值低于目标值，

00:31:14,240 --> 00:31:16,080
所以，矿工们就是这样挖矿的，

00:31:16,080 --> 00:31:18,640
他们只是获取一个区块头，

00:31:18,640 --> 00:31:21,360
改变其中的随机数，然后尽可能快地进行哈希运算。

00:31:21,360 --> 00:31:23,279
这个过程有没有让你感到困惑呢？

00:31:23,279 --> 00:31:24,880
好的，

00:31:24,880 --> 00:31:29,440
我会在最后添加一些链接，

00:31:29,440 --> 00:31:32,720
你去网站learnmebitcoin.com查看相关的代码部分，

00:31:32,720 --> 00:31:37,519
我已经把挖矿模拟器的代码放在那里了。

00:31:37,519 --> 00:31:40,320
这些代码是用Ruby语言编写的，

00:31:40,320 --> 00:31:44,799
我认为这是一种简单易读的语言，

00:31:44,799 --> 00:31:47,440
类似于Python。

00:31:47,440 --> 00:31:49,200
我尽量让这个过程尽可能简单，

00:31:49,200 --> 00:31:51,120
所以如果你想开始哈希你自己的区块头，

00:31:51,120 --> 00:31:53,120
你完全可以这样做。

00:31:53,120 --> 00:31:55,039
你也可以直接在浏览器上

00:31:55,039 --> 00:32:00,080
打开learnmeabitcoin.com网站。

00:32:00,080 --> 00:32:04,480
你将能够看到最新的区块，

00:32:04,480 --> 00:32:07,200
这些都是区块头，

00:32:07,200 --> 00:32:10,640
如果你点击序列化，

00:32:10,880 --> 00:32:14,399
它会显示序列化的代码，

00:32:14,399 --> 00:32:16,399
如果你对这个代码进行哈希运算，

00:32:16,399 --> 00:32:21,919
它会产生这个区块头，

00:32:21,919 --> 00:32:23,679
这是一个候选区块,

00:32:23,679 --> 00:32:26,559
你可以尝试做同样的事情。

00:32:26,559 --> 00:32:30,159
我很好奇，

00:32:30,159 --> 00:32:35,679
这个是在你的机器上运行的吗？

00:32:35,679 --> 00:32:38,159
这是实时的吗？

00:32:38,159 --> 00:32:39,919
是的，这是实时的。

00:32:39,919 --> 00:32:41,840
这是一个实时的候选区块，

00:32:41,840 --> 00:32:45,760
这些都是实时的交易，

00:32:46,000 --> 00:32:54,080
一切都能浏览器上看到。

00:32:54,559 --> 00:32:58,480
好的，

00:32:58,480 --> 00:33:01,200
这就是基础知识的介绍。

00:33:01,200 --> 00:33:04,559
现在我将从技术角度来讲解，

00:33:04,559 --> 00:33:06,159
基本上我要讲一遍同样的事情，

00:33:06,159 --> 00:33:10,559
不过我是从程序员的角度来讲解。

00:33:10,559 --> 00:33:16,720
如果你对编程和挖矿感兴趣，

00:33:16,720 --> 00:33:19,039
这基本上就是和之前同样的内容，

00:33:19,039 --> 00:33:21,120
只是我从程序员的角度来讲述。

00:33:21,120 --> 00:33:23,120
再次重复，

00:33:23,120 --> 00:33:27,200
从内存池中获取交易，

00:33:27,200 --> 00:33:30,240
填充你的区块，

00:33:30,240 --> 00:33:34,000
然后你会得到一个候选区块，

00:33:34,000 --> 00:33:38,159
然后你在顶部放置你的coinbase交易。

00:33:38,159 --> 00:33:41,840
一个区块的第一笔交易总是coinbase交易，

00:33:41,840 --> 00:33:45,120
这是矿工放在那里的。

00:33:45,120 --> 00:33:46,960
这样你就可以领取区块奖励，

00:33:46,960 --> 00:33:50,159
当前是比特币12.5个。

00:33:50,159 --> 00:33:51,600
在选择了所有这些交易之后，

00:33:51,600 --> 00:33:56,080
你会将coinbase交易放在区块的顶部的原因是什么？

00:33:56,080 --> 00:33:57,360
每一笔交易都会有一个费用，

00:33:57,360 --> 00:34:02,559
通过你的coinbase交易，

00:34:02,559 --> 00:34:07,760
你可以收集所有这些费用。

00:34:07,760 --> 00:34:12,560
所以，coinbase交易不仅仅是接收12.5个区块奖励，

00:34:12,560 --> 00:34:14,239
你还可以根据这些费用的价值，

00:34:14,239 --> 00:34:17,040
给自己发送13个或更多的比特币。

00:34:17,040 --> 00:34:19,040
所以，

00:34:19,040 --> 00:34:23,520
coinbase交易包括了费用是吗？

00:34:23,520 --> 00:34:25,280
是的，

00:34:25,280 --> 00:34:27,599
coinbase交易不仅包括挖矿奖励，

00:34:27,599 --> 00:34:31,520
还包括基础级别的区块奖励。

00:34:31,520 --> 00:34:33,760
你可以根据每笔交易的费用，

00:34:33,760 --> 00:34:38,239
决定给自己发送多少比特币。

00:34:38,239 --> 00:34:38,239
这也就意味着，

00:34:38,239 --> 0:34:50,800
矿工们更倾向于选择交易费更高的交易。

00:34:50,800 --> 00:34:54,879
我还有一个问题，

00:34:54,879 --> 00:34:59,839
左边是费用，

00:34:59,839 --> 00:35:05,760
右边是挖矿所需的时间。

00:35:05,760 --> 00:35:08,160
这是否意味着，

00:35:08,160 --> 00:35:12,000
如果我们设置的交易费非常低，

00:35:12,000 --> 00:35:16,880
那么我们的交易可能永远不会被记录在区块中？

00:35:16,880 --> 00:35:19,040
这种情况在你觉得是否可能发生？

00:35:19,040 --> 00:35:21,280
是的，可能发生的。

00:35:21,280 --> 00:35:23,359
当你进行一笔交易时，

00:35:23,359 --> 00:35:26,079
它首先会进入内存池。

00:35:26,079 --> 00:35:28,640
如果内存池中的交易很多，

00:35:28,640 --> 00:35:36,640
那么你的交易就要和其他所有交易竞争区块中的空间。

00:35:36,640 --> 00:35:38,720
因为一个区块的大小是有限的，

00:35:38,720 --> 00:35:43,839
以前是1MB，

00:35:43,839 --> 00:35:44,880
现在大约是1.7MB，

00:35:44,880 --> 00:35:46,640
它使用了一个叫做权重的不同度量标准，

00:35:46,640 --> 00:35:48,320
但我现在不打算讲这个。

00:35:48,320 --> 00:35:50,160
那么，会发生的情况是，

00:35:50,160 --> 00:35:53,040
如果你设置的交易费太低，

00:35:53,040 --> 00:35:54,960
以至于它没有被记录在区块中，

00:35:54,960 --> 00:35:58,800
而是仍然停留在内存池中，

00:35:58,800 --> 00:36:05,520
那么如果你的交易在内存池中停留的时间超过72小时，

00:36:05,520 --> 00:36:10,640
你的交易就会被从内存池中移除。

00:36:10,640 --> 00:36:11,440
所以，

00:36:11,440 --> 00:36:15,440
如果你在交易中设置了非常低的交易费，

00:36:15,440 --> 00:36:18,000
那么你的交易可能永远不会被选入候选区块，

00:36:18,000 --> 00:36:20,640
甚至不会被记录在区块链上。

00:36:20,640 --> 00:36:22,320
那么，根据你的经验，

00:36:22,320 --> 00:36:26,480
根据你的经验，

00:36:26,480 --> 00:36:28,320
如果我想给某人寄五美元，

00:36:28,320 --> 00:36:30,720
或者买一杯三美元的咖啡，

00:36:30,720 --> 00:36:35,839
我需要支付的最低费用是多少呢？

00:36:35,839 --> 00:36:42,960
我知道钱包通常会帮助你处理这个问题，

00:36:42,960 --> 00:36:49,839
但我不确定他们是否设定了这个费用。

00:36:49,839 --> 00:36:52,079
我会做的一种方式是，

00:36:52,079 --> 00:36:54,960
我会查看候选区块。

00:36:54,960 --> 00:36:56,960
一般来说，

00:36:56,960 --> 00:36:58,640
候选区块中的交易是按照费用从高到低排序的，

00:36:58,640 --> 00:37:01,359
虽然这并不完全准确，

00:37:01,359 --> 00:37:04,960
但我会查看候选区块的底部，

00:37:04,960 --> 00:37:09,920
看看最低的费用是多少，

00:37:09,920 --> 00:37:16,960
然后设定一个比这个费用稍高的费用。

00:37:16,960 --> 00:37:23,040
我认为这是最简单的方法。

00:37:23,040 --> 00:37:25,599
所以，这是按每字节收费的吗？

00:37:25,599 --> 00:37:28,480
是的，这是按字节计费的，

00:37:28,480 --> 00:37:32,400
当你将鼠标悬停在上面时，

00:37:32,400 --> 00:37:40,000
可以看到每字节的费用。

00:37:40,000 --> 00:37:42,720
这是一个交易的平均字节大小吗？

00:37:42,720 --> 00:37:47,359
这是一个交易，

00:37:47,359 --> 00:37:50,560
然后你可以在上面设置一个费用，

00:37:50,560 --> 00:37:54,960
你基本上是按每个字节付费，

00:37:54,960 --> 00:37:57,520
所以数据越大的交易，

00:37:57,520 --> 00:38:01,119
你就需要设置更高的费用，

00:38:01,119 --> 00:38:05,839
因为矿工会根据每字节的费用选择交易，

00:38:05,839 --> 00:38:07,520
因此，

00:38:07,520 --> 00:38:09,440
交易占用他们在候选区块中的空间，

00:38:09,440 --> 00:38:15,119
他们会优先选择费用最高的交易。

00:38:15,119 --> 00:38:16,720
再次回顾一下挖矿，

00:38:16,720 --> 00:38:19,839
把你的coinbase交易放在最上面，

00:38:19,839 --> 00:38:21,359
然后你可以构造区块头，

00:38:21,359 --> 00:38:23,680
同样的，

00:38:23,680 --> 00:38:24,560
你有一个版本号。

00:38:24,560 --> 00:38:26,480
这是一个旧块，

00:38:26,480 --> 00:38:29,440
版本号是1

00:38:29,440 --> 00:38:34,160
版本号的工作方式现在和以前不同，

00:38:34,160 --> 00:38:36,960
它们可以用于投票，

00:38:36,960 --> 00:38:38,079
我现在不打算讲这个，

00:38:38,079 --> 00:38:40,640
我只是要简单地介绍一下区块头，

00:38:40,640 --> 00:38:42,400
然后你有前一个区块的，

00:38:42,400 --> 00:38:45,200
再次引用前一个区号在其上面建立的区块，

00:38:45,200 --> 00:38:47,119
基本上就是区块链的顶端，

00:38:47,119 --> 00:38:51,599
然后是merkle根。

00:38:51,599 --> 00:38:54,079
merkle根的工作方式是，

00:38:54,079 --> 00:38:55,920
你有所有的交易，

00:38:55,920 --> 00:38:57,119
在区块中，

00:38:57,119 --> 00:38:58,560
我只是把这些移动到一边，

00:38:58,560 --> 00:39:00,480
为了说明目的，

00:39:00,480 --> 00:39:02,320
然后你做的就是运行每一对交易，

00:39:02,320 --> 00:39:04,240
every single pair of transactions and

00:39:04,240 --> 00:39:05,839
然后把它们设一起哈希，

00:39:05,839 --> 00:39:08,720
记住这些哈希函数，

00:39:08,720 --> 00:39:12,240
然后就是把这些排列起来，

00:39:12,240 --> 00:39:15,760
这一和二就把它们排列在一起，

00:39:15,760 --> 00:39:17,920
然后一起哈希，

00:39:17,920 --> 00:39:21,200
它们会产生一个摘要或哈希结果，

00:39:21,200 --> 00:39:22,240
然后他们对区块中的每一对交易都这样做，

00:39:22,240 --> 00:39:26,720
你最后有一个交易是单独的，没有配对，

00:39:26,720 --> 00:39:29,440
你所做的就是把它和自己哈希在一起，

00:39:29,440 --> 00:39:31,680
然后就完成了第一轮，

00:39:31,680 --> 00:39:34,800
你从所有这些对中得到这4个哈希值，

00:39:34,800 --> 00:39:36,560
然后再运行一遍

00:39:36,560 --> 00:39:38,320
将所有的哈希值配对并一起哈希，

00:39:38,320 --> 00:39:40,400
然后再继续这样做，

00:39:40,400 --> 00:39:44,880
最终会得到一个单一的哈希结果，

00:39:44,880 --> 00:39:47,760
这称为默克尔根。

00:39:47,760 --> 00:39:51,119
现在的问题是，

00:39:51,119 --> 00:39:53,599
如果你想创建一个区块中所有交易的摘要

00:39:53,599 --> 00:39:56,480
你要怎么做？

00:39:56,480 --> 00:39:57,839
（顺便说一下，你将这里的交易ID进行哈希）

00:39:57,839 --> 00:40:00,160
但是，

00:40:00,160 --> 00:40:04,560
如果你想创建一个摘要或者指纹来表示区块中的所有交易，

00:40:04,560 --> 00:40:07,760
为什么不只是简单地将它们全部一起哈希，

00:40:07,760 --> 00:40:11,599
而是采用这种更复杂的树形结构呢？

00:40:11,599 --> 00:40:13,520
这样做的原因是，

00:40:13,520 --> 00:40:17,839
假设你得到了一个默克尔根，

00:40:17,839 --> 00:40:26,480
你想检查这个交易ID是否存在于这个区块中。

00:40:26,480 --> 00:40:32,400
唯一的检查方法就是取所有其他的交易ID，

00:40:32,400 --> 00:40:34,160
包括你想检查的那一个，

00:40:34,160 --> 00:40:38,720
然后将它们一起哈希，

00:40:38,720 --> 00:40:41,680
得到默克尔根。

00:40:41,680 --> 00:40:44,000
获取哈希，

00:40:44,000 --> 00:40:45,920
抱歉

00:40:45,920 --> 00:40:47,760
但是，

00:40:47,760 --> 00:40:50,000
如果你想检查这个哈希的存在，

00:40:50,000 --> 00:40:52,320
你实际上只需要这个，

00:40:52,320 --> 00:40:54,000
来创建这个，

00:40:54,000 --> 00:40:55,760
如果你有了这个，

00:40:55,760 --> 00:40:57,599
然后你需要这个，

00:40:57,599 --> 00:40:59,280
然后你就可以创建这个，

00:40:59,280 --> 00:41:01,440
只有这个在这里，

00:41:01,440 --> 00:41:03,920
你就可以得到默克尔根了

00:41:03,920 --> 00:41:06,480
我们做的另一个是1…2…3.4……5……7、6…

00:41:06,480 --> 00:41:10,240
它需要七个交易ID，

00:41:10,240 --> 00:41:12,720
但这个只需要三个。

00:41:12,720 --> 00:41:13,920
显然，

00:41:13,920 --> 00:41:14,960
这看起来并不是一个巨大的改进，

00:41:14,960 --> 00:41:16,319
但这只是一个简单的区块，

00:41:16,319 --> 00:41:23,520
如果这是一个包含数千笔交易的更长的区块，

00:41:23,520 --> 00:41:30,079
你需要更少的交易ID来检查单个交易的存在。

00:41:30,079 --> 00:41:32,079
我自己没有做过这个，

00:41:32,079 --> 00:41:34,160
但是显然这样做是有用的，

00:41:34,160 --> 00:41:35,599
也是高效的。

00:41:35,599 --> 00:41:38,640
所以我们有这个树形结构的哈希，

00:41:38,640 --> 00:41:43,839
因为它可以节省在我们的区块中检查交易存在的时间。

00:41:43,839 --> 00:41:48,880
当你说我们哈希两个交易时？

00:41:48,880 --> 00:41:51,520
是的,没错。

00:41:51,520 --> 00:41:57,760
你只需要将交易id连接起来并做一个sha256哈希。

00:41:57,920 --> 00:42:01,040
基本上是哈希交易数据来给你一个交易ID，

00:42:01,040 --> 00:42:02,960
是的，

00:42:02,960 --> 00:42:04,880
然后你再哈希这些ID。

00:42:04,880 --> 00:42:05,420
没错，对的。

00:42:08,319 --> 00:42:11,280
我们有一个叫做Merkel根的东西，

00:42:11,280 --> 00:42:15,359
，还有区块头中的时间，

00:42:15,359 --> 00:42:19,280
这是一个时间戳。

00:42:17,520 --> 00:42:19,280
但是，

00:42:19,280 --> 00:42:25,440
区块头中的时间是用Unix时间编码的，

00:42:25,440 --> 00:42:30,880
也就是从1970年1月1日开始的秒数。

00:42:30,880 --> 00:42:36,880
这个区块的时间戳的人类表示法是2011年5月12日，

00:42:36,880 --> 00:42:38,960
但在Unix时间中，

00:42:38,960 --> 00:42:42,319
那将是这么多秒。

00:42:42,319 --> 00:42:43,599
关于时间的一个简短说明，

00:42:43,599 --> 00:42:46,720
这些并不需要准确，

00:42:46,720 --> 00:42:51,280
只需要在一个特定的最小值和最大值之间。

00:42:51,280 --> 00:42:52,400
因此，

00:42:52,400 --> 00:42:55,520
你可以设置的最小值作为你的区块头的时间

00:42:55,520 --> 00:43:00,079
是最后11个区块的中位数时间，

00:43:00,079 --> 00:43:08,800
或者基本上是区块头中的第六个区块的时间，

00:43:08,800 --> 00:43:12,400
那么你不能有一个时间比这个更低，

00:43:12,400 --> 00:43:14,000
这是最小界限。

00:43:14,000 --> 00:43:19,119
然后最大值，

00:43:19,119 --> 00:43:22,720
基本上你的节点有它自己的时间，

00:43:22,720 --> 00:43:24,160
当你运行它时，

00:43:24,160 --> 00:43:26,000
它只是使用你的计算机的时间，

00:43:26,000 --> 00:43:28,000
然后当其他节点连接到你时，

00:43:28,000 --> 00:43:30,000
他们会发送他们的计算机上的时间给你，

00:43:30,000 --> 00:43:36,560
所以你的节点会跟踪你连接的所有节点的时间差，

00:43:36,560 --> 00:43:38,560
如果你将它们按顺序排列，

00:43:38,560 --> 00:43:42,319
然后取连接到的所有节点的中位数时间，

00:43:42,319 --> 00:43:47,280
这被称为网络平均时间。

00:43:47,280 --> 00:43:53,680
这个时间的最大值是网络平均时间加上两个小时。

00:43:53,680 --> 00:43:55,520
你能快速重温一下这部分吗?

00:43:55,520 --> 00:43:57,839
我是有点困惑，

00:43:57,839 --> 00:44:00,800
为什么要用这个时间，

00:44:00,800 --> 00:44:04,480
这个时间是挖一个区块还是什么？

00:44:04,480 --> 00:44:08,560
哦，不用，

00:44:08,560 --> 00:44:11,200
我认为我没有必要解释这个

00:44:11,200 --> 00:44:12,960
这个时间并不是用来挖矿的，

00:44:12,960 --> 00:44:14,960
而是你电脑当前的时间，

00:44:14,960 --> 00:44:18,000
插入到区块头中。

00:44:18,000 --> 00:44:20,560
但是这个时间并不需要精确，

00:44:20,560 --> 00:44:25,760
只需要在两个特定的值之间即可。

00:44:25,760 --> 00:44:28,720
只要它大于倒数第六个区块的时间，

00:44:28,720 --> 00:44:32,480
或者是最后11个区块的中位数时间，

00:44:32,480 --> 00:44:36,880
不能低于这个值，

00:44:36,880 --> 00:44:38,400
因为如果你放一个低于这个值的时间，

00:44:38,400 --> 00:44:42,160
那么你发送的节点会被拒绝。

00:44:42,160 --> 00:44:43,920
同时，

00:44:43,920 --> 00:44:47,119
最大的时间基本上是当前时间，

00:44:47,119 --> 00:44:49,280
再加上两个小时，

00:44:49,280 --> 00:44:53,920
但是使用的是网络平均时间，

00:44:53,920 --> 00:44:59,680
这就是你所连接的所有节点的平均时间。

00:44:59,680 --> 00:45:01,839
所以不用担心这个，

00:45:01,839 --> 00:45:03,599
但我要说的是，

00:45:03,599 --> 00:45:08,079
时间可以大约落后一小时或提前一两个小时。

00:45:08,079 --> 00:45:09,920
所以如果你看到一个区块通过，

00:45:09,920 --> 00:45:13,359
它的时间在另一个区块之前或之后，

00:45:13,359 --> 00:45:16,240
那并不重要，

00:45:16,240 --> 00:45:22,240
它有这种灵活的上下界限。

00:45:22,240 --> 00:45:25,359
对的，这就是时间。

00:45:25,359 --> 00:45:27,440
接下来是位数，记住Target，

00:45:27,440 --> 00:45:30,800
位数只是Target的紧凑表示。

00:45:30,800 --> 00:45:37,760
你不需要在区块头中放入整个Target，

00:45:37,760 --> 00:45:40,000
你要做什么？

00:45:40,000 --> 00:45:42,880
你需要抓取前三个重要的字节，

00:45:42,880 --> 00:45:47,599
或者在前导零后的第一个六个重要字符，

00:45:47,599 --> 00:45:50,560
然后把它放在那里，

00:45:50,560 --> 00:45:55,760
然后你需要抓取偏移量，

00:45:55,760 --> 00:45:58,560
也就是这三个字节距离右边有多远，

00:45:58,560 --> 00:46:00,880
这里从右边有26个字节，

00:46:00,880 --> 00:46:02,240
或者在十六进制中，

00:46:02,240 --> 00:46:06,160
26是"1a"。

00:46:06,160 --> 00:46:08,640
所以你只需要把那个开始放在那里，

00:46:08,640 --> 00:46:15,040
位数就是Target的紧凑表示。

00:46:15,040 --> 00:46:16,400
然后就是nonce，

00:46:16,400 --> 00:46:18,800
你可以把它设置为零。

00:46:18,800 --> 00:46:22,400
这就是所有的基本数据，

00:46:22,400 --> 00:46:25,839
现在我们已经准备好了区块头的所有字段。

00:46:25,839 --> 00:46:28,720
这些字段是否都有意义？

00:46:28,720 --> 00:46:30,160
很好，现在我们已经准备好了所有的字段，

00:46:30,160 --> 00:46:31,599
可以开始挖矿了。

00:46:31,599 --> 00:46:35,760
我们只需要把所有的数据都放入正确的格式中。

00:46:35,760 --> 00:46:37,839
这只是一些编程，

00:46:37,839 --> 00:46:41,520
确保所有的东西都在正确的顺序和格式中。

00:46:41,520 --> 00:46:44,400
每个字段都应该是十六进制的，

00:46:44,400 --> 00:46:46,640
把所有的东西都转换成十六进制。

00:46:47,680 --> 00:46:49,440
所以1是十六进制的，这不会改变

00:46:49,440 --> 00:46:52,560
但是你需要检查每一个字段，

00:46:52,560 --> 00:46:54,160
确保它都是十六进制的。

00:46:54,160 --> 00:46:56,640
时间现在是十进制的，

00:46:56,640 --> 00:46:58,079
所以我们把它转换成十六进制，

00:46:58,079 --> 00:47:00,079
对每个其他字段都这样做。

00:47:00,079 --> 00:47:02,800
这个过程对每个字段都是一样的。

00:47:02,800 --> 00:47:03,839
其次，

00:47:03,839 --> 00:47:09,599
每个字段必须是固定的字节数。

00:47:09,599 --> 00:47:11,040
比如，这里只有一个字符，

00:47:11,040 --> 00:47:13,760
但版本字段是四个字节，

00:47:13,760 --> 00:47:16,160
如果我们将其转换为四个字节，

00:47:16,160 --> 00:47:17,839
它看起来就像这样。

00:47:17,839 --> 00:47:20,720
一个字节是两个字符，

00:47:20,720 --> 00:47:23,119
所以"00"就是一个字节，

00:47:23,119 --> 00:47:26,640
版本中有四个字节。

00:47:26,640 --> 00:47:29,599
然后你只需要遍历每个字段，

00:47:29,599 --> 00:47:32,000
确保它们都填充到正确的大小。

00:47:32,000 --> 00:47:36,319
所以这已经是32字节了

00:47:36,319 --> 00:47:37,760
这个时间字段已经是四个字节，

00:47:37,760 --> 00:47:40,400
它已经是四位了，

00:47:40,400 --> 00:47:42,640
同样对于nonce字段也是四个字节。

00:47:42,640 --> 00:47:45,119
所以对于每个字段，

00:47:45,119 --> 00:47:49,760
确保你已经用正确的字节数填充了它。

00:47:49,760 --> 00:47:52,720
这意味着，

00:47:52,720 --> 00:47:56,480
计算机可以轻松地读取每个单独的字段。

00:47:56,960 --> 00:48:03,359
这就是所有的数据都在正确的格式和正确的字段大小。

00:48:03,359 --> 00:48:05,280
最后，

00:48:05,280 --> 00:48:10,160
比特币唯一稍微令人沮丧的事情是，

00:48:10,160 --> 00:48:15,440
当你发送数据到节点时，

00:48:15,440 --> 00:48:19,680
你必须以反向字节顺序发送数据，

00:48:19,680 --> 00:48:22,160
这被称为网络字节顺序。

00:48:22,160 --> 00:48:23,200
order

00:48:23,200 --> 00:48:29,200
我们已经将所有这些数据转换为人类可读的字节顺序，

00:48:29,200 --> 00:48:31,520
但是当你处理比特币数据时，

00:48:31,520 --> 00:48:33,520
它必须是反向字节顺序。

00:48:33,520 --> 00:48:35,680
所以你需要遍历每个字段，

00:48:35,680 --> 00:48:37,200
将其转换为网络字节顺序，

00:48:37,200 --> 00:48:39,440
反转每个字节。

00:48:39,440 --> 00:48:45,599
这是我刚开始挖矿时遇到的问题，

00:48:45,599 --> 00:48:47,280
我试图哈希这些块头，

00:48:47,280 --> 00:48:50,000
我不明白为什么我得不到相同的结果，

00:48:51,040 --> 00:48:56,240
原因就是你需要将所有数据转换为网络字节顺序。

00:48:56,240 --> 00:49:01,839
我做了一个小的演示来说明这一点。

00:49:01,839 --> 00:49:02,880
我已经写了一个简单的脚本来反转字节。

00:49:02,880 --> 00:49:13,200
如果我输入a b c d e f 1 2 3 4，

00:49:13,839 --> 00:49:19,839
那么反转字节的方式就是将其分割成每个单独的字节，

00:49:19,839 --> 00:49:23,200
那么，一个字节是两个字符，

00:49:23,200 --> 00:49:24,720
然后你只需要反转字节的顺序，

00:49:24,720 --> 00:49:26,480
就可以得到结果。

00:49:26,480 --> 00:49:28,480
这就是它的工作原理，

00:49:28,480 --> 00:49:31,680
你不仅仅是反转字符串，

00:49:31,680 --> 00:49:34,800
而是在反转每个字节。

00:49:34,800 --> 00:49:35,920
这可能是一个基本的问题，

00:49:35,920 --> 00:49:38,720
但一个字节是两个字符，对吗？

00:49:38,720 --> 00:49:40,400
是的，

00:49:40,400 --> 00:49:41,680
是的，

00:49:41,680 --> 00:49:42,800
2个字符就是1个字节

00:49:42,800 --> 00:49:45,200
是的，这就是我学到的东西。

00:49:45,200 --> 00:49:51,520
我是在看C++...

00:49:51,520 --> 00:49:54,480
我已经很久没有做过C++了，

00:49:54,480 --> 00:49:59,520
字符类型的大小是一个字节。

00:50:01,599 --> 00:50:06,640
我对计算机科学了解地不是很深入，

00:50:06,640 --> 00:50:10,880
我是从上到下的层次来学习的，

00:50:10,880 --> 00:50:17,440
我只是知道两个字符可以转换为一个字节。

00:50:17,440 --> 00:50:22,160
现在我们终于得到了所有正确顺序的数据，

00:50:22,160 --> 00:50:26,559
然后你只需要将每个单独的字段连接在一起，

00:50:26,559 --> 00:50:28,319
这就是区块头，

00:50:28,319 --> 00:50:32,240
现在它已经准备好放入哈希函数中了。

00:50:32,240 --> 00:50:35,440
正如我提到的，

00:50:35,440 --> 00:50:38,480
比特币使用的是SHA-256简单哈希算法，

00:50:38,480 --> 00:50:39,520
但在比特币中，

00:50:39,520 --> 00:50:44,319
所有的东西都被哈希两次。

00:50:44,319 --> 00:50:46,400
这就是它的设计方式，

00:50:46,400 --> 00:50:50,800
我不认为它提供了任何巨大的好处，

00:50:50,800 --> 00:50:53,520
这只是比特币哈希的方式。

00:50:53,520 --> 00:50:55,760
所以你只需要将这个放入哈希函数，

00:50:55,760 --> 00:50:58,480
它会输出结果，

00:50:58,480 --> 00:50:59,920
然后你再哈希这个结果得到另一个结果，

00:50:59,920 --> 00:51:05,520
这就是最终的哈希。

00:51:05,520 --> 00:51:07,680
当你在比特币中哈希东西时，

00:51:07,680 --> 00:51:10,000
是以十六进制表示的，

00:51:10,000 --> 00:51:12,000
你首先将其转换为二进制，

00:51:12,000 --> 00:51:14,800
然后你将二进制数据放入哈希函数，

00:51:14,800 --> 00:51:15,920
它会输出一个二进制结果，

00:51:15,920 --> 00:51:20,079
你再将这个二进制结果放入第二个哈希函数，

00:51:20,079 --> 00:51:24,880
它会输出第二个二进制摘要，

00:51:24,880 --> 00:51:29,359
当你将这个第二个摘要转换回十六进制时，

00:51:29,359 --> 00:51:33,040
将会给你区块哈希，

00:51:33,040 --> 00:51:41,680
但显然这是以网络字节顺序反向的，

00:51:41,680 --> 00:51:42,880
如果我们将其反转，

00:51:42,880 --> 00:51:45,760
那么它就是更符合人类阅览格式。

00:51:45,760 --> 00:51:50,559
如果你将这个与目标进行比较，

00:51:50,559 --> 00:51:53,520
你需要确保它是反向的，

00:51:55,359 --> 00:51:58,880
返回到非网络字节顺序。

00:51:58,880 --> 00:52:01,359
那么我们就到这里，

00:52:01,359 --> 00:52:03,119
我只讲解了这些东西，

00:52:03,119 --> 00:52:05,599
我再多讲可能会让你困扰。

00:52:05,599 --> 00:52:07,200
获取字段很简单，

00:52:07,200 --> 00:52:08,960
将它们放入正确的顺序，

00:52:08,960 --> 00:52:11,839
将它们转换为二进制，然后再将它们切换回来。

00:52:11,839 --> 00:52:14,240
在你试图自己挖掘区块头或哈希区块头时，

00:52:14,240 --> 00:52:15,920
这就是会让你困扰的地方。

00:52:15,920 --> 00:52:20,640
对，这就是区块头，

00:52:20,640 --> 00:52:26,319
已经将字段反向为网络字节顺序。

00:52:23,760 --> 00:52:26,319
然后对其进行双重哈希？

00:52:26,319 --> 00:52:31,359
是的是的，

00:52:31,359 --> 00:52:36,720
将其转换为十六进制，

00:52:36,720 --> 00:52:40,160
再把它转换成反向字节顺序。

00:52:40,160 --> 00:52:43,599
我把它反转了，

00:52:44,000 --> 00:52:44,839
ok，好了

00:52:44,839 --> 00:52:50,559
是的，就是这个的方式。

00:52:50,559 --> 00:52:56,720
假设你成功挖掘了一个区块，

00:52:56,720 --> 00:53:02,880
并且你得到的难度值低于目标值。

00:53:02,880 --> 00:53:04,720
那么你接下来会做什么？

00:53:04,720 --> 00:53:06,800
好的，

00:53:06,800 --> 00:53:08,480
我想我应该现在就讲解。

00:53:08,480 --> 00:53:09,920
你其实并不需要发送区块哈希，

00:53:09,920 --> 00:53:13,599
你只需要发送区块头和交易信息。

00:53:13,599 --> 00:53:15,440
但是，如果你在编程时，

00:53:15,440 --> 00:53:16,720
你可以不反转它，

00:53:16,720 --> 00:53:24,720
这只是为了能以一种人类可以理解的方式正确地显示结果。

00:53:24,720 --> 00:53:27,359
而矿工只需要改变随机数。

00:53:27,359 --> 00:53:29,520
现在，

00:53:29,520 --> 00:53:30,240
我是从零开始递增，

00:53:30,240 --> 00:53:32,720
一、二、三、四、五等等。

00:53:32,720 --> 00:53:35,359
显然，

00:53:35,359 --> 00:53:36,880
这是网络字节顺序。

00:53:36,880 --> 00:53:40,319
最终，

00:53:40,319 --> 00:53:44,160
如果你幸运的话，

00:53:44,160 --> 00:53:47,839
你会得到一个低于目标的哈希值。

00:53:47,839 --> 00:53:49,280
这就完成了，

00:53:49,280 --> 00:53:51,280
这是一次成功的挖矿。

00:53:51,280 --> 00:53:52,000
如果你把这个区块头发送给其他人，

00:53:52,000 --> 00:53:54,319
他们可以自己进行哈希运算，

00:53:54,319 --> 00:53:55,760
会得到相同的结果。

00:53:55,760 --> 00:53:57,200
我认为这就是他们所说的工作证明，

00:53:57,200 --> 00:54:00,400
因为你可以把这个区块头发送给任何人，

00:54:00,400 --> 00:54:03,440
他们可以自己证明哈希值低于目标。

00:54:03,440 --> 00:54:10,480
你要做的就是把这个区块发送给你连接的所有节点，

00:54:10,480 --> 00:54:17,440
实际上发送给他们的是所有交易数据的连接，

00:54:17,440 --> 00:54:18,880
对于每个交易来说，

00:54:18,880 --> 00:54:20,559
前面放一个小的交易计数器，

00:54:20,559 --> 00:54:22,559
这只是一个字节，

00:54:22,559 --> 00:54:25,200
它是一个非常可变的字节，

00:54:25,200 --> 00:54:26,960
我还没有讲到，

00:54:26,960 --> 00:54:28,720
但是在网站上有。

00:54:28,720 --> 00:54:30,079
它会告诉你区块中有多少交易，

00:54:30,079 --> 00:54:31,839
在这之前你有区块头，

00:54:31,839 --> 00:54:35,359
这是发送给所有节点的内容。

00:54:35,359 --> 00:54:38,480
不需要发送区块哈希给所有节点

00:54:38,480 --> 00:54:44,800
因为它们可以自己计算出来。

00:54:44,800 --> 00:54:47,599
这就是挖矿的工作原理，

00:54:47,599 --> 00:54:56,800
我现在想尝试展示如何挖掘一个实际的活动区块。

00:54:56,800 --> 00:54:58,160
所以,是的…

00:54:58,160 --> 00:55:01,359
如果你运行一个比特币节点，

00:55:01,359 --> 00:55:08,640
你可以使用比特币cli命令来询问比特币节点问题，

00:55:08,640 --> 00:55:14,559
其中一个问题就是获取区块模板。

00:55:14,559 --> 00:55:22,720
这将会从你当前的内存池中获取最高价值的交易来填充一个区块，

00:55:22,720 --> 00:55:24,960
并把它们提供给你。

00:55:25,119 --> 00:55:30,400
这就是显示我所有的交易，

00:55:30,400 --> 00:55:32,319
这些交易将构成一个候选区块。

00:55:32,319 --> 00:55:38,880
让我把它往下移一些...

00:55:38,880 --> 00:55:40,720
那么，

00:55:40,720 --> 00:55:45,359
我们快速检查这里的信息，

00:55:45,359 --> 00:55:52,640
如果你使用比特币cli帮助获取区块模板，

00:55:52,640 --> 00:55:57,920
那将会显示所有的字段，

00:55:59,520 --> 00:56:02,319
但如果我只是快速地看一下这些交易，

00:56:02,319 --> 00:56:06,240
并从中创建一个区块头。

00:56:06,240 --> 00:56:09,680
所以bitcoin-cli getblocktemplate

00:56:09,680 --> 00:56:15,680
我将使用grep来搜索我们需要的字段，

00:56:15,680 --> 00:56:19,200
我使用的是rg，

00:56:19,200 --> 00:56:21,760
是grep的一个变体。

00:56:21,760 --> 00:56:24,160
我们还需要找到一个版本号，

00:56:24,160 --> 00:56:27,599
需要前一个区块，

00:56:27,920 --> 00:56:30,480
然后我们需要默克尔根，

00:56:30,480 --> 00:56:33,440
需要时间，

00:56:33,440 --> 00:56:34,799
然后是bits，

00:56:34,799 --> 00:56:36,400
再然后是nonce，

00:56:36,400 --> 00:56:37,920
但我们将提供我们自己的nonce，

00:56:37,920 --> 00:56:39,440
所以我们不需要那个。

00:56:39,440 --> 00:56:41,359
让我看看，

00:56:41,359 --> 00:56:45,000
我这里出了点错。

00:56:45,200 --> 00:56:49,280
让我们看' getblocktemplate '的结果

00:56:49,280 --> 00:56:51,200
它给了我们版本，

00:56:51,200 --> 00:56:52,960
前一个区块的哈希，

00:56:52,960 --> 00:56:56,160
也给了我们当前时间和bits。

00:56:56,160 --> 00:56:58,480
所以它正在改变当前的时间，

00:56:58,480 --> 00:57:01,440
但它没有给我们一个merkle根，

00:57:01,440 --> 00:57:05,520
我不知道为什么没有，

00:57:05,520 --> 00:57:12,160
但你可以做的是，

00:57:12,160 --> 00:57:15,440
它给你的是一个json解析器，

00:57:15,440 --> 00:57:20,799
给了你一个交易列表，

00:57:20,799 --> 00:57:22,400
和给你所有的交易id，

00:57:22,400 --> 00:57:25,040
所以如果我们只是遍历每一个，

00:57:25,040 --> 00:57:29,599
然后说给我们交易id，

00:57:29,599 --> 00:57:33,920
现在我们需要把它放在引号里，

00:57:36,240 --> 00:57:39,680
这就是所有的交易id，

00:57:39,680 --> 00:57:43,200
现在我们得到了这个候选块中所有的交易id

00:57:43,200 --> 00:57:46,480
我们需要它们来创建我们自己的merkle根，

00:57:46,480 --> 00:57:47,200
幸运的是，

00:57:47,200 --> 00:57:49,839
我已经写了我自己的脚本，

00:57:49,839 --> 00:57:55,359
它会接收一个交易列表并从中创建一个merkle根，

00:57:55,359 --> 00:57:56,960
我已经把这个放到了网站上

00:57:56,960 --> 00:57:58,960
我会在一会儿展示它，

00:57:58,960 --> 00:58:00,720
所以我这么做，

00:58:00,720 --> 00:58:02,880
我们就有一个merkle根，

00:58:02,880 --> 00:58:07,280
现在我们得到了我们需要的所有数据来挖掘一个块，

00:58:07,280 --> 00:58:10,640
或者我们来构造一个块头，

00:58:10,640 --> 00:58:12,480
如果你能听我讲五分钟，

00:58:12,480 --> 00:58:16,079
我会逐个解释每个内容，

00:58:16,079 --> 00:58:25,200
首先我们需要得到版本，

00:58:25,200 --> 00:58:27,440
这是用getblocktemplate得到的当前版本，

00:58:27,440 --> 00:58:29,119
就像我之前说的，

00:58:29,119 --> 00:58:32,079
它们已经改变了一些，

00:58:32,079 --> 00:58:33,040
它们被改成用来投票，

00:58:33,040 --> 00:58:36,960
所以为什么它是一个非常高的数字，

00:58:36,960 --> 00:58:38,160
但我现在不打算解释它，

00:58:38,160 --> 00:58:40,480
只是把它当作是个版本号，

00:58:40,480 --> 00:58:41,920
但显然它是十进制的，

00:58:41,920 --> 00:58:46,240
所以首先要把它转换成十六进制，

00:58:46,240 --> 00:58:54,559
我们首先需要将版本转换为十六进制，

00:58:54,559 --> 00:58:59,920
然后调整字节顺序或调整字节顺序，

00:58:59,920 --> 00:59:06,720
有时也被称为"endianness""

00:59:06,720 --> 00:59:12,480
然后，我们可以将版本设置好并准备好使用。

00:59:12,480 --> 00:59:15,119
我只需要删掉那个末尾，

00:59:15,119 --> 00:59:16,640
因为我要把它全部连接起来。

00:59:16,640 --> 00:59:20,160
所以我把这个保存为一个变量，

00:59:20,160 --> 00:59:22,640
ok

00:59:25,680 --> 00:59:26,880
我们回显一下进行检查，

00:59:26,880 --> 00:59:29,359
这是Version done。

00:59:29,359 --> 00:59:40,799
接下来，我们处理前一个块的版本。

00:59:40,799 --> 00:59:44,559
这是前一个区块的哈希值，

00:59:44,559 --> 00:59:51,040
让我去掉引号，

00:59:51,040 --> 00:59:52,640
已经是十六进制的，

00:59:52,640 --> 00:59:55,440
已经是32字节，

00:59:55,440 --> 00:59:57,680
那么我需要做的是将字节顺序排序，

00:59:57,680 --> 00:59:59,040
或者将其转换为小端字节序。

00:59:59,040 --> 01:00:07,200
之后我就可以将其保存为前一个区块的变量。

01:00:11,119 --> 01:00:16,000
接下来是默克尔根，

01:00:16,000 --> 01:00:23,839
显然我们从get block template命令中并没有得到默克尔根

01:00:23,839 --> 01:00:25,440
但是它给了我们交易列表，

01:00:25,440 --> 01:00:28,559
对于每一笔交易，

01:00:28,559 --> 01:00:31,440
它都会给我们一个交易ID，

01:00:31,440 --> 01:00:35,280
从这些交易ID中，

01:00:35,280 --> 01:00:41,760
我可以得到默克尔根。

01:00:41,760 --> 01:00:46,079
好的，它已经是十六进制的，

01:00:46,079 --> 01:00:49,599
是32字节，

01:00:49,599 --> 01:00:54,240
我只需要将字节顺序排序。

01:00:54,240 --> 01:00:56,799
快好了，我知道这有点费力，

01:00:58,640 --> 01:01:00,559
我知道这有点费力，

01:01:00,559 --> 01:01:03,680
但是这就是版本、

01:01:03,680 --> 01:01:05,920
前一个块的默克尔根、

01:01:05,920 --> 01:01:07,040
还有时间。

01:01:07,040 --> 01:01:08,839
um for some reason

01:01:08,839 --> 01:01:10,480
um

01:01:10,480 --> 01:01:12,640
出于某种原因，

01:01:12,640 --> 01:01:15,119
即使是' getblocktemplate '没有给你默克尔根，

01:01:15,119 --> 01:01:19,280
它会显示你电脑上的当前时间

01:01:19,280 --> 01:01:21,200
哦，实际上不是，

01:01:21,200 --> 01:01:24,880
它给你的是一个有效的时间，

01:01:24,880 --> 01:01:25,839
我不确定这是不是，

01:01:25,839 --> 01:01:27,760
我不知道，

01:01:27,760 --> 01:01:29,440
但这绝对是一个有效的时间，

01:01:29,440 --> 01:01:30,480
如果你不想使用那个，

01:01:30,480 --> 01:01:32,079
如果你不想用getblocktemplate时间，

01:01:32,079 --> 01:01:36,240
你可以用编程语言中的' date '函数，

01:01:36,240 --> 01:01:39,680
那么会给你Unix时间的秒数，

01:01:39,680 --> 01:01:42,799
只需要把它转换成十六进制，

01:01:42,799 --> 01:01:44,000
像这样，

01:01:44,000 --> 01:01:46,720
一二三四五六七，

01:01:46,720 --> 01:01:48,799
24个字节，

01:01:48,799 --> 01:01:56,319
然后我们把它转换成反字节顺序，

01:01:56,319 --> 01:01:58,160
这就是时间，

01:01:58,160 --> 01:01:59,040
那么准备好了，

01:01:59,040 --> 01:02:07,440
这是最后完成的时间“比特”

01:02:07,440 --> 01:02:11,359
这是目标的紧凑版本，

01:02:11,359 --> 01:02:18,079
就是这样，把引号去掉

01:02:18,079 --> 01:02:21,839
然后把它转换成反字节顺序，

01:02:22,400 --> 01:02:31,599
现在我们已经准备好了所有基本的block header数据

01:02:32,160 --> 01:02:36,160
接下来，以正确的格式，

01:02:36,160 --> 01:02:40,960
我们需要从每个单独的字段构建区块头，

01:02:40,960 --> 01:02:43,359
这些字段包括版本、

01:02:43,359 --> 01:02:46,799
前一个区块、

01:02:46,839 --> 01:02:50,400
默克尔根、

01:02:50,400 --> 01:02:55,280
时间和bits。

01:02:55,280 --> 01:02:58,640
然后我们将这些字段组合起来，

01:02:58,960 --> 01:03:00,640
得到我们的区块头。

01:03:00,640 --> 01:03:04,160
现在我们唯一缺少的就是随机数（nonce）。

01:03:04,160 --> 01:03:06,960
如果我们想要挖矿，

01:03:06,960 --> 01:03:08,960
我们需要创建一个循环，

01:03:08,960 --> 01:03:13,280
不断地对这个区块头进行哈希，

01:03:13,280 --> 01:03:17,599
并在每次尝试时增加Nonce。

01:03:17,599 --> 01:03:22,640
我们可以从零开始，

01:03:22,640 --> 01:03:28,839
但显然我们需要将它转换成正确的格式。

01:03:28,839 --> 01:03:30,960
十六进制。

01:03:30,960 --> 01:03:32,240
对的，谢谢。

01:03:32,240 --> 01:03:36,319
但是很明显，

01:03:37,119 --> 01:03:38,880
它的长度需要是4字节

01:03:38,880 --> 01:03:43,359
所以我创建了一个函数来确保它的大小，

01:03:43,359 --> 01:03:45,280
并进行端转换。

01:03:45,280 --> 01:03:46,720
显然这不是很有趣，

01:03:46,720 --> 01:03:48,559
因为我用的是数字0，

01:03:48,559 --> 01:03:50,960
但如果我要用一个大得多的Nonce值

01:03:50,960 --> 01:03:52,559
就像这样，它

01:03:52,559 --> 01:03:55,039
它已经为我准备好了，

01:03:55,039 --> 01:03:56,319
但我现在还不打算将其附加到上面。

01:03:56,319 --> 01:04:00,640
我要做的是创建一个循环，

01:04:00,640 --> 01:04:08,400
所以当为真时，

01:04:08,400 --> 01:04:15,599
我要设置一个增量变量。

01:04:15,599 --> 01:04:16,960
然后，

01:04:16,960 --> 01:04:19,760
我要创建一个nonce，

01:04:19,760 --> 01:04:25,039
就像我刚才给你们展示的那样，

01:04:25,039 --> 01:04:31,039
我要将其转化为十六进制，

01:04:31,039 --> 01:04:34,559
然后交换字节顺序，

01:04:34,559 --> 01:04:37,760
最后剪掉末尾。

01:04:37,760 --> 01:04:39,440
这就是nonce的创建过程。

01:04:39,440 --> 01:04:42,319
然后，

01:04:42,319 --> 01:04:44,319
我们尝试挖掘区块，

01:04:44,319 --> 01:04:51,039
就是我们创建的区块头加上nonce的尾部，

01:04:51,039 --> 01:04:53,440
然后我们要对整个尝试进行哈希。

01:04:53,440 --> 01:05:00,319
我创建了一个叫做hash 256的函数来帮助，

01:05:00,319 --> 01:05:04,480
这个函数会将二进制数据进行双重哈希，

01:05:04,480 --> 01:05:08,960
我要对其尝试进行hash 256处理。

01:05:08,960 --> 01:05:12,400
在每次尝试之后

01:05:12,400 --> 01:05:15,920
我们都要增加nonce，

01:05:15,920 --> 01:05:23,760
所以我要增加这个数字。

01:05:23,760 --> 01:05:25,599
现在，

01:05:25,599 --> 01:05:36,000
这个程序正在非常缓慢地对当前的区块头进行哈希处理，

01:05:36,000 --> 01:05:37,680
这花了我很长时间，

01:05:37,680 --> 01:05:42,319
这实际上就是我试图挖掘一个区块的正常流程。

01:05:42,319 --> 01:05:44,000
如果你有运气，

01:05:44,960 --> 01:05:52,799
你可以在代码中加入一些能在达到目标时停止的代码。

01:05:52,799 --> 01:05:59,280
然后你会使用Bitcoin CLI中的一个函数叫做提交区块。

01:05:59,520 --> 01:06:01,760
你需要提交区块头、

01:06:01,760 --> 01:06:08,960
交易数量和所有的交易数据。

01:06:08,960 --> 01:06:10,799
如果你构建了一个成功的区块头，

01:06:10,799 --> 01:06:13,760
你会将其发送给你连接的所有节点，

01:06:13,760 --> 01:06:19,599
并使用提交区块的Bitcoin CLI命令来完成这个操作。

01:06:19,599 --> 01:06:24,559
你可以通过Bitcoin CLI获取目标值？

01:06:24,559 --> 01:06:36,480
是的，我认为它包含在Bitcoin CLI的getblocktemplate中。

01:06:36,480 --> 01:06:39,599
这就是当前的目标，

01:06:39,599 --> 01:06:42,160
你可以抓取这个目标，

01:06:42,160 --> 01:06:44,079
然后将其放入for循环中。

01:06:44,079 --> 01:06:46,480
但显然，

01:06:46,480 --> 01:06:48,400
这里的哈希运算非常非常慢。

01:06:48,400 --> 01:06:49,200
哦，是的，

01:06:49,200 --> 01:06:51,599
我完全明白，

01:06:51,599 --> 01:06:58,960
你可能会想在一种编程语言中完成这个任务。

01:06:58,960 --> 01:07:01,520
这只是在bash中快速演示说明的目的，

01:07:01,520 --> 01:07:03,599
这就足以显示挖矿实际上有多简单。

01:07:03,599 --> 01:07:05,520
最难的部分就是将数据按正确的顺序排列，

01:07:05,520 --> 01:07:07,440
但在那之后，

01:07:07,440 --> 01:07:09,680
你只需要增加一个无意义的哈希，

01:07:09,680 --> 01:07:15,760
然后希望你能得到一个幸运的结果。

01:07:15,760 --> 01:07:18,480
我想是的，

01:07:18,480 --> 01:07:23,839
这就是我想解释的关于挖矿工作原理的所有技术性内容。

01:07:23,839 --> 01:07:30,559
这可能比想象的要简单得多。

01:07:30,559 --> 01:07:32,400
在我制作的网站上，

01:07:32,400 --> 01:07:35,119
我已经提供了所有这些代码，

01:07:35,119 --> 01:07:37,760
每一个十六进制转换器和十进制转换器

01:07:37,760 --> 01:07:40,960
以及交换字节顺序，都在这里。

01:07:40,960 --> 01:07:44,240
这里有一个用php写的merkle root函数

01:07:44,240 --> 01:07:46,960
它不是最完美的，

01:07:46,960 --> 01:07:52,400
但它会接受一份交易ID列表并为你创建一个merkle root。

01:07:52,400 --> 01:07:54,400
你可能不想在生产中使用它，

01:07:54,400 --> 01:07:55,599
你可能想使用一个不同的库，

01:07:55,599 --> 01:08:05,760
我相信有很多比特币库有自己的merkle root函数供你使用。

01:08:05,760 --> 01:08:09,920
关于挖矿过程还有什么问题吗？

01:08:09,920 --> 01:08:11,520
没有，

01:08:11,520 --> 01:08:13,200
这真的很棒，

01:08:13,200 --> 01:08:15,359
非常感谢。

01:08:16,000 --> 01:08:21,198
你有没有使用过那些大型矿机的经验？

01:08:21,198 --> 01:08:23,198
没有，我实际上并没有自己挖矿，

01:08:23,198 --> 01:08:25,359
因为像我们说的，

01:08:25,359 --> 01:08:27,120
用你的笔记本电脑挖矿效率太低了。

01:08:27,120 --> 01:08:28,960
如果你现在想挖矿，

01:08:28,960 --> 01:08:30,399
这可不是一种业余的事情，

01:08:30,399 --> 01:08:33,120
你必须购买专业的挖矿设备，

01:08:33,120 --> 01:08:34,640
并像经营正规业务一样运行它。

01:08:34,640 --> 01:08:37,040
这是一种遗憾，

01:08:37,040 --> 01:08:41,920
因为这使得普通人无法参与挖矿。

01:08:41,920 --> 01:08:44,880
所以我认为如果你想参与挖矿，

01:08:44,880 --> 01:08:46,319
你必须真正的投入进去，

01:08:46,319 --> 01:08:48,238
这不仅仅是一种权益。

01:08:48,238 --> 01:08:50,080
即使那些专业的矿工，也只是在做同样的事情，

01:08:50,080 --> 01:08:51,759
他们也只是在做同样的事情？

01:08:51,759 --> 01:08:54,799
是的，他们会快一点。

01:08:54,799 --> 01:08:56,158
他们只是做着完全相同的事情，

01:08:56,158 --> 01:08:57,600
构建区块头，

01:08:57,600 --> 01:08:58,960
然后尽可能快的哈希。

01:08:58,960 --> 01:09:02,880
这整个构建区块头的过程非常简单，

01:09:02,880 --> 01:09:05,359
只需要一小部分的时间，

01:09:05,359 --> 01:09:15,359
挖矿的主要的核心部分就是尽可能快的哈希。

01:09:15,359 --> 01:09:18,238
我认为我没有遗漏任何东西，

01:09:18,238 --> 01:09:19,839
我想我已经涵盖了我所想要讲的所有内容。

01:09:19,839 --> 01:09:21,759
对不起，我知道这部分可能有点重复。

01:09:21,759 --> 01:09:24,960
不，不，不，

01:09:24,960 --> 01:09:26,960
这是一个很好的解释，

01:09:26,960 --> 01:09:28,000
非常感谢，

01:09:28,000 --> 01:09:29,600
但我认为，

01:09:29,600 --> 01:09:31,679
如果你刚开始接触比特币，

01:09:31,679 --> 01:09:36,479
学习的最好方式之一是尝试挖掘你自己的区块头。

01:09:36,479 --> 01:09:38,158
我认为这很简单，

01:09:38,158 --> 01:09:40,000
而且挖矿是比特币工作原理的基本部分之一，

01:09:40,000 --> 01:09:46,158
如果你能弄清楚如何挖掘或哈希一个区块头，

01:09:46,158 --> 01:09:47,839
那将是一个很好的起点。

01:09:47,839 --> 01:09:50,158
我会给你提供工具，让你了解所有的比特币相关知识。

01:09:50,158 --> 01:09:52,960
十六进制，网络字节顺序，以及如何哈希

01:09:52,960 --> 01:09:58,000
然后你可以使用这些工具去理解比特币的其他部分，

01:09:58,000 --> 01:10:01,040
比如交易等等。

01:10:01,040 --> 01:10:06,000
所以这会是我开始使用比特币编程的第一个地方。

01:10:06,000 --> 01:10:10,560
你可能不会去设置你自己的矿机，

01:10:10,560 --> 01:10:11,679
但作为一种学习经验，

01:10:11,679 --> 01:10:14,320
这是一个很好的开始。

01:10:15,280 --> 01:10:17,199
所以，如果你想浏览区块头，

01:10:17,199 --> 01:10:18,880
只需访问learnmeabitcoin.com

01:10:18,880 --> 01:10:20,560
这就是区块链。

01:10:20,560 --> 01:10:21,920
你可以浏览每个单独的区块，

01:10:21,920 --> 01:10:23,600
查看所有不同的区块头，

01:10:23,600 --> 01:10:25,520
并自己进行测试。

01:10:25,520 --> 01:10:28,960
然后你可以得到相同的区块缓存结果。

01:10:28,960 --> 01:10:31,280
非常好。

01:10:31,280 --> 01:10:32,400
谢谢

01:10:32,400 --> 01:10:35,280
非常感谢你的演示，

01:10:35,280 --> 01:10:37,120
这很有帮助。

01:10:37,120 --> 01:10:38,320
谢谢

01:10:38,320 --> 01:10:42,520
不用谢。