00:00:00,640 --> 00:00:01,520
那么，

00:00:01,520 --> 00:00:02,720
在这个演示中，

00:00:02,720 -->  00:00:06,720
我将介绍比特币挖矿是如何工作的。

00:00:06,720 --> 00:00:08,480
我将从什么是挖矿开始，

00:00:08,480 --> 00:00:11,200
然后解释它是什么以及为什么存在。

00:00:11,200 --> 00:00:12,240
然后，

00:00:12,240 --> 00:00:14,559
我将介绍它是如何工作的。

00:00:14,559 --> 00:00:16,640
但在我解释它是如何工作的之前，

00:00:16,640 --> 00:00:19,119
我需要解释什么是哈希函数，

00:00:19,119 --> 00:00:23,279
因为这是比特币工作的一个重要部分。

00:00:23,279 --> 00:00:25,119
我会先介绍它的基本工作原理，

00:00:25,119 --> 00:00:28,480
然后我将再次介绍它，

00:00:27,199 --> 00:00:30,240
我将以更专业的方式来解释。

00:00:30,240 --> 00:00:31,599
所以，

00:00:31,599 --> 00:00:33,360
如果你是一个程序员，

00:00:33,360 --> 00:00:35,120
你会发现这更有趣。

00:00:35,120 --> 00:00:37,280
我将开始做一些例子，

00:00:37,280 --> 00:00:43,200
并尝试向你展示如何在非常少的代码中实际挖掘一个实时块。

00:00:43,200 --> 00:00:47,440
那么，什么是挖矿?

00:00:47,440 --> 00:00:53,120
假设这是比特币网络，

00:00:51,680 --> 00:00:53,120
这些都是连接在一起运行比特币程序的计算机，

00:00:53,120 --> 00:00:59,039
这些都是连接在一起运行比特币程序的计算机，

00:00:59,039 --> 00:01:01,840
共享同一个文件，

00:01:01,840 --> 00:01:04,000
即区块链。

00:01:04,000 --> 00:01:06,400
比特币的工作方式是，

00:01:06,400 --> 00:01:09,040
如果你想向某人发送比特币，

00:01:09,040 --> 00:01:13,040
或者将比特币的所有权转让给别人，

00:01:13,040 --> 00:01:14,320
你需要创建一个交易，

00:01:14,320 --> 00:01:17,280
这只是一行数据，

00:01:17,280 --> 00:01:23,840
然后你将其插入到网络上的一个节点中。

00:01:23,840 --> 00:01:25,759
然后，

00:01:25,759 --> 00:01:27,840
如果我们没有挖矿，

00:01:27,840 --> 00:01:31,840
这个计算机将直接将其写入区块链，

00:01:31,840 --> 00:01:34,960
然后它们会将这个交易传递给它们连接的节点，

00:01:34,960 --> 00:01:38,960
将其写入自己的文件，

00:01:38,960 --> 00:01:40,640
如此反复，

00:01:40,640 --> 00:01:48,320
直到这个交易在整个网络中传播，

00:01:48,320 --> 00:01:50,159
并写入他们的共享文件。

00:01:50,159 --> 00:01:56,079
是拥有共享文件或共享交易的一种简单方法

00:01:56,079 --> 00:01:57,439
你知道的，

00:01:57,439 --> 00:02:01,200
当每个人都更新了他们的文件副本，

00:02:01,200 --> 00:02:06,719
比特币的所有权就从一个人转移到了另一个人，

00:02:06,719 --> 00:02:09,038
这是一个简单的交易。

00:02:09,038 --> 00:02:11,120
但是，如果你这样做，

00:02:11,120 --> 00:02:14,000
会有一个问题需要解决。

00:02:14,000 --> 00:02:17,440
让我们把这个人涂成绿色……

00:02:17,440 --> 00:02:20,959
你要做的就是创建一个交易，

00:02:20,959 --> 00:02:22,560
将比特币发送给这个人

00:02:22,560 --> 00:02:25,440
并将其插入网络的这一侧的一个节点。

00:02:25,440 --> 00:02:29,599
但是，由于这是一个连接的计算机网络，

00:02:29,599 --> 00:02:32,720
你要创建第二个交易，

00:02:32,720 --> 00:02:38,160
将同样的比特币发送给另一个人。

00:02:38,160 --> 00:02:39,200
所以，

00:02:39,200 --> 00:02:46,080
你刚刚在网络中插入了两个试图花费同一比特币的交易，

00:02:46,080 --> 00:02:47,360
你可以这样做，

00:02:47,360 --> 00:02:49,200
因为这是一个网络。

00:02:49,200 --> 00:02:50,959
接下来会发生的是，

00:02:53,280 --> 00:02:55,200
这两个交易将开始在网络中传播。

00:02:55,200 --> 00:02:57,280
你可以看到，

00:02:57,280 --> 00:03:01,599
这边的计算机已经收到了这个红色的交易和第二个交易，

00:03:01,599 --> 00:03:04,640
但是这边的计算机已经收到了绿色的交易。

00:03:04,640 --> 00:03:08,239
当这台计算机试图将绿色的交易传递给这台计算机时，

00:03:08,239 --> 00:03:15,440
这台计算机已经收到了花费这个比特币的红色交易，

00:03:15,440 --> 00:03:17,840
所以它们会拒绝它，

00:03:17,840 --> 00:03:19,360
这是对的。

00:03:19,360 --> 00:03:20,239
但是，

00:03:20,239 --> 00:03:22,800
你仍然有一个问题，

00:03:22,800 --> 00:03:24,800
那就是网络中存在这两个冲突的交易，

00:03:24,800 --> 00:03:28,720
或者你从整个网络或者这个文件的角度来看，

00:03:28,720 --> 00:03:31,360
这个比特币现在属于谁。

00:03:31,360 --> 00:03:34,640
所以，如果你以这种方式运行比特币，

00:03:34,640 --> 00:03:38,720
并直接将交易写入文件，

00:03:38,720 --> 00:03:42,400
你可能会创建这个双重支付问题。

00:03:42,400 --> 00:03:45,360
但是，比特币基本上解决了这个问题，

00:03:45,360 --> 00:03:51,599
将不将冲突的交易写入区块链或这个共享文件，

00:03:51,599 --> 00:03:53,280
这就是挖矿的含义。

00:03:53,280 --> 00:03:56,319
比特币解决这个双重支付问题的方式，

00:03:56,319 --> 00:03:58,239
这就是比特币有趣的地方，

00:03:58,239 --> 00:04:02,000
因为我们以前有过这种技术，

00:04:02,000 --> 00:04:21,199
*麦克风有问题，稍等*

00:04:21,199 --> 00:04:30,880
比特币解决了将两个冲突的交易写入共享文件的问题。

00:04:30,880 --> 00:04:33,199
这就是比特币的有趣之处，

00:04:33,199 --> 00:04:37,199
也是我认为比特币的“发明”成功之处

00:04:37,199 --> 00:04:42,800
比特币解决这个问题的方式是，

00:04:42,800 --> 00:04:47,280
它给运行比特币程序的每台计算机一些临时内存，

00:04:47,280 --> 00:04:50,960
称为内存池。


00:04:50,960 --> 00:04:53,280
你不能阻止这种双重支付攻击，

00:04:53,280 --> 00:04:56,000
接下来会发生的是，

00:04:56,000 --> 00:04:57,759
这个人会在这台计算机中插入一个交易，这个绿色的交易，

00:04:57,759 --> 00:05:02,400
这个绿色的交易，

00:05:02,400 --> 00:05:05,680
然后他们可以去这里做同样的攻击

00:05:05,680 --> 00:05:08,400
再次将这个第二个红色交易插入这台计算机。

00:05:08,400 --> 00:05:11,199
但显然，

00:05:11,199 --> 00:05:12,880
这两个交易并没有直接写入文件，

00:05:12,880 --> 00:05:15,759
它们首先被存储在临时内存中。

00:05:15,759 --> 00:05:16,479
然后，

00:05:16,479 --> 00:05:18,400
同样的事情再次发生，

00:05:18,400 --> 00:05:20,560
两个交易在网络中传播，

00:05:20,560 --> 00:05:23,039
这个节点会拒绝绿色交易，

00:05:23,039 --> 00:05:25,919
因为他们已经接收到了红色交易。

00:05:25,919 --> 00:05:28,800
所以我们看到，

00:05:28,800 --> 00:05:30,639
两个交易都在网络中，

00:05:30,639 --> 00:05:32,000
但它们还没有写入文件，

00:05:32,000 --> 00:05:34,560
所以文件仍然是安全的。

00:05:34,560 --> 00:05:36,880
然后会发生的事情是，

00:05:36,880 --> 00:05:44,880
所有的这些计算机都会努力尝试从他们的内存池中获取交易，

00:05:44,880 --> 00:05:46,720
并将其添加到文件中。

00:05:46,720 --> 00:05:49,120
所以他们基本上都在竞争，

00:05:49,120 --> 00:05:53,199
要成为第一个将内存池中的交易添加到文件中的节点。

00:05:53,199 --> 00:05:56,880
假设这个节点是第一个能够做到的，

00:05:56,880 --> 00:05:58,800
他们将他们的内存池中的交易添加到文件中，

00:05:58,800 --> 00:06:00,400
就像这样……

00:06:00,400 --> 00:06:03,360
当他们这样做的时候，

00:06:03,360 --> 00:06:08,880
他们会将更新后的文件副本传递给他们连接的所有其他节点，

00:06:08,880 --> 00:06:11,039
然后他们会更新他们的副本。

00:06:11,039 --> 00:06:13,280
这个节点，

00:06:13,280 --> 00:06:16,560
因为他们的内存池中有这个冲突的绿色交易，

00:06:16,560 --> 00:06:19,680
但他们刚刚接收到这个红色交易，

00:06:19,680 --> 00:06:22,000
消费了同样的比特币，

00:06:22,000 --> 00:06:28,880
他们会将这个绿色交易从他们的内存池中剔除。

00:06:28,880 --> 00:06:30,880
这个内存池就像一个等待区域或者一个清算所，

00:06:30,880 --> 00:06:33,120
他们接收到了这个红色交易在更新的文件中，

00:06:33,120 --> 00:06:35,360
然后他们会剔除这个冲突的交易。

00:06:35,360 --> 00:06:39,520
然后这个节点会将更新的副本传递给这些节点，

00:06:39,520 --> 00:06:41,199
他们也会做同样的事情，

00:06:41,199 --> 00:06:46,000
他们会从他们的内存池中剔除任何冲突的交易。

00:06:46,000 --> 00:06:50,080
这就是你如何解决网络中有两个冲突交易的问题的方法，

00:06:50,080 --> 00:06:54,080
你只需要有一个等待区域，

00:06:54,080 --> 00:06:56,720
所有的节点都在竞争，

00:06:56,720 --> 00:07:01,039
试图将他们的交易添加到文件中，

00:07:01,039 --> 00:07:04,560
这个过程就叫做挖矿，

00:07:04,560 --> 00:07:06,080
这个人获得了比特币。

00:07:06,080 --> 00:07:07,759
所以这个过程，

00:07:07,759 --> 00:07:10,800
每个节点都在竞争，

00:07:10,800 --> 00:07:14,240
试图从他们的内存池中获取交易，

00:07:14,240 --> 00:07:15,759
然后添加到文件中，

00:07:15,759 --> 00:07:17,280
这就叫做挖矿，

00:07:17,280 --> 00:07:18,639
这就是我现在要解释的。

00:07:18,639 --> 00:07:20,800
那么，

00:07:20,800 --> 00:07:23,039
到目前为止有问题吗?

00:07:23,039 --> 00:07:25,759
但是这里需要注意的一点是，

00:07:25,759 --> 00:07:29,840
网络中的每个节点并不一定都在挖矿。

00:07:29,840 --> 00:07:32,240
是的，

00:07:32,240 --> 00:07:37,280
我做了一个非常简单的图表来尝试解释这个问题。

00:07:37,280 --> 00:07:39,360
有些节点可能并不是在挖矿，

00:07:39,360 --> 00:07:43,360
你可以只运行一个节点来传递区块和交易信息。

00:07:43,360 --> 00:07:47,680
但在这个简化的图表中，

00:07:47,680 --> 00:07:50,400
每个节点都在尝试挖矿。

00:07:50,400 --> 00:07:53,360
我们也可以设想一个不挖矿的节点，

00:07:53,360 --> 00:07:58,479
如果它收到一个包含交易信息的区块

00:07:58,720 --> 00:08:01,280
而内存池中有一个与之冲突的交易，

00:08:01,280 --> 00:08:03,039
它会将其移除。

00:08:03,039 --> 00:08:05,520
是的

00:08:05,520 --> 00:08:07,120
所有的区块和交易信息传递，

00:08:07,120 --> 00:08:09,360
节点都会做这个工作，

00:08:09,360 --> 00:08:13,199
但是矿工只会做这最后一部分，

00:08:13,199 --> 00:08:15,599
试图从内存池中添加交易信息。

00:08:15,599 --> 00:08:17,759
这就是矿工的工作，

00:08:17,759 --> 00:08:21,440
你可以成为一个节点，而不必挖矿。

00:08:21,440 --> 00:08:25,639
而不必挖矿。

00:08:26,319 --> 00:08:29,599
我的介绍还可以吗？

00:08:29,599 --> 00:08:33,519
接下来我要解释的是哈希函数，

00:08:33,519 --> 00:08:38,880
然后我会讲解比特币挖矿是如何工作的。

00:08:38,880 --> 00:08:41,279
好的，

00:08:41,279 --> 00:08:48,320
哈希函数其实就是一个小型的计算机程序，

00:08:48,320 --> 00:08:53,360
它的工作方式是你可以将一些数据输入到哈希函数中，

00:08:53,360 --> 00:09:06,160
哈希函数会将其打乱并产生一个随机的数据字符串作为结果。

00:09:06,320 --> 00:09:08,800
哈希函数的一个有用的特性是，

00:09:08,800 --> 00:09:12,640
你可以将相同的数据输入到它中，

00:09:12,640 --> 00:09:16,480
它总是会输出相同的结果，

00:09:16,480 --> 00:09:22,080
也就是以相同的方式打乱数据以产生这个随机的数据字符串。

00:09:22,080 --> 00:09:23,600
这个数据字符串的大小总是相同的，

00:09:23,600 --> 00:09:26,880
为32字节或64个字符，

00:09:26,880 --> 00:09:32,560
因为每个字节有两个字符。

00:09:32,560 --> 00:09:38,160
如果你对输入到哈希函数中的数据做一个微小的调整，

00:09:38,160 --> 00:09:43,200
比如从a1变为a2，

00:09:43,200 --> 00:09:45,519
结果会完全不同。

00:09:45,519 --> 00:09:47,600
我们只做了一个微小的调整，

00:09:47,600 --> 00:09:51,440
但哈希函数的结果却大不相同。

00:09:51,440 --> 00:09:54,399
再次输入a3，

00:09:54,399 --> 00:09:55,839
微小的调整，

00:09:55,839 --> 00:09:57,440
结果还是完全不同。

00:09:57,440 --> 00:10:01,839
哈希函数的一个重要特性是，

00:10:01,839 --> 00:10:06,880
如果你事先不知道结果，

00:10:06,880 --> 00:10:11,200
就无法预测a2会输出什么。

00:10:11,200 --> 00:10:11,920
结论：

00:10:11,920 --> 00:10:15,760
如果你事先不知道这个结果，

00:10:15,760 --> 00:10:19,440
就无法预测结果到是什么，

00:10:19,440 --> 00:10:22,959
这是很有用的，

00:10:22,959 --> 00:10:24,160
我们稍后会看到。

00:10:24,160 --> 00:10:25,760
最后，

00:10:25,760 --> 00:10:30,079
尽管这看起来像一个随机的数据字符串，

00:10:30,079 --> 00:10:31,440
它包含了字母f、e、a，

00:10:31,440 --> 00:10:34,959
基本上是a、b、c、d、e和f，

00:10:34,959 --> 00:10:37,760
但它们实际上可以转换成数字。

00:10:37,760 --> 00:10:44,839
这是因为我们习惯于使用十进制格式的数字，

00:10:44,839 --> 00:10:48,320
它使用0到9的数字，

00:10:48,320 --> 00:10:52,880
但你也有一种叫做十六进制的数字格式，

00:10:52,880 --> 00:10:55,760
它使用相同的数字，

00:10:55,760 --> 00:10:59,360
但也包括a、b、c、d、e和f，

00:10:59,360 --> 00:11:01,680
当你转换它们时，

00:11:01,680 --> 00:11:04,240
它们就像这样。

00:11:04,480 --> 00:11:05,519
所以，

00:11:05,519 --> 00:11:07,279
这被称为十进制，

00:11:07,279 --> 00:11:08,160
因为它使用10，

00:11:08,160 --> 00:11:12,720
deci在拉丁语中意思是10。

00:11:12,720 --> 00:11:15,040
然后十六进制，

00:11:15,040 --> 00:11:18,800
hexa就像六边形一样有六个边，

00:11:18,800 --> 00:11:19,519
deci 10，6 10 16。

00:11:19,519 --> 00:11:21,920
所以，

00:11:21,920 --> 00:11:23,920
基本上这是我们人类使用的，

00:11:23,920 --> 00:11:26,560
但计算机非常乐意以十六进制格式读取数字。

00:11:26,560 --> 00:11:28,560
基本上来说，

00:11:28,560 --> 00:11:30,800
你把数据放入哈希函数，

00:11:30,800 --> 00:11:36,000
它会输出一个随机数作为结果。

00:11:36,000 --> 00:11:43,760
如果你看到一个像这样的十六进制格式字符串，

00:11:43,760 --> 00:11:46,480
记住这只是一个随机数。

00:11:46,480 --> 00:11:49,680
这个概念很容易理解了吧？

00:11:49,680 --> 00:11:51,360
好的，

00:11:51,360 --> 00:11:52,240
那就是哈希函数，

00:11:52,240 --> 00:11:54,399
它只是一个输出随机数据的小工具。

00:11:54,399 --> 00:11:58,240
如果我快速给你展示一下，

00:11:58,240 --> 00:11:59,760
我不知道你们是否能看到，

00:11:59,760 --> 00:12:03,760
是否能读懂

00:12:03,760 --> 00:12:06,959
但如果你能看到，

00:12:06,959 --> 00:12:08,720
哈希函数在很多编程语言中都有。

00:12:08,720 --> 00:12:11,360
例如，在PHP中，

00:12:11,360 --> 00:12:16,720
有一个叫做hash()的函数，

00:12:16,720 --> 00:12:20,560
然后你可以告诉它你想使用哪种哈希函数，

00:12:20,560 --> 00:12:22,079
比如sha256，

00:12:22,079 --> 00:12:23,920
这是比特币中使用的一种，

00:12:23,920 --> 00:12:29,959
它代表的是简单哈希算法256位，

00:12:29,959 --> 00:12:34,480
这是它输出结果的大小，

00:12:34,480 --> 00:12:36,560
然后你可以把你想要哈希的内容放进去。

00:12:36,560 --> 00:12:38,800
好了。

00:12:38,800 --> 00:12:41,440
这就是结果，

00:12:51,200 --> 00:12:57,440
你可以在任何编程语言中使用哈希函数

00:12:57,440 --> 00:12:59,920
我刚刚展示了如何在PHP中使用它

00:12:59,920 --> 00:13:04,000
这是在Ruby中，

00:13:04,000 --> 00:13:08,240
只是为了完整

00:13:08,240 --> 00:13:10,160
它包含在'digest'库中，

00:13:10,160 --> 00:13:18,480
所以你可以输入:' puts digest::SHA56

00:13:18,480 --> 00:13:21,839
然后我们需要一个十六进制摘要…

00:13:21,839 --> 00:13:26,000
“摘要”只是从哈希函数中得到的结果的另一个术语

00:13:26,000 --> 00:13:28,560
所以我把“a1”代入这里，

00:13:28,560 --> 00:13:30,639
这里我们得到了同样的东西，

00:13:30,639 --> 00:13:31,839
所以

00:13:31,839 --> 00:13:39,279
哈希函数在很多编程语言中都是可用的

00:13:39,279 --> 00:13:44,079
现在我将介绍挖矿的基本原理，

00:13:44,079 --> 00:13:49,360
我将给出一个简单的例子

00:13:49,360 --> 00:13:56,320
说明如何从内存池获取交易并将其添加到区块链中。

00:13:56,320 --> 00:13:58,639
所以，

00:13:58,639 --> 00:14:00,320
挖矿的基本原理是，

00:14:00,320 --> 00:14:02,079
所有的交易都在内存池中。

00:14:02,079 --> 00:14:16,399
*调整麦克风*

00:14:16,399 --> 00:14:19,199
我们继续来看到这个计算机，

00:14:19,199 --> 00:14:20,880
这个节点是一个矿工，

00:14:20,880 --> 00:14:22,800
我们来看看它的内部，

00:14:22,800 --> 00:14:27,600
看看它是如何从内存池中挖取交易到其文件的。

00:14:28,480 --> 00:14:41,680
*他调整麦克风*

00:14:41,680 --> 00:14:46,079
我们继续，查看比特币矿工的内部情况。

00:14:46,079 --> 00:14:47,680
这是内存池，

00:14:47,680 --> 00:14:49,680
里面有红色的是交易。

00:14:49,680 --> 00:14:52,240
交易在内存池中，

00:14:52,240 --> 00:14:56,639
但内存池中可以有多个交易。

00:14:56,639 --> 00:15:00,959
假设这个内存池已经有了很多交易。

00:15:00,959 --> 00:15:08,079
挖矿者会创建一个叫做候选块的容器，

00:15:08,079 --> 00:15:12,240
这只是一个交易的容器。

00:15:12,240 --> 00:15:18,800
他们会用内存池中的交易填充这个候选块，

00:15:18,800 --> 00:15:21,519
就像这样，

00:15:21,519 --> 00:15:26,480
然后他们会试图将这个交易块添加到区块链上。

00:15:26,480 --> 00:15:36,880
那么他们如何将这个他们构建的候选块添加到区块链上呢？

00:15:36,880 --> 00:15:38,880
首先，

00:15:38,880 --> 00:15:41,839
他们会构建一个被称为区块头的东西，

00:15:41,839 --> 00:15:44,000
这只是块内所有数据的摘要，

00:15:44,000 --> 00:15:47,839
所有区块内的交易，

00:15:47,839 --> 00:15:49,680
在那个区块头中，

00:15:49,680 --> 00:15:51,199
你有一个被称为版本的东西，

00:15:51,199 --> 00:15:54,800
这就像是数据结构的版本号，

00:15:54,800 --> 00:15:56,639
假设那是1。

00:15:56,639 --> 00:15:59,199
还会有一些被称为

00:15:59,199 --> 00:16:03,680
前一个区块或前一个区块哈希的信息。

00:16:03,680 --> 00:16:05,600
这个工作方式是，

00:16:05,600 --> 00:16:08,800
假设这是区块链，

00:16:08,800 --> 00:16:14,320
他们正在构建的这个候选块必须建立在这些区块之一的顶部。

00:16:14,320 --> 00:16:20,160
所以挖矿者会做的是，

00:16:20,160 --> 00:16:25,040
他们会包含他们想要建立在其顶部的区块的哈希或区块哈希，

00:16:25,040 --> 00:16:28,079
这就像是一个区块的id号。

00:16:28,079 --> 00:16:29,360
所以在这里，

00:16:29,360 --> 00:16:32,800
这是这个区块的区块哈希。

00:16:32,800 --> 00:16:37,360
所以这只是说他们想要建立在哪个区块的顶部，

00:16:37,360 --> 00:16:43,279
因为每个挖矿者基本上都想要建立在区块链的顶部。

00:16:43,279 --> 00:16:47,040
我来讲解“默克尔根”是什么

00:16:47,040 --> 00:16:48,720
基本上如果你把所有的交易ID一起哈希，

00:16:48,720 --> 00:16:52,639
反复的哈希，

00:16:52,639 --> 00:16:55,199
你最后会得到一个单独的哈希，

00:16:55,199 --> 00:16:59,120
这就叫做梅克尔根。

00:16:59,120 --> 00:17:00,240
就像这样，

00:17:00,240 --> 00:17:02,639
这基本上就像一个指纹，

00:17:02,639 --> 00:17:04,959
一个数字指纹，

00:17:04,959 --> 00:17:12,160
总结了区块中的所有交易。

00:17:12,160 --> 00:17:14,319
所以，

00:17:14,319 --> 00:17:17,119
你知道这个区块头，

00:17:17,119 --> 00:17:18,720
它创建了一个独特的指纹，

00:17:18,720 --> 00:17:21,839
用于所有的区块数据，

00:17:21,839 --> 00:17:24,160
但使用的数据比所有的交易数据组合起来要少得多。

00:17:24,160 --> 00:17:28,720
或许你能谈一谈默克尔根

00:17:28,720 --> 00:17:34,160
因为我没有听说过太多关于它的事情。

00:17:34,160 --> 00:17:36,400
你是在哈希每一笔交易，

00:17:36,400 --> 00:17:40,640
然后哈希那些结果吗？

00:17:40,640 --> 00:17:42,960
是的，我会在接下来的技术部分中介绍这个，

00:17:42,960 --> 00:17:44,720
但只要现在你需要知道：

00:17:50,799 --> 00:17:52,720
涵盖所有区块交易的总结就可以了。

00:17:52,720 --> 00:17:54,720
默克尔根是非常有意义的。

00:17:54,720 --> 00:17:57,520
我会在一会儿介绍梅克尔是如何工作的，

00:17:57,520 --> 00:18:00,000
以及为什么使用梅克尔，

00:18:00,000 --> 00:18:02,240
这是一个好问题。

00:18:02,240 --> 00:18:04,000
这是区块头，

00:18:04,000 --> 00:18:07,600
我没有涵盖所有的区块头数据，

00:18:07,600 --> 00:18:09,520
那么这就是是最重要的东西。

00:18:09,520 --> 00:18:14,880
现在我们有了一个区块头，

00:18:14,880 --> 00:18:19,919
下一步就是将这个区块头数据放入哈希函数，

00:18:19,919 --> 00:18:23,200
也就是SHA-256哈希函数中，

00:18:23,200 --> 00:18:27,600
然后这将产生一个随机数作为结果，

00:18:27,600 --> 00:18:31,919
这就是所谓的区块哈希。

00:18:32,000 --> 00:18:34,480
到目前为止你有任何问题吗？

00:18:34,480 --> 00:18:35,919
好的，

00:18:35,919 --> 00:18:38,559
这很好，我们继续，

00:18:38,559 --> 00:18:43,760
但是为什么矿工要这么做呢？

00:18:43,760 --> 00:18:46,240
或者说，这如何帮助将区块挖掘到区块链上呢？

00:18:46,240 --> 00:18:47,600
如果这个区块哈希，

00:18:47,600 --> 00:18:54,960
也就是将区块头放入哈希函数产生的结果，

00:18:54,960 --> 00:19:00,160
生成一个低于“Target”值的块哈希值

00:19:00,160 --> 00:19:02,320
就像这样，

00:19:02,320 --> 00:19:06,640
假设这是当前的目标值，

00:19:07,200 --> 00:19:15,120
这是每个比特币节点内部的一个数字，

00:19:15,120 --> 00:19:19,600
他们都有一个共享的目标值，

00:19:19,600 --> 00:19:23,840
这个目标值与其他节点同步计算。

00:19:23,840 --> 00:19:28,720
他们能让他们的区块哈希值低于这个目标值，

00:19:28,720 --> 00:19:30,320
那么这个区块就会被添加到区块链上，

00:19:30,320 --> 00:19:32,480
这个问题基本上解决了。

00:19:32,480 --> 00:19:34,320
所以，

00:19:34,320 --> 00:19:35,919
到目前为止，

00:19:35,919 --> 00:19:38,480
这是第一次尝试，

00:19:38,480 --> 00:19:40,160
你们可以看到，

00:19:40,160 --> 00:19:43,840
这个数字显然比目标值大，

00:19:43,840 --> 00:19:45,600
所以它不低于目标，

00:19:45,600 --> 00:19:48,160
所以，

00:19:48,160 --> 00:19:55,039
这第一次尝试添加这个区块到区块链上失败了。

00:19:55,039 --> 00:19:59,200
然后，矿工并不放弃。

00:19:59,200 --> 00:20:00,880
在区块头中，

00:20:00,880 --> 00:20:06,480
有一个额外的字段叫做nonce，

00:20:06,480 --> 00:20:12,400
它代表一次性使用的数字。

00:20:12,400 --> 00:20:16,240
这是一个开放的字段，

00:20:16,240 --> 00:20:20,240
矿工可以自由地放入他们自己的数字或数据。

00:20:20,240 --> 00:20:22,960
所以，

00:20:22,960 --> 00:20:24,480
如果区块头的第一次尝试失败，

00:20:24,480 --> 00:20:28,559
他们可以改变nonce值或改变nonce中的数据。

00:20:28,559 --> 00:20:31,120
例如，

00:20:31,120 --> 00:20:33,520
第一次尝试可能他们在那里放了数字零，

00:20:33,520 --> 00:20:35,600
如果那失败了，

00:20:35,600 --> 00:20:37,840
他们会改变nonce，

00:20:37,840 --> 00:20:39,600
然后再次将区块头通过哈希函数。

00:20:39,600 --> 00:20:41,919
因为我们只做了一点小的调整

00:20:41,919 --> 00:20:44,880
就像我之前给你们展示的哈希函数，

00:20:44,880 --> 00:20:50,080
小的调整可以产生完全不同的结果。

00:20:50,080 --> 00:20:54,720
所以，矿工基本上会构造一个区块头，

00:20:54,720 --> 00:20:58,720
并不断改变这个nonce值，

00:20:58,720 --> 00:21:04,159
希望结果会产生一个低于目标值的区块哈希。

00:21:04,159 --> 00:21:08,080
所以，矿工实际上是创建一个区块头，

00:21:08,080 --> 00:21:09,919
然后在末尾添加一个nonce，

00:21:09,919 --> 00:21:12,400
如果不成功，

00:21:12,400 --> 00:21:14,840
他们会不断增加尝试，

00:21:14,840 --> 00:21:17,679
这完全是随机的，

00:21:17,679 --> 00:21:19,200
…这只是纯粹的随机性和纯粹的运气…

00:21:19,200 --> 00:21:25,440
他们可能能够猜到一个有效的随机数，

00:21:25,440 --> 00:21:30,400
产生一个低于目标的区块哈希。

00:21:30,400 --> 00:21:32,640
所以，

00:21:32,640 --> 00:21:38,000
这个特定的非常高的随机数产生了一个成功的区块哈希结果。

00:21:38,000 --> 00:21:39,280
然后，

00:21:39,280 --> 00:21:43,120
这个节点会将该区块添加到他们的区块链中，

00:21:43,120 --> 00:21:50,640
并将这个已解决的候选区块传递给他们连接的所有节点。

00:21:50,640 --> 00:21:58,000
他们会检查并验证区块头确实产生了一个低于目标的区块哈希，

00:21:58,000 --> 00:22:00,880
然后将其添加到文件中，

00:22:00,880 --> 00:22:05,360
剔除包含在该区块中的任何冲突交易，

00:22:05,360 --> 00:22:08,240
然后像这样传递区块。

00:22:08,240 --> 00:22:09,360
他们也会做同样的事情。

00:22:09,360 --> 00:22:13,679
这就是挖矿在基本层面上的工作方式。

00:22:13,679 --> 00:22:19,440
我有个问题，

00:22:19,440 --> 00:22:24,559
你说的目标值，

00:22:24,840 --> 00:22:28,559
每个节点都有自己的目标值，

00:22:28,559 --> 00:22:30,480
对吗？我想过这个问题，

00:22:30,480 --> 00:22:37,919
但是有可能我挖到的区块低于我的目标值，

00:22:37,919 --> 00:22:40,960
然后我把它给我的邻居节点，

00:22:40,960 --> 00:22:44,400
可能目标值已经改变了，

00:22:44,400 --> 00:22:46,799
或者出于某种原因，

00:22:46,799 --> 00:22:49,039
其他节点的目标值不同。

00:22:49,039 --> 00:22:51,600
是的，

00:22:51,600 --> 00:22:53,760
我明白你的问题。

00:22:53,760 --> 00:22:59,360
我想我已经解释过目标了，

00:22:59,360 --> 00:23:02,159
可能我没有解释得很好，

00:23:02,159 --> 00:23:11,919
我再解释一下。

00:23:11,919 --> 00:23:17,440
目标的存在是为了确保每10分钟会有一个新的区块被挖出。

00:23:17,520 --> 00:23:19,760
但是，

00:23:19,760 --> 00:23:29,600
如果有更多的计算机以更快的速度进行哈希运算，

00:23:29,600 --> 00:23:32,880
那么一个区块可能会在10分钟内被挖出。

00:23:32,880 --> 00:23:34,240
因此，

00:23:34,240 --> 00:23:38,559
这个目标值会上下浮动，

00:23:38,559 --> 00:23:44,480
以确保每10分钟挖出一个新的区块。

00:23:44,480 --> 00:23:48,080
当你首次运行比特币并挖出第一个区块时，

00:23:48,080 --> 00:23:53,919
目标值是硬编码在这个值中的。

00:23:53,919 --> 00:23:57,039
然后，每过2016个区块，

00:23:59,200 --> 00:24:02,000
或者大约每两周，

00:24:02,000 --> 00:24:09,120
每个节点都会查看挖出最后2016个区块所需的时间。

00:24:09,120 --> 00:24:14,559
预期的时间显然是20160分钟，

00:24:14,559 --> 00:24:18,880
但如果实际挖出这些区块的时间少于这个时间，

00:24:18,880 --> 00:24:21,120
那么，目标会进行调整。

00:24:21,120 --> 00:24:25,200
目标会按照这个比例进行调整。

00:24:25,200 --> 00:24:26,000
所以，

00:24:26,000 --> 00:24:29,679
这个比例是因为所有的区块都被挖掘得更快，

00:24:29,679 --> 00:24:32,960
所以它是0.9。

00:24:32,960 --> 00:24:34,880
所以你可以看到，

00:24:34,880 --> 00:24:36,720
这个目标会向下调整。

00:24:36,720 --> 00:24:38,880
所以每个节点在接收到一个新的区块后，

00:24:38,880 --> 00:24:41,279
每2016个区块，

00:24:41,279 --> 00:24:45,360
他们都会做这个精确的计算。

00:24:45,360 --> 00:24:47,520
然后每个节点都从这个值开始，

00:24:47,520 --> 00:24:49,520
但是如果每个人都在同一个区块，

00:24:49,520 --> 00:24:53,840
那么每个人都会计算出同样的目标。

00:24:53,840 --> 00:24:56,720
所以基本上每个人都有同样的目标，

00:24:56,720 --> 00:24:59,840
他们都自己计算，

00:24:59,840 --> 00:25:02,000
但是因为他们都接收到同样的区块，

00:25:02,000 --> 00:25:04,159
他们都会计算出同样的目标值。

00:25:04,159 --> 00:25:07,520
所以不是每个人都有不同的目标值，

00:25:07,520 --> 00:25:10,799
个人都有同样的计算目标。

00:25:10,799 --> 00:25:13,360
所以再次强调，

00:25:13,360 --> 00:25:14,880
这每2016个区块就会发生一次，

00:25:14,880 --> 00:25:18,240
同样的事情会发生，

00:25:18,240 --> 00:25:19,440
他们花了多长时间，

00:25:19,440 --> 00:25:22,720
比例是多少，挖掘得更快，

00:25:23,360 --> 00:25:24,240
就再次向下调整，

00:25:24,240 --> 00:25:26,559
就像这样。

00:25:26,960 --> 00:25:29,120
那么，

00:25:29,120 --> 00:25:31,279
这就是Target 是如何工作的。

00:25:31,279 --> 00:25:36,159
到目前为止，

00:25:36,159 --> 00:25:39,520
我已经把这个区块链称为一个共享文件，

00:25:39,520 --> 00:25:41,919
这个共享文件是一个区块链。

00:25:41,919 --> 00:25:45,440
基本上，这个共享文件充满了交易，

00:25:45,440 --> 00:25:48,559
因为交易是以区块的形式添加的，

00:25:48,559 --> 00:25:50,240
这个文件被称为区块链，

00:25:50,240 --> 00:25:52,480
因为每个区块都在彼此之上建立。

00:25:52,480 --> 00:25:54,559
所以对于比特币来说，

00:25:54,559 --> 00:25:56,240
它是一个共享文件，

00:25:56,240 --> 00:25:57,919
这个共享文件被称为区块链。

00:25:57,919 --> 00:26:00,320
所以如果我更新这个图，

00:26:00,320 --> 00:26:06,000
你可以把这个共享文件想象成就是一堆堆叠在一起的区块。

00:26:06,000 --> 00:26:07,520
最后，

00:26:07,520 --> 00:26:09,679
为什么有人会挖矿呢？

00:26:09,679 --> 00:26:11,279
对于矿工来说，

00:26:11,279 --> 00:26:15,679
他们为什么要在他们的电脑上使用所有这些哈希算力

00:26:15,679 --> 00:26:20,799
来尝试从内存池中挖掘交易到区块链呢？

00:26:20,799 --> 00:26:25,520
每次矿工成功挖掘一个区块，

00:26:25,520 --> 00:26:27,919
们都会得到一个叫做区块奖励的东西。

00:26:27,919 --> 00:26:30,159
它开始时是50，

00:26:30,159 --> 00:26:34,559
但大约每四年就会减半。

00:26:34,799 --> 00:26:37,600
所以这就是挖掘一个区块的激励。

00:26:37,600 --> 00:26:40,640
当矿工构建候选区块时，

00:26:40,640 --> 00:26:45,120
他们会得到这个区块奖励。

00:26:45,120 --> 00:26:49,440
第一笔交易是他们自己的。

00:26:49,440 --> 00:26:55,600
矿工会把他们自己的交易放在最顶部，

00:26:55,600 --> 00:26:57,039
这叫做coinbase交易。

00:26:57,039 --> 00:27:01,440
这是一种特殊的交易，

00:27:01,440 --> 00:27:07,440
因为它允许他们向自己发送一定数量的比特币，

00:27:07,440 --> 00:27:12,240
这些比特币之前并不存在。

00:27:12,240 --> 00:27:13,039
所以，

00:27:13,039 --> 00:27:16,320
如果这个区块被挖掘到区块链上，

00:27:16,320 --> 00:27:19,600
他们将能够通过这个coinbase交易接收新的比特币。

00:27:19,600 --> 00:27:21,440
多亏了这个coinbase交易，

00:27:21,440 --> 00:27:25,360
他们在这里放置他们的比特币地址，

00:27:25,360 --> 00:27:28,960
以便他们可以接收区块奖励。

00:27:28,960 --> 00:27:30,640
总结一下挖矿的基本步骤，

00:27:30,640 --> 00:27:34,480
矿工会从内存池中获取交易，

00:27:34,480 --> 00:27:37,200
然后他们会在顶部放置他们的coinbase交易，

00:27:37,200 --> 00:27:40,080
以便如果他们成功挖掘这个区块到区块链上，

00:27:40,080 --> 00:27:41,600
可以接收区块奖励。

00:27:41,600 --> 00:27:43,760
然后他们会创建一个区块头，

00:27:43,760 --> 00:27:45,679
对其进行哈希。

00:27:45,679 --> 00:27:48,000
希望哈希值低于目标值，

00:27:48,000 --> 00:27:49,679
如果不是，

00:27:49,679 --> 00:27:52,000
他们会不断调整nonce，

00:27:52,000 --> 00:27:56,480
直到他们领先于别人找到一个nonce，

00:27:56,480 --> 00:27:58,159
这个nonce产生的区块哈希值低于目标值。

00:27:58,159 --> 00:28:01,440
然后他们会将区块添加到区块链上。

00:28:01,440 --> 00:28:03,840
像这样。你理解了吗?

00:28:04,080 --> 00:28:06,320
你理解了吗?

00:28:06,320 --> 00:28:08,159
okay

00:28:08,159 --> 00:28:16,240
我现在将向你展示一个小型的挖矿模拟器。

00:28:16,240 --> 00:28:27,279
这就是比特币矿机在内部可能看起来的样子。

00:28:27,279 --> 00:28:31,600
他们会进入他们的内存池，

00:28:31,600 --> 00:28:34,080
从内存池中获取交易。

00:28:34,080 --> 00:28:40,000
这个挖矿模拟器正在挖掘一个已经被挖掘过的区块，

00:28:40,000 --> 00:28:41,679
这是很久以前的事情，

00:28:41,679 --> 00:28:43,279
内存池中只有13个交易。

00:28:43,279 --> 00:28:45,440
现在显然更多了。

00:28:45,440 --> 00:28:46,720
然后它们会做什么呢，

00:28:46,720 --> 00:28:48,240
它们会构建区块头，

00:28:48,240 --> 00:28:52,399
我还没有介绍区块头的最后两部分，

00:28:52,399 --> 00:28:53,679
不过别担心，

00:28:53,679 --> 00:28:54,640
我马上就会介绍。

00:28:54,640 --> 00:28:56,399
但这些数据是指前一个区块...

00:28:56,399 --> 00:29:00,640
有默克尔根，版本号。

00:29:00,640 --> 00:29:03,440
然后他们会做的是，

00:29:03,440 --> 00:29:06,720
把所有这些数据压缩成一行数据。

00:29:06,720 --> 00:29:08,480
我在这里留了一些空间用于nonce，

00:29:08,480 --> 00:29:11,520
这是区块头数据，

00:29:11,520 --> 00:29:13,840
这是目标值。

00:29:13,840 --> 00:29:16,320
然后矿工会做的是，

00:29:16,320 --> 00:29:18,080
他们会取这个区块头，

00:29:18,080 --> 00:29:19,760
并在其中放入一个nonce，

00:29:19,760 --> 00:29:22,640
不断增加它，

00:29:22,640 --> 00:29:24,399
正如你现在看到的。

00:29:24,399 --> 00:29:26,240
这是一个非常慢的矿工，

00:29:26,240 --> 00:29:30,720
你可以看到这些是左边的随机数值，

00:29:30,720 --> 00:29:33,919
这些是区块头正在产生的不同的哈希值。

00:29:33,919 --> 00:29:35,760
好的，

00:29:35,760 --> 00:29:39,120
所以当你在顶部创建那个字符串...？

00:29:39,120 --> 00:29:42,080
那并没有包括交易，

00:29:42,080 --> 00:29:45,440
只包括了区块头？

00:29:45,440 --> 00:29:46,159
是的

00:29:46,159 --> 00:29:51,279
哦，好的。

00:29:51,279 --> 00:29:55,600
交易我想是包含在这个默克尔根里，

00:29:55,600 --> 00:29:58,720
这个默克尔根是所有交易的摘要，

00:29:58,720 --> 00:30:03,039
它指向区块中的所有交易。

00:30:03,039 --> 00:30:05,760
这里是这个矿工的代码，

00:30:05,760 --> 00:30:11,600
它只是挖掘了一个区块头，

00:30:11,600 --> 00:30:15,200
我已经在网站上提供了这个代码，

00:30:15,200 --> 00:30:17,200
我会在一会儿给你一个链接。

00:30:17,200 --> 00:30:21,440
对于这个特定的矿工，

00:30:21,440 --> 00:30:29,200
我知道成功的哈希是什么。

00:30:29,520 --> 00:30:34,000
让我们把这个减少100。

00:30:34,000 --> 00:30:37,200
如果我再次启动这个，

00:30:37,200 --> 00:30:41,520
我已经增加了开始的nonce值，

00:30:41,520 --> 00:30:43,840
所以再次强调，这是区块头。

00:30:43,840 --> 00:30:45,200
这次，随机数不是从0开始，

00:30:45,200 --> 00:30:47,360
而是从一个更高的数字开始。

00:30:47,360 --> 00:30:49,679
如果我现在让它运行，

00:30:49,679 --> 00:30:53,919
希望在大约100次之后，

00:30:53,919 --> 00:30:57,760
当它找到一个低于目标值的区块哈希时，它会停止。

00:30:57,919 --> 00:31:01,200
这里我们来看看，

00:31:01,200 --> 00:31:02,880
如果你看到这个，

00:31:02,880 --> 00:31:04,480
区块已经被挖出来了。

00:31:04,480 --> 00:31:08,000
这个特定的区块哈希完全是随机的，

00:31:08,000 --> 00:31:12,320
纯粹是运气使得区块哈希以这么多个零开头，

00:31:12,320 --> 00:31:14,240
这个值低于目标值，

00:31:14,240 --> 00:31:16,080
所以矿工们就是这样做的，

00:31:16,080 --> 00:31:18,640
他们只是抓取一个区块头，

00:31:18,640 --> 00:31:21,360
改变随机数，尽可能快地进行哈希。

00:31:21,360 --> 00:31:23,279
这个理解起来有问题吗？

00:31:23,279 --> 00:31:24,880
好的，

00:31:24,880 --> 00:31:29,440
我会在最后添加这些链接，

00:31:29,440 --> 00:31:32,720
你去网站learnmebitcoin.com看代码部分，

00:31:32,720 --> 00:31:37,519
我已经把挖矿模拟器的代码放在这里了。

00:31:37,519 --> 00:31:40,320
这是用Ruby写的，

00:31:40,320 --> 00:31:44,799
我觉得这是一种简单易读的语言，

00:31:44,799 --> 00:31:47,440
类似于Python。

00:31:47,440 --> 00:31:49,200
我试图让这个尽可能简单，

00:31:49,200 --> 00:31:51,120
所以如果你想开始哈希你自己的区块头，

00:31:51,120 --> 00:31:53,120
你可以这样做。

00:31:53,120 --> 00:31:55,039
你也可以在浏览器上，

00:31:55,039 --> 00:32:00,080
打开learnmeabitcoin.com

00:32:00,080 --> 00:32:04,480
你将能够看到这些最新的区块，

00:32:04,480 --> 00:32:07,200
这些是区块头，

00:32:07,200 --> 00:32:10,640
如果你点击序列化，

00:32:10,880 --> 00:32:14,399
它会显示序列化的代码，

00:32:14,399 --> 00:32:16,399
如果你对这个进行哈希，

00:32:16,399 --> 00:32:21,919
它会产生这个区块头，

00:32:21,919 --> 00:32:23,679
这是一个候选区块,

00:32:23,679 --> 00:32:26,559
在尝试做同样的事情。

00:32:26,559 --> 00:32:30,159
我很好奇，

00:32:30,159 --> 00:32:35,679
这个是在你的机器上运行的吗？

00:32:35,679 --> 00:32:38,159
这是实时的吗？

00:32:38,159 --> 00:32:39,919
是的，这是实时的。

00:32:39,919 --> 00:32:41,840
这是一个实时的候选区块，

00:32:41,840 --> 00:32:45,760
这些都是实时的交易，

00:32:46,000 --> 00:32:54,080
一切都在浏览器上。

00:32:54,559 --> 00:32:58,480
好的，

00:32:58,480 --> 00:33:01,200
这就是基础知识的介绍。

00:33:01,200 --> 00:33:04,559
现在我将从技术角度来讲解，

00:33:04,559 --> 00:33:06,159
基本上我要讲一遍同样的事情，

00:33:06,159 --> 00:33:10,559
但是从程序员的角度来讲解。

00:33:10,559 --> 00:33:16,720
如果你对编程和挖矿感兴趣，

00:33:16,720 --> 00:33:19,039
这基本上就是和之前同样的内容，

00:33:19,039 --> 00:33:21,120
只是从程序员的角度来看。

00:33:21,120 --> 00:33:23,120
再次重复，

00:33:23,120 --> 00:33:27,200
从内存池中获取交易，

00:33:27,200 --> 00:33:30,240
填充你的区块，

00:33:30,240 --> 00:33:34,000
然后你会得到一个候选区块，

00:33:34,000 --> 00:33:38,159
然后你在顶部放置你的coinbase交易。

00:33:38,159 --> 00:33:41,840
一个区块的第一笔交易总是coinbase交易，

00:33:41,840 --> 00:33:45,120
这是矿工放在那里的。

00:33:45,120 --> 00:33:46,960
这样你就可以领取区块奖励，

00:33:46,960 --> 00:33:50,159
当前是比特币12.5个。

00:33:50,159 --> 00:33:51,600
在选择了所有这些交易之后，

00:33:51,600 --> 00:33:56,080
你会将coinbase交易放在区块的顶部的原因是什么？

00:33:56,080 --> 00:33:57,360
每一笔交易都会有一个费用，

00:33:57,360 --> 00:34:02,559
通过你的coinbase交易，

00:34:02,559 --> 00:34:07,760
你可以收集所有这些费用。

00:34:07,760 --> 00:34:12,560
所以，coinbase交易不仅仅是接收12.5个区块奖励，

00:34:12,560 --> 00:34:14,239
你还可以根据这些费用的价值，

00:34:14,239 --> 00:34:17,040
给自己发送13个或更多的比特币。

00:34:17,040 --> 00:34:19,040
所以，

00:34:19,040 --> 00:34:23,520
coinbase交易包括了费用是吗？

00:34:23,520 --> 00:34:25,280
是的，

00:34:25,280 --> 00:34:27,599
它不仅包括挖矿奖励。

00:34:27,599 --> 00:34:31,520
你还有基础级别的区块奖励，

00:34:31,520 --> 00:34:33,760
但是你可以根据每笔交易的费用，

00:34:33,760 --> 00:34:38,239
给自己发送多少比特币。

00:34:38,239 --> 00:34:40,560
so this means that miners will tend to

00:34:40,560 --> 00:34:41,760
pick uh

00:34:41,760 --> 00:34:42,800
uh

00:34:42,800 --> 00:34:47,040
transactions with a higher exactly yes

00:34:47,040 --> 00:34:48,639
uh so there we are we've got the

00:34:48,639 --> 00:34:50,800
transfer one more question on that uh

00:34:50,800 --> 00:34:53,040
yeah so i i remember seeing a graph

00:34:53,040 --> 00:34:54,879
where uh

00:34:54,879 --> 00:34:57,760
you know it showed me like uh

00:34:57,760 --> 00:34:59,839
on the left the fees and on the right

00:34:59,839 --> 00:35:02,079
like kind of how much time it will take

00:35:02,079 --> 00:35:05,760
to mine that block yeah so uh

00:35:05,760 --> 00:35:08,160
uh does this mean that

00:35:08,160 --> 00:35:09,119
you know

00:35:09,119 --> 00:35:12,000
if we put a very very low fee is it ever

00:35:12,000 --> 00:35:14,400
possible that our transaction will never

00:35:14,400 --> 00:35:16,880
get uh

00:35:16,880 --> 00:35:19,040
never be part of a block is that ever

00:35:19,040 --> 00:35:21,280
possible in your experience or what can

00:35:21,280 --> 00:35:23,359
happen is so say you make a transaction

00:35:23,359 --> 00:35:26,079
it'll go into the memory pool first um

00:35:26,079 --> 00:35:27,359
if there's a lot of transactions in the

00:35:27,359 --> 00:35:28,640
memory pool

00:35:28,640 --> 00:35:30,640
um then you basically basically your

00:35:30,640 --> 00:35:32,560
transaction is competing with all these

00:35:32,560 --> 00:35:35,200
other transactions for space in a block

00:35:35,200 --> 00:35:36,640
because a block

00:35:36,640 --> 00:35:38,720
it's the way a block is

00:35:38,720 --> 00:35:40,720
it used to be one megabytes worth of

00:35:40,720 --> 00:35:43,839
transactions um it's roughly about 1.7

00:35:43,839 --> 00:35:44,880
now

00:35:44,880 --> 00:35:46,640
it uses a different metric called weight

00:35:46,640 --> 00:35:48,320
but don't i'm not going to cover that

00:35:48,320 --> 00:35:50,160
just now but um

00:35:50,160 --> 00:35:51,760
what will happen is say you put such a

00:35:51,760 --> 00:35:53,040
low fee on there

00:35:53,040 --> 00:35:54,960
that um it doesn't make it into the

00:35:54,960 --> 00:35:56,560
blocks are still hanging around in the

00:35:56,560 --> 00:35:58,800
memory pool um

00:35:58,800 --> 00:36:00,640
if your transaction stays in the memory

00:36:00,640 --> 00:36:03,440
pool memory pool for longer than 72

00:36:03,440 --> 00:36:05,520
hours

00:36:05,520 --> 00:36:07,200
on average um

00:36:07,200 --> 00:36:08,160
your

00:36:08,160 --> 00:36:09,359
transaction will just get kicked out the

00:36:09,359 --> 00:36:10,640
memory pool

00:36:10,640 --> 00:36:11,440
so

00:36:11,440 --> 00:36:13,440
you if you put a very low transaction a

00:36:13,440 --> 00:36:15,440
fee on a transaction there's a chance

00:36:15,440 --> 00:36:18,000
that it will never make it um one into a

00:36:18,000 --> 00:36:20,640
into a candidate block or even it or

00:36:20,640 --> 00:36:22,320
onto the blockchain right

00:36:22,320 --> 00:36:24,320
so again in your experience what's like

00:36:24,320 --> 00:36:26,480
the like the bare minimum let's say if i

00:36:26,480 --> 00:36:28,320
want to send like five bucks to someone

00:36:28,320 --> 00:36:29,839
you know or buy a coffee like three

00:36:29,839 --> 00:36:30,720
bucks

00:36:30,720 --> 00:36:33,920
uh what's what's the minimum

00:36:33,920 --> 00:36:35,839
fee that i have to pay i mean

00:36:35,839 --> 00:36:40,560
um i think wallets generally um

00:36:40,560 --> 00:36:41,680
tend to

00:36:41,680 --> 00:36:42,960
um

00:36:42,960 --> 00:36:44,240
help you out with that but i don't think

00:36:44,240 --> 00:36:46,320
they created it but

00:36:46,320 --> 00:36:48,480
um

00:36:48,480 --> 00:36:49,839
one way

00:36:49,839 --> 00:36:52,079
what i would do is i would look at a cat

00:36:52,079 --> 00:36:54,960
this candidate block and

00:36:54,960 --> 00:36:56,960
transactions in general are ordered in a

00:36:56,960 --> 00:36:58,640
candidate block from highest to lowest

00:36:58,640 --> 00:37:01,359
fees not strictly but i would head

00:37:01,359 --> 00:37:02,560
towards the bottom of this candidate

00:37:02,560 --> 00:37:04,960
block and have a look at each of the fee

00:37:04,960 --> 00:37:07,040
the fees on them and

00:37:07,040 --> 00:37:08,560
um

00:37:08,560 --> 00:37:09,920
uh

00:37:09,920 --> 00:37:12,400
you can just basically add a fee that's

00:37:12,400 --> 00:37:15,119
greater than the lowest fees yeah

00:37:15,119 --> 00:37:16,960
exactly that's a

00:37:16,960 --> 00:37:18,880
rough i mean that's like the simplest

00:37:18,880 --> 00:37:22,000
way to do it in my opinion um

00:37:22,000 --> 00:37:23,040
so

00:37:23,040 --> 00:37:25,599
yeah yeah so again this is per byte i

00:37:25,599 --> 00:37:28,480
think when you hovered over uh yeah so

00:37:28,480 --> 00:37:32,400
fee per byte so this is uh

00:37:32,400 --> 00:37:34,320
so the average

00:37:34,320 --> 00:37:37,119
byte size of a transaction is that what

00:37:37,119 --> 00:37:39,200
this is yeah so

00:37:39,200 --> 00:37:40,000
um

00:37:40,000 --> 00:37:42,720
so this this is a transaction

00:37:42,720 --> 00:37:44,000
and um this

00:37:44,000 --> 00:37:47,359
yeah this takes up um space in a block

00:37:47,359 --> 00:37:50,560
so um then you set a fee on it but

00:37:50,560 --> 00:37:51,839
you're basically paying for each

00:37:51,839 --> 00:37:53,839
individual bytes so that the the bigger

00:37:53,839 --> 00:37:54,960
the um

00:37:54,960 --> 00:37:57,520
the transaction is in data wise uh the

00:37:57,520 --> 00:37:59,200
more of a higher fee you want to put on

00:37:59,200 --> 00:38:01,119
it to give you because

00:38:01,119 --> 00:38:02,880
a miner but they will

00:38:02,880 --> 00:38:05,839
select transactions um based on fee per

00:38:05,839 --> 00:38:07,520
byte so basically which transactions are

00:38:07,520 --> 00:38:09,440
giving them the most fee for the space

00:38:09,440 --> 00:38:10,720
they're going to take up in the

00:38:10,720 --> 00:38:12,480
candidate block

00:38:12,480 --> 00:38:13,599
okay

00:38:13,599 --> 00:38:15,119
um

00:38:15,119 --> 00:38:16,720
so again just going to went through

00:38:16,720 --> 00:38:17,920
mining again put your coinbase

00:38:17,920 --> 00:38:19,839
transaction at the top

00:38:19,839 --> 00:38:21,359
and then you can check the block header

00:38:21,359 --> 00:38:23,680
same again you have a version number

00:38:23,680 --> 00:38:24,560
um

00:38:24,560 --> 00:38:26,480
this was like this null block and the

00:38:26,480 --> 00:38:29,440
version of was one uh the way versions

00:38:29,440 --> 00:38:32,160
numbers has cha the way version numbers

00:38:32,160 --> 00:38:34,160
uh work now is different to how it used

00:38:34,160 --> 00:38:36,960
to be they can be used for um voting um

00:38:36,960 --> 00:38:38,079
i'm not going to cover that just now

00:38:38,079 --> 00:38:40,640
it's going to run through um

00:38:40,640 --> 00:38:42,400
simple block header then you have the

00:38:42,400 --> 00:38:44,160
previous block name again just refer to

00:38:44,160 --> 00:38:45,200
the block you're going to build on top

00:38:45,200 --> 00:38:47,119
of build on top of which is basically

00:38:47,119 --> 00:38:49,599
the tip of the blockchain

00:38:49,599 --> 00:38:51,599
uh then you have the merkle root

00:38:51,599 --> 00:38:54,079
so the way that works is um you have all

00:38:54,079 --> 00:38:55,920
the transactions uh

00:38:55,920 --> 00:38:57,119
in the block

00:38:57,119 --> 00:38:58,560
i'm just moving these to the side just

00:38:58,560 --> 00:39:00,480
for illustration purposes

00:39:00,480 --> 00:39:02,320
and what you do you just run through

00:39:02,320 --> 00:39:04,240
every single pair of transactions and

00:39:04,240 --> 00:39:05,839
you hash them together

00:39:05,839 --> 00:39:08,720
so remember the hash function and you

00:39:08,720 --> 00:39:10,560
basically line these up

00:39:10,560 --> 00:39:12,240
so one and two just line them up

00:39:12,240 --> 00:39:14,079
together and hash them together and

00:39:14,079 --> 00:39:15,760
they'll produce a

00:39:15,760 --> 00:39:17,920
digest or hash result

00:39:17,920 --> 00:39:19,359
and they do that for every single pair

00:39:19,359 --> 00:39:21,200
of transactions

00:39:21,200 --> 00:39:22,240
in the block

00:39:22,240 --> 00:39:24,960
um if you end up with a transaction on

00:39:24,960 --> 00:39:26,720
his own that doesn't have a pair all you

00:39:26,720 --> 00:39:29,440
do is you just hash it with itself

00:39:29,440 --> 00:39:31,680
and then that's the first round done you

00:39:31,680 --> 00:39:33,599
have these four hashes from all these

00:39:33,599 --> 00:39:34,800
pairs

00:39:34,800 --> 00:39:36,560
then you just run through again

00:39:36,560 --> 00:39:38,320
hash them all together hash each pair

00:39:38,320 --> 00:39:40,400
together and you keep going on and

00:39:40,400 --> 00:39:43,680
you'll end up with a single um

00:39:43,680 --> 00:39:44,880
hash result

00:39:44,880 --> 00:39:46,960
called the merkle root

00:39:46,960 --> 00:39:47,760
now

00:39:47,760 --> 00:39:49,839
the question is um

00:39:49,839 --> 00:39:51,119
why

00:39:51,119 --> 00:39:53,599
if you want to create a summary of all

00:39:53,599 --> 00:39:56,480
the transactions in the block you're

00:39:56,480 --> 00:39:57,839
hashing the transaction ids here

00:39:57,839 --> 00:40:00,160
together by the way but um

00:40:00,160 --> 00:40:01,359
if you want to create a summary or a

00:40:01,359 --> 00:40:02,720
fingerprint for all the transactions in

00:40:02,720 --> 00:40:04,560
the block why wouldn't you just hash

00:40:04,560 --> 00:40:06,320
them all together like this in a more

00:40:06,320 --> 00:40:07,760
simple way why would you do it in this

00:40:07,760 --> 00:40:09,280
more elaborate

00:40:09,280 --> 00:40:11,599
um tree structure

00:40:11,599 --> 00:40:13,520
and the reason for that is

00:40:13,520 --> 00:40:16,720
um say you you were given a merkle root

00:40:16,720 --> 00:40:17,839
um

00:40:17,839 --> 00:40:21,359
a merkel root and you want to check if

00:40:21,359 --> 00:40:23,599
this transaction id

00:40:23,599 --> 00:40:26,480
is present in this block

00:40:26,480 --> 00:40:29,359
um the only way you could check it

00:40:29,359 --> 00:40:30,800
would be to take

00:40:30,800 --> 00:40:32,400
all of the other

00:40:32,400 --> 00:40:34,160
transaction ids you need all the other

00:40:34,160 --> 00:40:36,079
ones including the one you want to check

00:40:36,079 --> 00:40:38,720
and then hash them together to get the

00:40:38,720 --> 00:40:40,400
miracle root

00:40:40,400 --> 00:40:41,680
um

00:40:41,680 --> 00:40:44,000
to get the to get the hash sorry

00:40:44,000 --> 00:40:44,800
um

00:40:44,800 --> 00:40:45,920
but

00:40:45,920 --> 00:40:47,760
with a miracle root um so you want to

00:40:47,760 --> 00:40:50,000
check the presence of this hash here all

00:40:50,000 --> 00:40:52,320
you actually need is you need this one

00:40:52,320 --> 00:40:54,000
to create this one

00:40:54,000 --> 00:40:55,760
and then if you've got that one and then

00:40:55,760 --> 00:40:57,599
all you need is that one

00:40:57,599 --> 00:40:59,280
and then you can create that one

00:40:59,280 --> 00:41:01,440
and then only then is this one up here

00:41:01,440 --> 00:41:03,920
and that will give you this miracle root

00:41:03,920 --> 00:41:06,480
so the other one needed was it one two

00:41:06,480 --> 00:41:10,240
three four five seven six um

00:41:10,240 --> 00:41:12,720
transaction ids but this one only needed

00:41:12,720 --> 00:41:13,920
uh three

00:41:13,920 --> 00:41:14,960
so obviously it doesn't look like a

00:41:14,960 --> 00:41:16,319
massive improvement but this is just a

00:41:16,319 --> 00:41:18,880
simple block that if this is a lot

00:41:18,880 --> 00:41:20,560
longer block with

00:41:20,560 --> 00:41:22,240
thousands of transactions

00:41:22,240 --> 00:41:23,520
then

00:41:23,520 --> 00:41:25,040
you're needing a lot less transaction

00:41:25,040 --> 00:41:26,480
ids to

00:41:26,480 --> 00:41:28,079
check the presence of a single

00:41:28,079 --> 00:41:30,079
transaction

00:41:30,079 --> 00:41:32,079
i've not done this myself but

00:41:32,079 --> 00:41:34,160
apparently this is useful and efficient

00:41:34,160 --> 00:41:35,599
to um

00:41:35,599 --> 00:41:37,280
do it this way so that's why we have

00:41:37,280 --> 00:41:38,640
this tree structure for hashing because

00:41:38,640 --> 00:41:41,520
it saves on checking for the presence of

00:41:41,520 --> 00:41:43,839
transactions in our block yeah just one

00:41:43,839 --> 00:41:46,400
question when you say that we we hash

00:41:46,400 --> 00:41:48,880
like two transactions you're saying that

00:41:48,880 --> 00:41:51,520
we just concatenate them and hash do a

00:41:51,520 --> 00:41:53,839
chat yeah 256. exactly you just

00:41:53,839 --> 00:41:57,760
concatenate the transaction ids

00:41:57,920 --> 00:41:59,440
which are basically the hashes of the

00:41:59,440 --> 00:42:01,040
time yeah so

00:42:01,040 --> 00:42:02,960
you basically hash transaction data to

00:42:02,960 --> 00:42:04,880
give you a transaction id and then you

00:42:04,880 --> 00:42:05,420
yeah yeah

00:42:05,420 --> 00:42:06,800
[Music]

00:42:06,800 --> 00:42:07,170
um

00:42:07,170 --> 00:42:08,319
[Music]

00:42:08,319 --> 00:42:10,319
so there we go um that's the merkel

00:42:10,319 --> 00:42:11,280
route

00:42:11,280 --> 00:42:13,760
uh time also in the block header

00:42:13,760 --> 00:42:15,359
you have something called but you just

00:42:15,359 --> 00:42:17,520
have the time which is a timestamp

00:42:17,520 --> 00:42:19,280
um like so

00:42:19,280 --> 00:42:21,839
but you don't the way the

00:42:21,839 --> 00:42:23,760
time is encoded in the block header is

00:42:23,760 --> 00:42:25,440
using unix time

00:42:25,440 --> 00:42:27,280
which is the number of seconds since the

00:42:27,280 --> 00:42:29,359
1st january 1970.

00:42:29,359 --> 00:42:30,880
so this

00:42:30,880 --> 00:42:34,480
blocks times timestamping so the human

00:42:34,480 --> 00:42:36,880
representation is 12 may 2011 but in

00:42:36,880 --> 00:42:38,960
unix time that would be this many

00:42:38,960 --> 00:42:41,040
seconds

00:42:41,040 --> 00:42:42,319
um

00:42:42,319 --> 00:42:43,599
a quick note

00:42:43,599 --> 00:42:45,680
on the time um these don't have to be

00:42:45,680 --> 00:42:46,720
accurate

00:42:46,720 --> 00:42:48,560
um they just have to be between a

00:42:48,560 --> 00:42:51,280
certain minimum and maximum value

00:42:51,280 --> 00:42:52,400
so um

00:42:52,400 --> 00:42:53,920
the minimum value

00:42:53,920 --> 00:42:55,520
you can set as the time for your block

00:42:55,520 --> 00:42:58,960
header is the median time of the last 11

00:42:58,960 --> 00:43:00,079
blocks

00:43:00,079 --> 00:43:03,359
or basically the the time set that's

00:43:03,359 --> 00:43:06,160
been the time of in the block header of

00:43:06,160 --> 00:43:08,800
the sixth block down

00:43:08,800 --> 00:43:10,800
so you can't have a time

00:43:10,800 --> 00:43:12,400
uh any lower than that

00:43:12,400 --> 00:43:14,000
that's the minimum bound

00:43:14,000 --> 00:43:15,599
and then the maximum

00:43:15,599 --> 00:43:17,839
um

00:43:17,839 --> 00:43:19,119
the maximum

00:43:19,119 --> 00:43:22,720
basically your node has its own time

00:43:22,720 --> 00:43:24,160
uh when you run it it just uses your

00:43:24,160 --> 00:43:26,000
computer's time and then when other

00:43:26,000 --> 00:43:28,000
nodes connect to you they will send you

00:43:28,000 --> 00:43:30,000
what their time is on their computer and

00:43:30,000 --> 00:43:31,760
so your node will keep track of the

00:43:31,760 --> 00:43:33,760
difference between

00:43:33,760 --> 00:43:35,119
all of the times of the nodes you're

00:43:35,119 --> 00:43:36,560
connected to

00:43:36,560 --> 00:43:38,560
and if you put them in order and you

00:43:38,560 --> 00:43:40,400
take the median time

00:43:40,400 --> 00:43:42,319
of all the nodes you're connected to

00:43:42,319 --> 00:43:44,319
um that's called the network average

00:43:44,319 --> 00:43:45,760
time

00:43:45,760 --> 00:43:47,280
so um

00:43:47,280 --> 00:43:50,079
the maximum value of this time is the

00:43:50,079 --> 00:43:53,680
network average time plus two hours

00:43:53,680 --> 00:43:55,520
so can you repeat this

00:43:55,520 --> 00:43:57,839
like quickly i mean i just got a little

00:43:57,839 --> 00:44:00,800
confused so why is this time used and uh

00:44:00,800 --> 00:44:02,480
is this the time to mine a block or

00:44:02,480 --> 00:44:04,480
something i mean uh no uh no this is

00:44:04,480 --> 00:44:07,280
this this time um i think this is i

00:44:07,280 --> 00:44:08,560
think this is quite a bit unnecessary

00:44:08,560 --> 00:44:11,200
necessary for me to explain um basically

00:44:11,200 --> 00:44:12,960
the time is just you just stick the

00:44:12,960 --> 00:44:14,960
current time of your computer um in the

00:44:14,960 --> 00:44:18,000
block header but it's but it's not um

00:44:18,000 --> 00:44:20,560
it doesn't have to be precise um

00:44:20,560 --> 00:44:23,200
it's not yeah so basically it just has

00:44:23,200 --> 00:44:25,760
to be between two certain values um as

00:44:25,760 --> 00:44:28,720
long as it's a greater than um the time

00:44:28,720 --> 00:44:29,599
of

00:44:29,599 --> 00:44:32,480
the sixth block down

00:44:32,480 --> 00:44:35,280
yeah or the meat of the median time of

00:44:35,280 --> 00:44:36,880
the last 11 blocks

00:44:36,880 --> 00:44:38,400
um it can't be any lower than that

00:44:38,400 --> 00:44:40,240
because if you were to put a time lower

00:44:40,240 --> 00:44:42,160
than that then it would get rejected by

00:44:42,160 --> 00:44:43,920
the nodes you send it to and also the

00:44:43,920 --> 00:44:45,760
maximum time is basically the current

00:44:45,760 --> 00:44:47,119
time

00:44:47,119 --> 00:44:49,280
plus two hours

00:44:49,280 --> 00:44:51,440
but it's we used

00:44:51,440 --> 00:44:53,920
um network average time is used which is

00:44:53,920 --> 00:44:56,000
just the average time

00:44:56,000 --> 00:44:57,359
of all the nodes that are connected to

00:44:57,359 --> 00:44:58,800
you

00:44:58,800 --> 00:44:59,680
um

00:44:59,680 --> 00:45:01,839
so don't worry about that um but it's

00:45:01,839 --> 00:45:03,599
basically all i'm saying is the time can

00:45:03,599 --> 00:45:04,640
be

00:45:04,640 --> 00:45:07,200
roughly an hour behind one or two hours

00:45:07,200 --> 00:45:08,079
ahead

00:45:08,079 --> 00:45:09,920
so it's not really if you see if a block

00:45:09,920 --> 00:45:12,079
comes comes through and it has a time

00:45:12,079 --> 00:45:13,359
like

00:45:13,359 --> 00:45:15,280
before or ahead of like a different

00:45:15,280 --> 00:45:16,240
block

00:45:16,240 --> 00:45:17,839
it doesn't really matter it has this

00:45:17,839 --> 00:45:20,240
sort of flexible sort of upper and lower

00:45:20,240 --> 00:45:22,240
boundary

00:45:22,240 --> 00:45:25,359
all right so that's the time um bits um

00:45:25,359 --> 00:45:27,440
bits remember the target

00:45:27,440 --> 00:45:29,599
bits is just a compact representation of

00:45:29,599 --> 00:45:30,800
the target

00:45:30,800 --> 00:45:33,359
so instead of putting the the current

00:45:33,359 --> 00:45:35,200
target um

00:45:35,200 --> 00:45:37,760
the entire target in the block header

00:45:37,760 --> 00:45:40,000
what you what you do

00:45:40,000 --> 00:45:42,880
is you just grab um the first three

00:45:42,880 --> 00:45:45,520
significant bytes or the first six you

00:45:45,520 --> 00:45:47,599
know significant characters after the

00:45:47,599 --> 00:45:49,680
leading zeros and then you put that

00:45:49,680 --> 00:45:50,560
there

00:45:50,560 --> 00:45:51,599
and then

00:45:51,599 --> 00:45:54,960
um you just grab the offset so how far

00:45:54,960 --> 00:45:55,760
these

00:45:55,760 --> 00:45:58,560
um three bytes are from the right

00:45:58,560 --> 00:46:00,880
uh and that is there are 26 bytes from

00:46:00,880 --> 00:46:02,240
the right here

00:46:02,240 --> 00:46:06,160
or in hexadecimal 26 is 1a

00:46:06,160 --> 00:46:08,640
so you just put that start there so bits

00:46:08,640 --> 00:46:10,800
is just this compact representation of

00:46:10,800 --> 00:46:13,280
the target

00:46:13,440 --> 00:46:15,040
um

00:46:15,040 --> 00:46:16,400
then that's it then then you just have

00:46:16,400 --> 00:46:18,800
the nonce and you can set that to zero

00:46:18,800 --> 00:46:22,400
and so this is all the basic data now um

00:46:22,400 --> 00:46:23,839
for the block header

00:46:23,839 --> 00:46:25,839
does that does it all these fields make

00:46:25,839 --> 00:46:28,720
sense each part okay good um so now

00:46:28,720 --> 00:46:30,160
we've got all the fields ready to be

00:46:30,160 --> 00:46:31,599
mined

00:46:31,599 --> 00:46:34,319
um we just have to get all the data into

00:46:34,319 --> 00:46:35,760
the correct format

00:46:35,760 --> 00:46:37,839
uh so this is just a bit of programming

00:46:37,839 --> 00:46:39,040
just to make sure everything's in the

00:46:39,040 --> 00:46:41,520
right order and format

00:46:41,520 --> 00:46:44,400
each field um should be in hexa put it

00:46:44,400 --> 00:46:46,640
all into hexadecimal

00:46:46,640 --> 00:46:47,680
so

00:46:47,680 --> 00:46:49,440
one is one in hexadecimal so this is

00:46:49,440 --> 00:46:51,040
going to change but you just go through

00:46:51,040 --> 00:46:52,560
every single field making sure that it's

00:46:52,560 --> 00:46:54,160
all hexadecimal so

00:46:54,160 --> 00:46:56,640
these two hexadecimal the time this is

00:46:56,640 --> 00:46:58,079
in decimal at the moment so we just

00:46:58,079 --> 00:47:00,079
convert that hex decimal and you do the

00:47:00,079 --> 00:47:02,800
same for every other field

00:47:02,800 --> 00:47:03,839
secondly

00:47:03,839 --> 00:47:05,359
each field

00:47:05,359 --> 00:47:07,040
must be a

00:47:07,040 --> 00:47:09,599
fixed number of bytes

00:47:09,599 --> 00:47:11,040
so there's only got one character in

00:47:11,040 --> 00:47:13,760
here but the version field is four bytes

00:47:13,760 --> 00:47:16,160
so if we convert that to four bytes it

00:47:16,160 --> 00:47:17,839
looks like this

00:47:17,839 --> 00:47:20,720
so one byte is two characters so zero

00:47:20,720 --> 00:47:23,119
zero that's one byte and there are four

00:47:23,119 --> 00:47:25,680
bytes in the version

00:47:25,680 --> 00:47:26,640
um

00:47:26,640 --> 00:47:27,680
then you just go through every single

00:47:27,680 --> 00:47:29,599
field giving it

00:47:29,599 --> 00:47:32,000
putting it into the correct um

00:47:32,000 --> 00:47:34,480
size so this is already 32 bytes that's

00:47:34,480 --> 00:47:36,319
already 32 bytes

00:47:36,319 --> 00:47:37,760
the time's gonna be four bytes it's

00:47:37,760 --> 00:47:40,400
already four bits same again four the

00:47:40,400 --> 00:47:42,640
nonce then that's four bytes as well

00:47:42,640 --> 00:47:45,119
so just for each field make sure that

00:47:45,119 --> 00:47:47,440
you've padded it out padded it out

00:47:47,440 --> 00:47:49,760
with the right number of bytes so this

00:47:49,760 --> 00:47:52,720
basically means that when a computer can

00:47:52,720 --> 00:47:54,079
read through each individual fields

00:47:54,079 --> 00:47:56,480
easily

00:47:56,960 --> 00:47:58,880
so that's all the

00:47:58,880 --> 00:48:00,640
data in the right

00:48:00,640 --> 00:48:03,359
format and the right field size

00:48:03,359 --> 00:48:05,280
lastly the only

00:48:05,280 --> 00:48:07,440
slightly frustrating thing with bitcoin

00:48:07,440 --> 00:48:10,160
is that when you send

00:48:10,160 --> 00:48:12,400
data to

00:48:12,400 --> 00:48:15,440
um the nodes um

00:48:15,440 --> 00:48:17,599
across the wire

00:48:17,599 --> 00:48:19,680
you have to send the data in reverse

00:48:19,680 --> 00:48:22,160
byte order which is called network byte

00:48:22,160 --> 00:48:23,200
order

00:48:23,200 --> 00:48:26,079
so um obviously we've got all this in

00:48:26,079 --> 00:48:29,200
human readable human human readable byte

00:48:29,200 --> 00:48:31,520
order but when you

00:48:31,520 --> 00:48:33,520
hash and work with bitcoin data it has

00:48:33,520 --> 00:48:35,680
to be in reverse byte order so you just

00:48:35,680 --> 00:48:37,200
go through every single field and put it

00:48:37,200 --> 00:48:39,440
into network byte order

00:48:39,440 --> 00:48:43,040
which is just reversing each byte

00:48:43,040 --> 00:48:45,599
so that's something that

00:48:45,599 --> 00:48:47,280
well they tripped me up when i first

00:48:47,280 --> 00:48:48,800
started mining i was like i was trying

00:48:48,800 --> 00:48:50,000
to hash these block headers and i was

00:48:50,000 --> 00:48:51,040
like why am i not getting the same

00:48:51,040 --> 00:48:52,800
results it's because

00:48:52,800 --> 00:48:54,559
you want to get everything in network

00:48:54,559 --> 00:48:56,240
byte order

00:48:56,240 --> 00:48:58,000
and just to show you i've made like a

00:48:58,000 --> 00:49:00,559
little quick um

00:49:00,559 --> 00:49:01,839
uh

00:49:01,839 --> 00:49:02,880
script

00:49:02,880 --> 00:49:06,480
so reverse bytes so if i put the

00:49:06,480 --> 00:49:08,160
a b c d e

00:49:08,160 --> 00:49:10,800
f one two three four

00:49:10,800 --> 00:49:13,200
let me see

00:49:13,839 --> 00:49:15,359
um the way that works is reverse byte

00:49:15,359 --> 00:49:17,520
order you just split it all into each

00:49:17,520 --> 00:49:19,839
individual byte so one byte is two

00:49:19,839 --> 00:49:23,200
characters and then you just um reverse

00:49:23,200 --> 00:49:24,720
the order of the bytes and that gives

00:49:24,720 --> 00:49:26,480
you that so that's how it works so

00:49:26,480 --> 00:49:28,480
you're not just reversing the string

00:49:28,480 --> 00:49:31,680
you are um reversing each byte

00:49:31,680 --> 00:49:34,800
so this might be a basic question but uh

00:49:34,800 --> 00:49:35,920
one

00:49:35,920 --> 00:49:38,720
so two characters is one byte yes yes

00:49:38,720 --> 00:49:40,400
yeah

00:49:40,400 --> 00:49:41,680
yep

00:49:41,680 --> 00:49:42,800
um

00:49:42,800 --> 00:49:45,200
that's just something i've learned

00:49:45,200 --> 00:49:47,359
uh

00:49:47,359 --> 00:49:51,520
i'm just looking at the c plus plus

00:49:51,520 --> 00:49:53,520
uh i've not done c plus plus in a long

00:49:53,520 --> 00:49:54,480
time

00:49:54,480 --> 00:49:59,520
so character type size is one byte um

00:50:01,599 --> 00:50:04,079
yeah no i i don't i don't know that much

00:50:04,079 --> 00:50:06,640
deep about computer science um but all i

00:50:06,640 --> 00:50:08,800
know is yeah

00:50:08,800 --> 00:50:10,880
i'm doing this more like a top down sort

00:50:10,880 --> 00:50:12,720
of level i i've just learned that um two

00:50:12,720 --> 00:50:15,359
characters translates as one byte so

00:50:15,359 --> 00:50:17,440
yeah

00:50:17,440 --> 00:50:19,599
um so there we are now we've got all the

00:50:19,599 --> 00:50:22,160
data finally in the right order um all

00:50:22,160 --> 00:50:23,839
you do then you just concatenate each

00:50:23,839 --> 00:50:26,559
individual field together like that so

00:50:26,559 --> 00:50:28,319
this is the block header

00:50:28,319 --> 00:50:30,559
now it's ready to put inside to put into

00:50:30,559 --> 00:50:32,240
the hash function

00:50:32,240 --> 00:50:35,440
um as i mentioned um sha-256 simple

00:50:35,440 --> 00:50:38,480
hashing algorithm 256

00:50:38,480 --> 00:50:39,520
is used

00:50:39,520 --> 00:50:41,839
um but in bitcoin everything gets hashed

00:50:41,839 --> 00:50:42,800
twice

00:50:42,800 --> 00:50:44,319
um

00:50:44,319 --> 00:50:46,400
it's just the way it was designed i

00:50:46,400 --> 00:50:48,240
don't think it provides any massive

00:50:48,240 --> 00:50:50,800
benefits it's just the way that

00:50:50,800 --> 00:50:52,640
bitcoin hashes things

00:50:52,640 --> 00:50:53,520
um

00:50:53,520 --> 00:50:55,760
so you just put this into hash function

00:50:55,760 --> 00:50:58,480
spits our result and then spits out then

00:50:58,480 --> 00:50:59,920
you hash the result to get you another

00:50:59,920 --> 00:51:01,359
result and that's the

00:51:01,359 --> 00:51:02,800
final hash

00:51:02,800 --> 00:51:05,520
um quick note um

00:51:05,520 --> 00:51:07,680
when when you hash things in bitcoin um

00:51:07,680 --> 00:51:10,000
this is in hexadecimal but you convert

00:51:10,000 --> 00:51:12,000
it into binary first so you put binary

00:51:12,000 --> 00:51:14,800
data into the hashing function

00:51:14,800 --> 00:51:15,920
and then

00:51:15,920 --> 00:51:17,520
that'll spit out a binding result then

00:51:17,520 --> 00:51:19,280
you put the binary result into the

00:51:19,280 --> 00:51:20,079
second

00:51:20,079 --> 00:51:21,440
hashing function

00:51:21,440 --> 00:51:24,880
that'll spit out a second binary digest

00:51:24,880 --> 00:51:27,839
and then when you convert that

00:51:27,839 --> 00:51:29,359
second digest

00:51:29,359 --> 00:51:31,200
back into hexadecimal

00:51:31,200 --> 00:51:33,040
that'll give you the

00:51:33,040 --> 00:51:35,119
um

00:51:35,119 --> 00:51:38,319
block hash but obviously this is in

00:51:38,319 --> 00:51:39,359
reverse

00:51:39,359 --> 00:51:41,680
uh network byte order again so if you

00:51:41,680 --> 00:51:42,880
reverse it

00:51:42,880 --> 00:51:45,760
then that's in the more human

00:51:45,760 --> 00:51:49,040
uh format so if you compare this

00:51:49,040 --> 00:51:50,559
to the target you want to make sure it's

00:51:50,559 --> 00:51:53,520
in you want to reverse it back into

00:51:53,520 --> 00:51:55,359
uh

00:51:55,359 --> 00:51:58,079
non-network byte order

00:51:58,079 --> 00:51:58,880
so

00:51:58,880 --> 00:52:01,359
so there we go um so this i've only

00:52:01,359 --> 00:52:03,119
covered these things because they just

00:52:03,119 --> 00:52:05,599
trip you up i mean get in the fields

00:52:05,599 --> 00:52:07,200
it's quite simple but then get anything

00:52:07,200 --> 00:52:08,960
into the right order then converting it

00:52:08,960 --> 00:52:11,040
to binary and then switching it back

00:52:11,040 --> 00:52:11,839
again

00:52:11,839 --> 00:52:14,240
um that's what'll trip you up if you're

00:52:14,240 --> 00:52:15,920
trying to minor block header or hash a

00:52:15,920 --> 00:52:18,240
block header for yourself

00:52:18,240 --> 00:52:20,640
all right so this was the block header

00:52:20,640 --> 00:52:23,760
on the left which already had the fields

00:52:23,760 --> 00:52:26,319
in reverse network order right

00:52:26,319 --> 00:52:28,240
uh yes yes

00:52:28,240 --> 00:52:30,400
okay then you

00:52:30,400 --> 00:52:31,359
uh

00:52:31,359 --> 00:52:34,319
do a double hash of that yeah and you

00:52:34,319 --> 00:52:36,720
convert it to hex and

00:52:36,720 --> 00:52:40,160
you converted that again in reverse

00:52:40,160 --> 00:52:43,599
i reversed it i reversed it back

00:52:44,000 --> 00:52:44,839
okay

00:52:44,839 --> 00:52:48,319
um yeah and this is how this is

00:52:48,319 --> 00:52:50,559
like if you mind the block this is the

00:52:50,559 --> 00:52:52,319
hash that you would send on to the

00:52:52,319 --> 00:52:54,880
network is that uh

00:52:54,880 --> 00:52:56,720
um let's say that you end up mining a

00:52:56,720 --> 00:52:58,880
block and let's say you get a nuance

00:52:58,880 --> 00:53:01,599
that is like below a target value yeah

00:53:01,599 --> 00:53:02,880
uh

00:53:02,880 --> 00:53:04,720
what do you do next yeah i mean okay i

00:53:04,720 --> 00:53:06,800
think i should cover that now i think um

00:53:06,800 --> 00:53:08,480
so okay um

00:53:08,480 --> 00:53:09,920
you don't actually send the block hash

00:53:09,920 --> 00:53:11,280
um you just send basically the block

00:53:11,280 --> 00:53:12,880
header and the transactions

00:53:12,880 --> 00:53:13,599
so

00:53:13,599 --> 00:53:15,440
okay but i'm just i don't think you have

00:53:15,440 --> 00:53:16,720
to if you're programming you wouldn't

00:53:16,720 --> 00:53:18,319
you might not have to reverse it this is

00:53:18,319 --> 00:53:19,599
just so i can

00:53:19,599 --> 00:53:23,040
display the results correctly uh in a

00:53:23,040 --> 00:53:24,720
sort of a human way

00:53:24,720 --> 00:53:27,359
so again so now like a minor you just

00:53:27,359 --> 00:53:29,520
change the nonce now i'm incrementing it

00:53:29,520 --> 00:53:30,240
from

00:53:30,240 --> 00:53:32,720
um zero one two three four five and so

00:53:32,720 --> 00:53:35,359
on so there you are obviously this is in

00:53:35,359 --> 00:53:36,880
network byte order

00:53:36,880 --> 00:53:40,319
and so on eventually you'll get a

00:53:40,319 --> 00:53:41,359
uh

00:53:41,359 --> 00:53:43,280
hash uh this below the target if you're

00:53:43,280 --> 00:53:44,160
lucky

00:53:44,160 --> 00:53:46,319
then that's mind so when you mind the

00:53:46,319 --> 00:53:47,839
actual block

00:53:47,839 --> 00:53:49,280
so this is done now so this is a

00:53:49,280 --> 00:53:51,280
successful block header

00:53:51,280 --> 00:53:52,000
so

00:53:52,000 --> 00:53:54,319
if you send this block header to anyone

00:53:54,319 --> 00:53:55,760
else they can hash it for themselves and

00:53:55,760 --> 00:53:57,200
they get the same result

00:53:57,200 --> 00:53:58,559
that's what i think that's what they

00:53:58,559 --> 00:54:00,400
call proof of work because you can just

00:54:00,400 --> 00:54:01,599
send this block header to anyone and

00:54:01,599 --> 00:54:03,440
they can prove for themselves that the

00:54:03,440 --> 00:54:05,359
hash is below the target so what you

00:54:05,359 --> 00:54:08,240
what you do then is you send this block

00:54:08,240 --> 00:54:10,480
uh to all the nodes you're connected to

00:54:10,480 --> 00:54:12,400
and what you're actually sending them is

00:54:12,400 --> 00:54:14,480
all of the transaction data concatenated

00:54:14,480 --> 00:54:16,480
together for each transaction

00:54:16,480 --> 00:54:17,440
um

00:54:17,440 --> 00:54:18,880
before that you put like a little

00:54:18,880 --> 00:54:20,559
transaction counter

00:54:20,559 --> 00:54:22,559
which is just a byte

00:54:22,559 --> 00:54:25,200
it's a it's a very very variable sized

00:54:25,200 --> 00:54:26,960
byte i haven't covered it but it's on

00:54:26,960 --> 00:54:28,720
the website um

00:54:28,720 --> 00:54:30,079
just tells you how many transactions are

00:54:30,079 --> 00:54:31,839
in the block and then before that you

00:54:31,839 --> 00:54:33,520
have the block header so this is what

00:54:33,520 --> 00:54:35,359
gets sent to

00:54:35,359 --> 00:54:37,599
um all the nodes so you don't have to

00:54:37,599 --> 00:54:38,480
send the

00:54:38,480 --> 00:54:39,839
block hash because they can calculate it

00:54:39,839 --> 00:54:42,400
for themselves

00:54:43,119 --> 00:54:44,800
so um

00:54:44,800 --> 00:54:47,599
that's how mining works um what i

00:54:47,599 --> 00:54:50,079
thought i would do now is um try and

00:54:50,079 --> 00:54:53,200
show you how you could uh

00:54:53,200 --> 00:54:56,800
mine a actual live block

00:54:56,800 --> 00:54:58,160
so yeah

00:54:58,160 --> 00:55:01,359
right so um if you run a bitcoin node

00:55:01,359 --> 00:55:05,040
um you have the um bitcoin cli um

00:55:05,040 --> 00:55:06,880
command which allows you to ask the

00:55:06,880 --> 00:55:08,640
bitcoin no questions and one of them you

00:55:08,640 --> 00:55:12,480
can ask them is to get block template

00:55:12,480 --> 00:55:14,559
so what that will do that will take your

00:55:14,559 --> 00:55:16,800
current memory pool and

00:55:16,800 --> 00:55:20,240
gather the highest value transactions

00:55:20,240 --> 00:55:21,839
that would fill up a

00:55:21,839 --> 00:55:22,720
block

00:55:22,720 --> 00:55:24,960
and

00:55:25,119 --> 00:55:27,680
give them to you so this is showing me

00:55:27,680 --> 00:55:29,119
all of the transactions that would make

00:55:29,119 --> 00:55:30,400
a

00:55:30,400 --> 00:55:32,319
candidate block

00:55:32,319 --> 00:55:37,520
so um let me just move this down sorry

00:55:38,000 --> 00:55:38,880
um

00:55:38,880 --> 00:55:40,720
so

00:55:40,720 --> 00:55:44,079
uh if we to if i just quickly examine um

00:55:44,079 --> 00:55:45,359
the information

00:55:45,359 --> 00:55:48,079
inside here if you if you um use bitcoin

00:55:48,079 --> 00:55:50,640
cli help get block template that will

00:55:50,640 --> 00:55:52,640
show you um all the fields that will

00:55:52,640 --> 00:55:55,119
give you all the fields they'll produce

00:55:55,119 --> 00:55:57,920
um but if i just quickly

00:55:57,920 --> 00:55:59,520
um

00:55:59,520 --> 00:56:02,319
what we want to see basically to minor

00:56:02,319 --> 00:56:04,319
block is to create a block header from

00:56:04,319 --> 00:56:06,240
all these transactions

00:56:06,240 --> 00:56:09,680
so bitcoin cli get block template

00:56:09,680 --> 00:56:11,520
and i'm going to use um

00:56:11,520 --> 00:56:14,319
grep just to search for the fields that

00:56:14,319 --> 00:56:15,680
we want

00:56:15,680 --> 00:56:19,200
i'm using rg which is a variant of grep

00:56:19,200 --> 00:56:21,760
and so we want to find we want to have a

00:56:21,760 --> 00:56:22,720
version

00:56:22,720 --> 00:56:24,160
number

00:56:24,160 --> 00:56:27,599
we want the previous block

00:56:27,920 --> 00:56:30,480
then we want the merkle root

00:56:30,480 --> 00:56:31,359
um

00:56:31,359 --> 00:56:32,559
then we want

00:56:32,559 --> 00:56:33,440
time

00:56:33,440 --> 00:56:34,799
then bits

00:56:34,799 --> 00:56:36,400
then there's a nonce but

00:56:36,400 --> 00:56:37,920
we're going to provide our own nuns so

00:56:37,920 --> 00:56:39,440
we don't need that

00:56:39,440 --> 00:56:41,359
so looking at the

00:56:41,359 --> 00:56:45,000
i spelt that wrong

00:56:45,200 --> 00:56:47,520
there we are so

00:56:47,520 --> 00:56:49,280
looking at the results of block get

00:56:49,280 --> 00:56:51,200
block template it's given us the version

00:56:51,200 --> 00:56:52,960
the previous block hash it's also giving

00:56:52,960 --> 00:56:56,160
us the time current time and bits

00:56:56,160 --> 00:56:58,480
so it's changing the current time

00:56:58,480 --> 00:57:00,000
so what it's not giving us is a miracle

00:57:00,000 --> 00:57:01,440
root

00:57:01,440 --> 00:57:02,880
um

00:57:02,880 --> 00:57:05,520
for some i don't know why it's not um

00:57:05,520 --> 00:57:07,440
but what you can do

00:57:07,440 --> 00:57:12,160
um what it is giving you is um

00:57:12,160 --> 00:57:13,520
this is just a

00:57:13,520 --> 00:57:15,440
json parser

00:57:15,440 --> 00:57:17,520
it has given you um

00:57:17,520 --> 00:57:19,440
a list of

00:57:19,440 --> 00:57:20,799
transactions

00:57:20,799 --> 00:57:22,400
and it has given you all the transaction

00:57:22,400 --> 00:57:25,040
ids so if we just go through each one

00:57:25,040 --> 00:57:27,040
and say give us

00:57:27,040 --> 00:57:29,599
the transaction ids

00:57:29,599 --> 00:57:33,920
now let's need to put that in quotes

00:57:36,240 --> 00:57:37,599
there we are so these are all the

00:57:37,599 --> 00:57:39,680
transaction ids

00:57:39,680 --> 00:57:41,760
in this candidate block

00:57:41,760 --> 00:57:43,200
so now we've got all those transaction

00:57:43,200 --> 00:57:44,400
ids we just need to create our own

00:57:44,400 --> 00:57:46,480
merkle route for them

00:57:46,480 --> 00:57:47,200
so

00:57:47,200 --> 00:57:49,839
um luckily i've written my own script

00:57:49,839 --> 00:57:51,760
and that will take in a list of

00:57:51,760 --> 00:57:53,599
transactions and create a miracle route

00:57:53,599 --> 00:57:55,359
from them

00:57:55,359 --> 00:57:56,960
um i've made this available on the

00:57:56,960 --> 00:57:58,960
website i'll show it in the moment

00:57:58,960 --> 00:58:00,720
so if i just do that

00:58:00,720 --> 00:58:02,880
then we have a miracle root

00:58:02,880 --> 00:58:05,839
so now um we've got all the data we need

00:58:05,839 --> 00:58:07,280
to mine a

00:58:07,280 --> 00:58:08,799
both or basically to construct a block

00:58:08,799 --> 00:58:10,640
header

00:58:10,640 --> 00:58:12,480
so if you just bare with me for five

00:58:12,480 --> 00:58:14,400
minutes i'm gonna go through each field

00:58:14,400 --> 00:58:16,079
and um

00:58:16,079 --> 00:58:18,720
yeah so first of all uh we need to get

00:58:18,720 --> 00:58:20,640
the version

00:58:20,640 --> 00:58:23,119
oh that's done wrong

00:58:23,119 --> 00:58:25,200
okay

00:58:25,200 --> 00:58:27,440
so there we are using get a get block

00:58:27,440 --> 00:58:29,119
template this is the current version uh

00:58:29,119 --> 00:58:32,079
like i said they've changed a bit so um

00:58:32,079 --> 00:58:33,040
this is

00:58:33,040 --> 00:58:34,640
they've been used to vote for voting so

00:58:34,640 --> 00:58:36,960
this is why it's a very high number but

00:58:36,960 --> 00:58:38,160
i'm not going to spend it now just take

00:58:38,160 --> 00:58:39,680
it as it is

00:58:39,680 --> 00:58:40,480
um

00:58:40,480 --> 00:58:41,920
so this is the version number but

00:58:41,920 --> 00:58:44,559
obviously it's in uh decimal so to

00:58:44,559 --> 00:58:46,240
convert that into

00:58:46,240 --> 00:58:49,440
hexadecimal first first so there we are

00:58:49,440 --> 00:58:50,400
and then

00:58:50,400 --> 00:58:52,480
now it's in hexadecimal this is already

00:58:52,480 --> 00:58:54,559
um four bytes

00:58:54,559 --> 00:58:57,119
so i just swap the byte order or swap

00:58:57,119 --> 00:58:59,920
the endianness because sometimes

00:58:59,920 --> 00:59:01,280
um

00:59:01,280 --> 00:59:03,119
the byte order is referred to referred

00:59:03,119 --> 00:59:05,359
to as endianness

00:59:05,359 --> 00:59:06,720
um

00:59:06,720 --> 00:59:09,359
so there we are so this is the

00:59:09,359 --> 00:59:10,160
uh

00:59:10,160 --> 00:59:12,480
version all set up and ready to go so

00:59:12,480 --> 00:59:13,599
i'll just

00:59:13,599 --> 00:59:15,119
trim the end off that

00:59:15,119 --> 00:59:16,640
because i'm going to concatenate it all

00:59:16,640 --> 00:59:20,160
together so if i save this as a

00:59:20,160 --> 00:59:22,640
variable

00:59:25,680 --> 00:59:26,880
there we have so just

00:59:26,880 --> 00:59:29,359
echo that out to check

00:59:29,359 --> 00:59:31,520
so that's the version done so next up

00:59:31,520 --> 00:59:33,839
after the version is the

00:59:33,839 --> 00:59:37,520
version previous block

00:59:37,599 --> 00:59:39,599
so previous block

00:59:39,599 --> 00:59:40,799
hash

00:59:40,799 --> 00:59:42,559
so this is the block hash for the

00:59:42,559 --> 00:59:44,559
previous block

00:59:44,559 --> 00:59:47,119
let me just trim off the

00:59:47,119 --> 00:59:49,520
uh quotes

00:59:49,520 --> 00:59:51,040
and then

00:59:51,040 --> 00:59:52,640
uh it's already in hex decimal it's

00:59:52,640 --> 00:59:55,440
already 32 bytes so what i need to do is

00:59:55,440 --> 00:59:57,680
sort the byte order or put it into

00:59:57,680 --> 00:59:59,040
little endian

00:59:59,040 --> 01:00:01,760
so there we are and then i can save this

01:00:01,760 --> 01:00:03,599
then

01:00:03,599 --> 01:00:07,200
as the previous block variable

01:00:11,119 --> 01:00:15,040
next up then is the miracle root

01:00:15,040 --> 01:00:16,000
uh

01:00:16,000 --> 01:00:18,400
obviously we don't get a miracle root

01:00:18,400 --> 01:00:21,359
um from the get block template um

01:00:21,359 --> 01:00:23,839
command but what does give us is the

01:00:23,839 --> 01:00:25,440
list of transactions

01:00:25,440 --> 01:00:28,559
and for each of those it will give us um

01:00:28,559 --> 01:00:30,480
a transaction id

01:00:30,480 --> 01:00:31,440
oops

01:00:31,440 --> 01:00:33,599
oh well i just lost that

01:00:33,599 --> 01:00:35,280
oh there it is

01:00:35,280 --> 01:00:37,440
so there we go

01:00:37,440 --> 01:00:41,760
and from these i can get the merkle root

01:00:41,760 --> 01:00:44,000
there we are and then it's already in

01:00:44,000 --> 01:00:46,079
hexadecimal it's already in

01:00:46,079 --> 01:00:48,079
32 bytes i just need to sort the byte

01:00:48,079 --> 01:00:49,599
order

01:00:49,599 --> 01:00:50,960
again

01:00:50,960 --> 01:00:52,960
uh there we are i'll save that as a

01:00:52,960 --> 01:00:54,240
variable

01:00:54,240 --> 01:00:56,799
i'm going to call

01:00:58,640 --> 01:01:00,559
nearly there i know it's a bit laborious

01:01:00,559 --> 01:01:03,680
but uh so that's yeah so version

01:01:03,680 --> 01:01:05,920
previous block miracle root uh then we

01:01:05,920 --> 01:01:07,040
have the time

01:01:07,040 --> 01:01:08,839
um for some reason

01:01:08,839 --> 01:01:10,480
um

01:01:10,480 --> 01:01:12,640
even though the get plot template

01:01:12,640 --> 01:01:14,000
doesn't give you the merkel route it

01:01:14,000 --> 01:01:15,119
does give you

01:01:15,119 --> 01:01:17,520
the current time on your computer

01:01:17,520 --> 01:01:19,280
um

01:01:19,280 --> 01:01:21,200
actually it gives you a

01:01:21,200 --> 01:01:24,880
valid time i'm not sure if this is um

01:01:24,880 --> 01:01:25,839
i don't know but this is definitely a

01:01:25,839 --> 01:01:27,760
valid time but what you could do if you

01:01:27,760 --> 01:01:29,440
want to use that if you want to use the

01:01:29,440 --> 01:01:30,480
get blocked

01:01:30,480 --> 01:01:32,079
template time you can use the date

01:01:32,079 --> 01:01:34,400
function from a programming language

01:01:34,400 --> 01:01:36,240
so if you just this gives you the number

01:01:36,240 --> 01:01:37,599
of seconds

01:01:37,599 --> 01:01:39,680
in unix times if i just use that

01:01:39,680 --> 01:01:42,799
um just need to get it into hexadecimal

01:01:42,799 --> 01:01:44,000
like so

01:01:44,000 --> 01:01:46,720
one two three four five six seven so 24

01:01:46,720 --> 01:01:47,920
bytes

01:01:47,920 --> 01:01:48,799
uh

01:01:48,799 --> 01:01:51,960
then we

01:01:52,079 --> 01:01:53,599
it to and

01:01:53,599 --> 01:01:56,319
uh reverse bite order

01:01:56,319 --> 01:01:58,160
there we are so there is that's the time

01:01:58,160 --> 01:01:59,040
ready

01:01:59,040 --> 01:02:00,799
enough

01:02:00,799 --> 01:02:02,240
and

01:02:02,240 --> 01:02:04,480
that's the time done

01:02:04,480 --> 01:02:07,440
lastly uh bits

01:02:07,440 --> 01:02:09,119
which is the compact version of the

01:02:09,119 --> 01:02:11,359
target

01:02:11,359 --> 01:02:14,079
there it is you just trim off the

01:02:14,079 --> 01:02:16,240
uh

01:02:16,960 --> 01:02:18,079
quotes

01:02:18,079 --> 01:02:21,839
and then put into reverse byte order

01:02:22,400 --> 01:02:24,720
and there it is so now we've got all the

01:02:24,720 --> 01:02:28,160
basic block header data

01:02:28,160 --> 01:02:29,200
uh

01:02:29,200 --> 01:02:31,599
ready

01:02:32,160 --> 01:02:36,160
in the right format so if i

01:02:36,160 --> 01:02:38,240
just construct the block header from

01:02:38,240 --> 01:02:39,839
each individ each of those individual

01:02:39,839 --> 01:02:40,960
fields

01:02:40,960 --> 01:02:43,359
that is the version

01:02:43,359 --> 01:02:46,799
the previous block

01:02:46,839 --> 01:02:50,400
the miracle root

01:02:50,400 --> 01:02:52,000
then

01:02:52,000 --> 01:02:53,119
time

01:02:53,119 --> 01:02:55,280
and then bits

01:02:55,280 --> 01:02:58,640
so check what that looks like

01:02:58,960 --> 01:03:00,640
there it is there's our block header and

01:03:00,640 --> 01:03:02,480
so all we have all we haven't put there

01:03:02,480 --> 01:03:04,160
now is the nonce

01:03:04,160 --> 01:03:05,040
so

01:03:05,040 --> 01:03:06,960
if we wanted to

01:03:06,960 --> 01:03:08,960
mine this we just need to create a loop

01:03:08,960 --> 01:03:10,079
that will

01:03:10,079 --> 01:03:12,400
keep hashing this

01:03:12,400 --> 01:03:13,280
uh

01:03:13,280 --> 01:03:15,520
block header and we'll adjust the nonce

01:03:15,520 --> 01:03:17,599
increment it with every attempt

01:03:17,599 --> 01:03:20,480
so the nonce um will look like we'll

01:03:20,480 --> 01:03:22,640
start off with zero

01:03:22,640 --> 01:03:24,000
um but obviously we need to get this in

01:03:24,000 --> 01:03:25,920
the right format um so we need to

01:03:25,920 --> 01:03:28,839
convert that to um

01:03:28,839 --> 01:03:30,960
uh extradition

01:03:30,960 --> 01:03:32,240
sorry thank you

01:03:32,240 --> 01:03:36,319
uh then at least so like so

01:03:37,119 --> 01:03:38,880
uh but obviously this needs to be um

01:03:38,880 --> 01:03:40,640
four bytes in length so i made a little

01:03:40,640 --> 01:03:42,000
function that will just make sure it's

01:03:42,000 --> 01:03:43,359
the right size

01:03:43,359 --> 01:03:45,280
and then convert the swap end in

01:03:45,280 --> 01:03:46,720
obviously it's not very interesting

01:03:46,720 --> 01:03:48,559
because i've used the number zero but if

01:03:48,559 --> 01:03:50,000
i wish to use like a much higher nonce

01:03:50,000 --> 01:03:50,960
value

01:03:50,960 --> 01:03:52,559
uh like that

01:03:52,559 --> 01:03:55,039
then like so it's prepared it for me

01:03:55,039 --> 01:03:56,319
so i'm not going to append this to it

01:03:56,319 --> 01:03:57,440
yet what i'm going to do i'm going to

01:03:57,440 --> 01:04:00,640
create a loop so while true

01:04:00,640 --> 01:04:02,000
do

01:04:02,000 --> 01:04:03,760
you want to

01:04:03,760 --> 01:04:05,440
oh wait there before that i want to set

01:04:05,440 --> 01:04:08,400
a variable to

01:04:08,400 --> 01:04:11,680
an increment incremented variable ready

01:04:11,680 --> 01:04:14,559
so while true

01:04:14,559 --> 01:04:15,599
uh

01:04:15,599 --> 01:04:16,960
do

01:04:16,960 --> 01:04:18,079
want to

01:04:18,079 --> 01:04:19,760
create the nonce

01:04:19,760 --> 01:04:21,839
which is going to be like i just showed

01:04:21,839 --> 01:04:23,280
you um

01:04:23,280 --> 01:04:25,039
echo

01:04:25,039 --> 01:04:26,400
i

01:04:26,400 --> 01:04:28,960
uh they want to get it in deck

01:04:28,960 --> 01:04:31,039
hex decimal

01:04:31,039 --> 01:04:34,559
four byte field size swap endian

01:04:34,559 --> 01:04:35,359
uh

01:04:35,359 --> 01:04:37,760
trim off the end

01:04:37,760 --> 01:04:39,440
uh so that's the non stun

01:04:39,440 --> 01:04:42,319
then our attempt at

01:04:42,319 --> 01:04:44,319
trying to mine the block will be just

01:04:44,319 --> 01:04:45,280
the

01:04:45,280 --> 01:04:48,000
uh block header we created

01:04:48,000 --> 01:04:51,039
plus the nonce at the end

01:04:51,039 --> 01:04:52,160
and then what we want to do is we want

01:04:52,160 --> 01:04:53,440
to hash that

01:04:53,440 --> 01:04:55,039
um all together so i've made a little

01:04:55,039 --> 01:04:57,760
function that will hash for me um

01:04:57,760 --> 01:05:00,319
called hash 256 because this

01:05:00,319 --> 01:05:02,480
is just the the double hash converts the

01:05:02,480 --> 01:05:04,480
binary then double hashes it i'm going

01:05:04,480 --> 01:05:08,960
to hash 256 um the attempt

01:05:08,960 --> 01:05:09,839
and

01:05:09,839 --> 01:05:12,400
every after every attempt we want to

01:05:12,400 --> 01:05:15,920
uh increment the nonce so let

01:05:15,920 --> 01:05:18,559
uh i must plus so just increment the

01:05:18,559 --> 01:05:20,559
notes from

01:05:20,559 --> 01:05:21,680
this

01:05:21,680 --> 01:05:23,760
number here actually

01:05:23,760 --> 01:05:25,599
uh and then done so hopefully this will

01:05:25,599 --> 01:05:27,920
work there we are so now

01:05:27,920 --> 01:05:30,240
this is hashing

01:05:30,240 --> 01:05:31,200
um

01:05:31,200 --> 01:05:33,839
very slowly uh a block header the

01:05:33,839 --> 01:05:36,000
current block header obviously it's very

01:05:36,000 --> 01:05:37,680
slow it took me a long time but this is

01:05:37,680 --> 01:05:40,559
actually mine trying to mine a block

01:05:40,559 --> 01:05:42,319
um

01:05:42,319 --> 01:05:44,000
so if that was

01:05:44,000 --> 01:05:44,960
lucky

01:05:44,960 --> 01:05:46,400
what you'd probably do you'd have some

01:05:46,400 --> 01:05:48,480
code in there that would stop

01:05:48,480 --> 01:05:51,119
um when you if yeah if it reaches the

01:05:51,119 --> 01:05:52,799
target target yeah and then what you do

01:05:52,799 --> 01:05:55,839
then there's a function and bitcoin cli

01:05:55,839 --> 01:05:59,280
called um submit block

01:05:59,520 --> 01:06:01,760
and you would just submit

01:06:01,760 --> 01:06:05,839
the header the transaction count

01:06:06,400 --> 01:06:08,960
and all the transaction data so if you

01:06:08,960 --> 01:06:10,799
constructed a successful block header

01:06:10,799 --> 01:06:12,000
you would send that to all the nodes

01:06:12,000 --> 01:06:13,760
you're connected to and you'd use that

01:06:13,760 --> 01:06:15,280
do that using the

01:06:15,280 --> 01:06:17,280
submit block um

01:06:17,280 --> 01:06:19,599
bitcoin cli command

01:06:19,599 --> 01:06:21,839
is there a way to uh get the target

01:06:21,839 --> 01:06:24,559
value from the bitcoin cli

01:06:24,559 --> 01:06:27,039
uh yeah so um i think it's included in

01:06:27,039 --> 01:06:31,680
um bitcoin cli get block template

01:06:31,680 --> 01:06:35,119
yeah so um i think it's it's

01:06:35,119 --> 01:06:36,480
extending the block

01:06:36,480 --> 01:06:37,520
yeah so there it is so this is the

01:06:37,520 --> 01:06:39,599
current target so you could grab that

01:06:39,599 --> 01:06:42,160
target and then stick that summer into

01:06:42,160 --> 01:06:44,079
yeah into the for loop

01:06:44,079 --> 01:06:46,480
yeah but obviously um

01:06:46,480 --> 01:06:48,400
that that hashing there was very very

01:06:48,400 --> 01:06:49,200
slow

01:06:49,200 --> 01:06:51,599
oh yeah yeah i i totally get it yeah you

01:06:51,599 --> 01:06:53,200
probably want to do that yeah

01:06:53,200 --> 01:06:55,039
in a single programming language this is

01:06:55,039 --> 01:06:57,280
just on bash just for quick sort of

01:06:57,280 --> 01:06:58,960
illustration purposes but that just goes

01:06:58,960 --> 01:07:01,520
to show like how basically how simple uh

01:07:01,520 --> 01:07:03,599
mining is really the hardest part is

01:07:03,599 --> 01:07:05,520
just getting the data in the right order

01:07:05,520 --> 01:07:07,440
um but after that it's just you just

01:07:07,440 --> 01:07:09,680
increment a nonsense hash it and

01:07:09,680 --> 01:07:11,119
hopefully you get a result a lucky

01:07:11,119 --> 01:07:14,119
result

01:07:14,319 --> 01:07:15,760
um

01:07:15,760 --> 01:07:18,480
i think yeah so that's everything i

01:07:18,480 --> 01:07:21,039
wanted to explain about how mining works

01:07:21,039 --> 01:07:22,480
um

01:07:22,480 --> 01:07:23,839
that's all the technical stuff but

01:07:23,839 --> 01:07:25,119
obviously is

01:07:25,119 --> 01:07:27,440
probably a lot simpler than it's made

01:07:27,440 --> 01:07:29,760
out to be

01:07:29,760 --> 01:07:30,559
um

01:07:30,559 --> 01:07:32,400
on the website i've made all this code

01:07:32,400 --> 01:07:35,119
available so each those little um hex

01:07:35,119 --> 01:07:36,640
decimal converters and decimal

01:07:36,640 --> 01:07:37,760
converters

01:07:37,760 --> 01:07:40,960
and the swap endianness they're all here

01:07:40,960 --> 01:07:42,559
there's a miracle root function on here

01:07:42,559 --> 01:07:44,240
written in php

01:07:44,240 --> 01:07:46,960
um it's not the prettiest um but it will

01:07:46,960 --> 01:07:48,160
take a

01:07:48,160 --> 01:07:49,200
list of

01:07:49,200 --> 01:07:50,880
transaction ids and create american

01:07:50,880 --> 01:07:52,400
route for you

01:07:52,400 --> 01:07:54,400
i might not want to use it in production

01:07:54,400 --> 01:07:55,599
you might want to use a different

01:07:55,599 --> 01:07:57,760
library i'm sure there's loads of

01:07:57,760 --> 01:07:59,039
bitcoin libraries out there with their

01:07:59,039 --> 01:08:01,520
own merkle root um functions for you to

01:08:01,520 --> 01:08:03,760
use

01:08:04,559 --> 01:08:05,760
um

01:08:05,760 --> 01:08:07,760
is there any questions about

01:08:07,760 --> 01:08:09,920
that sort of mining process no i mean

01:08:09,920 --> 01:08:11,520
this this was really awesome great

01:08:11,520 --> 01:08:13,200
thanks a lot

01:08:13,200 --> 01:08:15,359
uh

01:08:16,000 --> 01:08:18,479
just curious any any experience with

01:08:18,479 --> 01:08:21,198
those heavy duty miners

01:08:21,198 --> 01:08:23,198
no i've not actually mined myself

01:08:23,198 --> 01:08:25,359
because like we said like it's so

01:08:25,359 --> 01:08:27,120
inefficient to mine on your laptop if

01:08:27,120 --> 01:08:28,960
you wanted to mine now it's not a hobby

01:08:28,960 --> 01:08:30,399
thing you have to sort of

01:08:30,399 --> 01:08:33,120
you know buy a professional mining rig

01:08:33,120 --> 01:08:34,640
and run it like a proper business which

01:08:34,640 --> 01:08:37,040
is a shame because that takes mining out

01:08:37,040 --> 01:08:38,880
of the hands of the average person then

01:08:38,880 --> 01:08:40,560
so

01:08:40,560 --> 01:08:41,920
um

01:08:41,920 --> 01:08:43,359
yeah so i think if you want to get into

01:08:43,359 --> 01:08:44,880
mind you you would have to really commit

01:08:44,880 --> 01:08:46,319
to it

01:08:46,319 --> 01:08:48,238
it's not just right gone yeah right

01:08:48,238 --> 01:08:50,080
right even those guys would be doing

01:08:50,080 --> 01:08:51,759
like at a fundamental level they would

01:08:51,759 --> 01:08:53,759
be doing the same thing right just

01:08:53,759 --> 01:08:54,799
faster

01:08:54,799 --> 01:08:56,158
yes so they're just doing the exact same

01:08:56,158 --> 01:08:57,600
thing constructing block header and just

01:08:57,600 --> 01:08:58,960
hashing it as fast as you can like this

01:08:58,960 --> 01:09:00,560
whole construction of the block header

01:09:00,560 --> 01:09:02,880
is simple and takes a

01:09:02,880 --> 01:09:05,359
absolute fraction of a second to do and

01:09:05,359 --> 01:09:08,080
then the whole mining then the whole

01:09:08,080 --> 01:09:10,080
meat of mining is hashing as fast as

01:09:10,080 --> 01:09:12,400
possible

01:09:13,600 --> 01:09:14,000
um

01:09:14,000 --> 01:09:15,359
[Music]

01:09:15,359 --> 01:09:16,640
i think i've

01:09:16,640 --> 01:09:18,238
don't think i've missed anything i think

01:09:18,238 --> 01:09:19,839
i've covered everything i wanted to

01:09:19,839 --> 01:09:21,759
sorry i know that's a bit repetitive in

01:09:21,759 --> 01:09:24,960
parts uh no no no this was a great

01:09:24,960 --> 01:09:26,960
explanation again yeah thanks a lot for

01:09:26,960 --> 01:09:28,000
this yeah

01:09:28,000 --> 01:09:29,600
but i think if you're starting out with

01:09:29,600 --> 01:09:31,679
bitcoin um

01:09:31,679 --> 01:09:33,279
one of the best ways to learn i think is

01:09:33,279 --> 01:09:34,880
to try and

01:09:34,880 --> 01:09:36,479
mine your own block header i think it's

01:09:36,479 --> 01:09:38,158
quite simple to do and i think mining is

01:09:38,158 --> 01:09:40,000
one of the sort of first fundamental

01:09:40,000 --> 01:09:41,839
parts of how bitcoin works so if you can

01:09:41,839 --> 01:09:44,479
figure out how to mine a block header

01:09:44,479 --> 01:09:46,158
or hash a block header that's a great

01:09:46,158 --> 01:09:47,839
stepping stone i'll give you the tools

01:09:47,839 --> 01:09:50,158
then to figure out about the all the um

01:09:50,158 --> 01:09:52,960
hexadecimal and network byte order and

01:09:52,960 --> 01:09:54,960
how to hash and then you can take those

01:09:54,960 --> 01:09:56,560
tools then and use them in other parts

01:09:56,560 --> 01:09:58,000
of bitcoin like in you know with

01:09:58,000 --> 01:10:01,040
transactions and all that

01:10:01,040 --> 01:10:02,719
so this would be my first place to start

01:10:02,719 --> 01:10:04,960
if you were to try coding with

01:10:04,960 --> 01:10:06,000
bitcoin

01:10:06,000 --> 01:10:07,600
i mean you you're obviously probably not

01:10:07,600 --> 01:10:08,560
going to

01:10:08,560 --> 01:10:10,560
set up your minor but as a sort of

01:10:10,560 --> 01:10:11,679
learning experience this is a great

01:10:11,679 --> 01:10:14,320
place to start

01:10:15,280 --> 01:10:17,199
so yeah if you want to browse block

01:10:17,199 --> 01:10:18,880
headers just go into livia bitcoin this

01:10:18,880 --> 01:10:20,560
is the blockchain

01:10:20,560 --> 01:10:21,920
and you can browse to each individual

01:10:21,920 --> 01:10:23,600
block and see all the different block

01:10:23,600 --> 01:10:25,520
headers and test for yourself

01:10:25,520 --> 01:10:27,520
then you can get the same

01:10:27,520 --> 01:10:28,960
block cache results

01:10:28,960 --> 01:10:31,280
nice

01:10:31,280 --> 01:10:32,400
yep

01:10:32,400 --> 01:10:35,280
so uh thank you very much for that uh

01:10:35,280 --> 01:10:37,120
that was good to do

01:10:37,120 --> 01:10:38,320
thanks

01:10:38,320 --> 01:10:42,520
no worries so yeah