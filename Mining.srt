00:00:00,640 --> 00:00:01,520
那么，

00:00:01,520 --> 00:00:02,720
在这个演示中，

00:00:02,720 -->  00:00:06,720
我将介绍比特币挖矿是如何工作的。

00:00:06,720 --> 00:00:08,480
我将从什么是挖矿开始，

00:00:08,480 --> 00:00:11,200
然后解释它是什么以及为什么存在。

00:00:11,200 --> 00:00:12,240
然后，

00:00:12,240 --> 00:00:14,559
我将介绍它是如何工作的。

00:00:14,559 --> 00:00:16,640
但在我解释它是如何工作的之前，

00:00:16,640 --> 00:00:19,119
我需要解释什么是哈希函数，

00:00:19,119 --> 00:00:23,279
因为这是比特币工作的一个重要部分。

00:00:23,279 --> 00:00:25,119
我会先介绍它的基本工作原理，

00:00:25,119 --> 00:00:28,480
然后我将再次介绍它，

00:00:27,199 --> 00:00:30,240
我将以更专业的方式来解释。

00:00:30,240 --> 00:00:31,599
所以，

00:00:31,599 --> 00:00:33,360
如果你是一个程序员，

00:00:33,360 --> 00:00:35,120
你会发现这更有趣。

00:00:35,120 --> 00:00:37,280
我将开始做一些例子，

00:00:37,280 --> 00:00:43,200
并尝试向你展示如何在非常少的代码中实际挖掘一个实时块。

00:00:43,200 --> 00:00:47,440
那么，什么是挖矿?

00:00:47,440 --> 00:00:53,120
假设这是比特币网络，

00:00:51,680 --> 00:00:53,120
这些都是连接在一起运行比特币程序的计算机，

00:00:53,120 --> 00:00:59,039
这些都是连接在一起运行比特币程序的计算机，

00:00:59,039 --> 00:01:01,840
共享同一个文件，

00:01:01,840 --> 00:01:04,000
即区块链。

00:01:04,000 --> 00:01:06,400
比特币的工作方式是，

00:01:06,400 --> 00:01:09,040
如果你想向某人发送比特币，

00:01:09,040 --> 00:01:13,040
或者将比特币的所有权转让给别人，

00:01:13,040 --> 00:01:14,320
你需要创建一个交易，

00:01:14,320 --> 00:01:17,280
这只是一行数据，

00:01:17,280 --> 00:01:23,840
然后你将其插入到网络上的一个节点中。

00:01:23,840 --> 00:01:25,759
然后，

00:01:25,759 --> 00:01:27,840
如果我们没有挖矿，

00:01:27,840 --> 00:01:31,840
这个计算机将直接将其写入区块链，

00:01:31,840 --> 00:01:34,960
然后它们会将这个交易传递给它们连接的节点，

00:01:34,960 --> 00:01:38,960
将其写入自己的文件，

00:01:38,960 --> 00:01:40,640
如此反复，

00:01:40,640 --> 00:01:48,320
直到这个交易在整个网络中传播，

00:01:48,320 --> 00:01:50,159
并写入他们的共享文件。

00:01:50,159 --> 00:01:56,079
是拥有共享文件或共享交易的一种简单方法

00:01:56,079 --> 00:01:57,439
你知道的，

00:01:57,439 --> 00:02:01,200
当每个人都更新了他们的文件副本，

00:02:01,200 --> 00:02:06,719
比特币的所有权就从一个人转移到了另一个人，

00:02:06,719 --> 00:02:09,038
这是一个简单的交易。

00:02:09,038 --> 00:02:11,120
但是，如果你这样做，

00:02:11,120 --> 00:02:14,000
会有一个问题需要解决。

00:02:14,000 --> 00:02:17,440
让我们把这个人涂成绿色……

00:02:17,440 --> 00:02:20,959
你要做的就是创建一个交易，

00:02:20,959 --> 00:02:22,560
将比特币发送给这个人

00:02:22,560 --> 00:02:25,440
并将其插入网络的这一侧的一个节点。

00:02:25,440 --> 00:02:29,599
但是，由于这是一个连接的计算机网络，

00:02:29,599 --> 00:02:32,720
你要创建第二个交易，

00:02:32,720 --> 00:02:38,160
将同样的比特币发送给另一个人。

00:02:38,160 --> 00:02:39,200
所以，

00:02:39,200 --> 00:02:46,080
你刚刚在网络中插入了两个试图花费同一比特币的交易，

00:02:46,080 --> 00:02:47,360
你可以这样做，

00:02:47,360 --> 00:02:49,200
因为这是一个网络。

00:02:49,200 --> 00:02:50,959
接下来会发生的是，

00:02:53,280 --> 00:02:55,200
这两个交易将开始在网络中传播。

00:02:55,200 --> 00:02:57,280
你可以看到，

00:02:57,280 --> 00:03:01,599
这边的计算机已经收到了这个红色的交易和第二个交易，

00:03:01,599 --> 00:03:04,640
但是这边的计算机已经收到了绿色的交易。

00:03:04,640 --> 00:03:08,239
当这台计算机试图将绿色的交易传递给这台计算机时，

00:03:08,239 --> 00:03:15,440
这台计算机已经收到了花费这个比特币的红色交易，

00:03:15,440 --> 00:03:17,840
所以它们会拒绝它，

00:03:17,840 --> 00:03:19,360
这是对的。

00:03:19,360 --> 00:03:20,239
但是，

00:03:20,239 --> 00:03:22,800
你仍然有一个问题，

00:03:22,800 --> 00:03:24,800
那就是网络中存在这两个冲突的交易，

00:03:24,800 --> 00:03:28,720
或者你从整个网络或者这个文件的角度来看，

00:03:28,720 --> 00:03:31,360
这个比特币现在属于谁。

00:03:31,360 --> 00:03:34,640
所以，如果你以这种方式运行比特币，

00:03:34,640 --> 00:03:38,720
并直接将交易写入文件，

00:03:38,720 --> 00:03:42,400
你可能会创建这个双重支付问题。

00:03:42,400 --> 00:03:45,360
但是，比特币基本上解决了这个问题，

00:03:45,360 --> 00:03:51,599
将不将冲突的交易写入区块链或这个共享文件，

00:03:51,599 --> 00:03:53,280
这就是挖矿的含义。

00:03:53,280 --> 00:03:56,319
比特币解决这个双重支付问题的方式，

00:03:56,319 --> 00:03:58,239
这就是比特币有趣的地方，

00:03:58,239 --> 00:04:02,000
因为我们以前有过这种技术，

00:04:02,000 --> 00:04:21,199
*麦克风有问题，稍等*

00:04:21,199 --> 00:04:30,880
比特币解决了将两个冲突的交易写入共享文件的问题。

00:04:30,880 --> 00:04:33,199
这就是比特币的有趣之处，

00:04:33,199 --> 00:04:37,199
也是我认为比特币的“发明”成功之处

00:04:37,199 --> 00:04:42,800
比特币解决这个问题的方式是，

00:04:42,800 --> 00:04:47,280
它给运行比特币程序的每台计算机一些临时内存，

00:04:47,280 --> 00:04:50,960
称为内存池。


00:04:50,960 --> 00:04:53,280
你不能阻止这种双重支付攻击，

00:04:53,280 --> 00:04:56,000
接下来会发生的是，

00:04:56,000 --> 00:04:57,759
这个人会在这台计算机中插入一个交易，这个绿色的交易，

00:04:57,759 --> 00:05:02,400
这个绿色的交易，

00:05:02,400 --> 00:05:05,680
然后他们可以去这里做同样的攻击

00:05:05,680 --> 00:05:08,400
再次将这个第二个红色交易插入这台计算机。

00:05:08,400 --> 00:05:11,199
但显然，

00:05:11,199 --> 00:05:12,880
这两个交易并没有直接写入文件，

00:05:12,880 --> 00:05:15,759
它们首先被存储在临时内存中。

00:05:15,759 --> 00:05:16,479
然后，

00:05:16,479 --> 00:05:18,400
同样的事情再次发生，

00:05:18,400 --> 00:05:20,560
两个交易在网络中传播，

00:05:20,560 --> 00:05:23,039
这个节点会拒绝绿色交易，

00:05:23,039 --> 00:05:25,919
因为他们已经接收到了红色交易。

00:05:25,919 --> 00:05:28,800
所以我们看到，

00:05:28,800 --> 00:05:30,639
两个交易都在网络中，

00:05:30,639 --> 00:05:32,000
但它们还没有写入文件，

00:05:32,000 --> 00:05:34,560
所以文件仍然是安全的。

00:05:34,560 --> 00:05:36,880
然后会发生的事情是，

00:05:36,880 --> 00:05:44,880
所有的这些计算机都会努力尝试从他们的内存池中获取交易，

00:05:44,880 --> 00:05:46,720
并将其添加到文件中。

00:05:46,720 --> 00:05:49,120
所以他们基本上都在竞争，

00:05:49,120 --> 00:05:53,199
要成为第一个将内存池中的交易添加到文件中的节点。

00:05:53,199 --> 00:05:56,880
假设这个节点是第一个能够做到的，

00:05:56,880 --> 00:05:58,800
他们将他们的内存池中的交易添加到文件中，

00:05:58,800 --> 00:06:00,400
就像这样……

00:06:00,400 --> 00:06:03,360
当他们这样做的时候，

00:06:03,360 --> 00:06:08,880
他们会将更新后的文件副本传递给他们连接的所有其他节点，

00:06:08,880 --> 00:06:11,039
然后他们会更新他们的副本。

00:06:11,039 --> 00:06:13,280
这个节点，

00:06:13,280 --> 00:06:16,560
因为他们的内存池中有这个冲突的绿色交易，

00:06:16,560 --> 00:06:19,680
但他们刚刚接收到这个红色交易，

00:06:19,680 --> 00:06:22,000
消费了同样的比特币，

00:06:22,000 --> 00:06:28,880
他们会将这个绿色交易从他们的内存池中剔除。

00:06:28,880 --> 00:06:30,880
这个内存池就像一个等待区域或者一个清算所，

00:06:30,880 --> 00:06:33,120
他们接收到了这个红色交易在更新的文件中，

00:06:33,120 --> 00:06:35,360
然后他们会剔除这个冲突的交易。

00:06:35,360 --> 00:06:39,520
然后这个节点会将更新的副本传递给这些节点，

00:06:39,520 --> 00:06:41,199
他们也会做同样的事情，

00:06:41,199 --> 00:06:46,000
他们会从他们的内存池中剔除任何冲突的交易。

00:06:46,000 --> 00:06:50,080
这就是你如何解决网络中有两个冲突交易的问题的方法，

00:06:50,080 --> 00:06:54,080
你只需要有一个等待区域，

00:06:54,080 --> 00:06:56,720
所有的节点都在竞争，

00:06:56,720 --> 00:07:01,039
试图将他们的交易添加到文件中，

00:07:01,039 --> 00:07:04,560
这个过程就叫做挖矿，

00:07:04,560 --> 00:07:06,080
这个人获得了比特币。

00:07:06,080 --> 00:07:07,759
所以这个过程，

00:07:07,759 --> 00:07:10,800
每个节点都在竞争，

00:07:10,800 --> 00:07:14,240
试图从他们的内存池中获取交易，

00:07:14,240 --> 00:07:15,759
然后添加到文件中，

00:07:15,759 --> 00:07:17,280
这就叫做挖矿，

00:07:17,280 --> 00:07:18,639
这就是我现在要解释的。

00:07:18,639 --> 00:07:20,800
那么，

00:07:20,800 --> 00:07:23,039
到目前为止有问题吗?

00:07:23,039 --> 00:07:25,759
但是这里需要注意的一点是，

00:07:25,759 --> 00:07:29,840
网络中的每个节点并不一定都在挖矿。

00:07:29,840 --> 00:07:32,240
是的，

00:07:32,240 --> 00:07:37,280
我做了一个非常简单的图表来尝试解释这个问题。

00:07:37,280 --> 00:07:39,360
有些节点可能并不是在挖矿，

00:07:39,360 --> 00:07:43,360
你可以只运行一个节点来传递区块和交易信息。

00:07:43,360 --> 00:07:47,680
但在这个简化的图表中，

00:07:47,680 --> 00:07:50,400
每个节点都在尝试挖矿。

00:07:50,400 --> 00:07:53,360
我们也可以设想一个不挖矿的节点，

00:07:53,360 --> 00:07:58,479
如果它收到一个包含交易信息的区块

00:07:58,720 --> 00:08:01,280
而内存池中有一个与之冲突的交易，

00:08:01,280 --> 00:08:03,039
它会将其移除。

00:08:03,039 --> 00:08:05,520
是的

00:08:05,520 --> 00:08:07,120
所有的区块和交易信息传递，

00:08:07,120 --> 00:08:09,360
节点都会做这个工作，

00:08:09,360 --> 00:08:13,199
但是矿工只会做这最后一部分，

00:08:13,199 --> 00:08:15,599
试图从内存池中添加交易信息。

00:08:15,599 --> 00:08:17,759
这就是矿工的工作，

00:08:17,759 --> 00:08:21,440
你可以成为一个节点，而不必挖矿。

00:08:21,440 --> 00:08:25,639
而不必挖矿。

00:08:26,319 --> 00:08:29,599
我的介绍还可以吗？

00:08:29,599 --> 00:08:33,519
接下来我要解释的是哈希函数，

00:08:33,519 --> 00:08:38,880
然后我会讲解比特币挖矿是如何工作的。

00:08:38,880 --> 00:08:41,279
好的，

00:08:41,279 --> 00:08:48,320
哈希函数其实就是一个小型的计算机程序，

00:08:48,320 --> 00:08:53,360
它的工作方式是你可以将一些数据输入到哈希函数中，

00:08:53,360 --> 00:09:06,160
哈希函数会将其打乱并产生一个随机的数据字符串作为结果。

00:09:06,320 --> 00:09:08,800
哈希函数的一个有用的特性是，

00:09:08,800 --> 00:09:12,640
你可以将相同的数据输入到它中，

00:09:12,640 --> 00:09:16,480
它总是会输出相同的结果，

00:09:16,480 --> 00:09:22,080
也就是以相同的方式打乱数据以产生这个随机的数据字符串。

00:09:22,080 --> 00:09:23,600
这个数据字符串的大小总是相同的，

00:09:23,600 --> 00:09:26,880
为32字节或64个字符，

00:09:26,880 --> 00:09:32,560
因为每个字节有两个字符。

00:09:32,560 --> 00:09:38,160
如果你对输入到哈希函数中的数据做一个微小的调整，

00:09:38,160 --> 00:09:43,200
比如从a1变为a2，

00:09:43,200 --> 00:09:45,519
结果会完全不同。

00:09:45,519 --> 00:09:47,600
我们只做了一个微小的调整，

00:09:47,600 --> 00:09:51,440
但哈希函数的结果却大不相同。

00:09:51,440 --> 00:09:54,399
再次输入a3，

00:09:54,399 --> 00:09:55,839
微小的调整，

00:09:55,839 --> 00:09:57,440
结果还是完全不同。

00:09:57,440 --> 00:10:01,839
哈希函数的一个重要特性是，

00:10:01,839 --> 00:10:06,880
如果你事先不知道结果，

00:10:06,880 --> 00:10:11,200
就无法预测a2会输出什么。

00:10:11,200 --> 00:10:11,920
结论：

00:10:11,920 --> 00:10:15,760
如果你事先不知道这个结果，

00:10:15,760 --> 00:10:19,440
就无法预测结果到是什么，

00:10:19,440 --> 00:10:22,959
这是很有用的，

00:10:22,959 --> 00:10:24,160
我们稍后会看到。

00:10:24,160 --> 00:10:25,760
最后，

00:10:25,760 --> 00:10:30,079
尽管这看起来像一个随机的数据字符串，

00:10:30,079 --> 00:10:31,440
它包含了字母f、e、a，

00:10:31,440 --> 00:10:34,959
基本上是a、b、c、d、e和f，

00:10:34,959 --> 00:10:37,760
但它们实际上可以转换成数字。

00:10:37,760 --> 00:10:44,839
这是因为我们习惯于使用十进制格式的数字，

00:10:44,839 --> 00:10:48,320
它使用0到9的数字，

00:10:48,320 --> 00:10:52,880
但你也有一种叫做十六进制的数字格式，

00:10:52,880 --> 00:10:55,760
它使用相同的数字，

00:10:55,760 --> 00:10:59,360
但也包括a、b、c、d、e和f，

00:10:59,360 --> 00:11:01,680
当你转换它们时，

00:11:01,680 --> 00:11:04,240
它们就像这样。

00:11:04,480 --> 00:11:05,519
所以，

00:11:05,519 --> 00:11:07,279
这被称为十进制，

00:11:07,279 --> 00:11:08,160
因为它使用10，

00:11:08,160 --> 00:11:12,720
deci在拉丁语中意思是10。

00:11:12,720 --> 00:11:15,040
然后十六进制，

00:11:15,040 --> 00:11:18,800
hexa就像六边形一样有六个边，

00:11:18,800 --> 00:11:19,519
deci 10，6 10 16。

00:11:19,519 --> 00:11:21,920
所以，

00:11:21,920 --> 00:11:23,920
基本上这是我们人类使用的，

00:11:23,920 --> 00:11:26,560
但计算机非常乐意以十六进制格式读取数字。

00:11:26,560 --> 00:11:28,560
基本上来说，

00:11:28,560 --> 00:11:30,800
你把数据放入哈希函数，

00:11:30,800 --> 00:11:36,000
它会输出一个随机数作为结果。

00:11:36,000 --> 00:11:43,760
如果你看到一个像这样的十六进制格式字符串，

00:11:43,760 --> 00:11:46,480
记住这只是一个随机数。

00:11:46,480 --> 00:11:49,680
这个概念很容易理解了吧？

00:11:49,680 --> 00:11:51,360
好的，

00:11:51,360 --> 00:11:52,240
那就是哈希函数，

00:11:52,240 --> 00:11:54,399
它只是一个输出随机数据的小工具。

00:11:54,399 --> 00:11:58,240
如果我快速给你展示一下，

00:11:58,240 --> 00:11:59,760
我不知道你们是否能看到，

00:11:59,760 --> 00:12:03,760
是否能读懂

00:12:03,760 --> 00:12:06,959
但如果你能看到，

00:12:06,959 --> 00:12:08,720
哈希函数在很多编程语言中都有。

00:12:08,720 --> 00:12:11,360
例如，在PHP中，

00:12:11,360 --> 00:12:16,720
有一个叫做hash()的函数，

00:12:16,720 --> 00:12:20,560
然后你可以告诉它你想使用哪种哈希函数，

00:12:20,560 --> 00:12:22,079
比如sha256，

00:12:22,079 --> 00:12:23,920
这是比特币中使用的一种，

00:12:23,920 --> 00:12:29,959
它代表的是简单哈希算法256位，

00:12:29,959 --> 00:12:34,480
这是它输出结果的大小，

00:12:34,480 --> 00:12:36,560
然后你可以把你想要哈希的内容放进去。

00:12:36,560 --> 00:12:38,800
好了。

00:12:38,800 --> 00:12:41,440
这就是结果，

00:12:51,200 --> 00:12:57,440
你可以在任何编程语言中使用哈希函数

00:12:57,440 --> 00:12:59,920
我刚刚展示了如何在PHP中使用它

00:12:59,920 --> 00:13:04,000
这是在Ruby中，

00:13:04,000 --> 00:13:08,240
只是为了完整

00:13:08,240 --> 00:13:10,160
它包含在'digest'库中，

00:13:10,160 --> 00:13:18,480
所以你可以输入:' puts digest::SHA56

00:13:18,480 --> 00:13:21,839
然后我们需要一个十六进制摘要…

00:13:21,839 --> 00:13:26,000
“摘要”只是从哈希函数中得到的结果的另一个术语

00:13:26,000 --> 00:13:28,560
所以我把“a1”代入这里，

00:13:28,560 --> 00:13:30,639
这里我们得到了同样的东西，

00:13:30,639 --> 00:13:31,839
所以

00:13:31,839 --> 00:13:39,279
哈希函数在很多编程语言中都是可用的

00:13:39,279 --> 00:13:44,079
现在我将介绍挖矿的基本原理，

00:13:44,079 --> 00:13:49,360
我将给出一个简单的例子

00:13:49,360 --> 00:13:56,320
说明如何从内存池获取交易并将其添加到区块链中。

00:13:56,320 --> 00:13:58,639
所以，

00:13:58,639 --> 00:14:00,320
挖矿的基本原理是，

00:14:00,320 --> 00:14:02,079
所有的交易都在内存池中。

00:14:02,079 --> 00:14:16,399
*调整麦克风*

00:14:16,399 --> 00:14:19,199
我们继续来看到这个计算机，

00:14:19,199 --> 00:14:20,880
这个节点是一个矿工，

00:14:20,880 --> 00:14:22,800
我们来看看它的内部，

00:14:22,800 --> 00:14:27,600
看看它是如何从内存池中挖取交易到其文件的。

00:14:28,480 --> 00:14:41,680
*他调整麦克风*

00:14:41,680 --> 00:14:46,079
我们继续，查看比特币矿工的内部情况。

00:14:46,079 --> 00:14:47,680
这是内存池，

00:14:47,680 --> 00:14:49,680
里面有红色的是交易。

00:14:49,680 --> 00:14:52,240
交易在内存池中，

00:14:52,240 --> 00:14:56,639
但内存池中可以有多个交易。

00:14:56,639 --> 00:15:00,959
假设这个内存池已经有了很多交易。

00:15:00,959 --> 00:15:08,079
挖矿者会创建一个叫做候选块的容器，

00:15:08,079 --> 00:15:12,240
这只是一个交易的容器。

00:15:12,240 --> 00:15:18,800
他们会用内存池中的交易填充这个候选块，

00:15:18,800 --> 00:15:21,519
就像这样，

00:15:21,519 --> 00:15:26,480
然后他们会试图将这个交易块添加到区块链上。

00:15:26,480 --> 00:15:36,880
那么他们如何将这个他们构建的候选块添加到区块链上呢？

00:15:36,880 --> 00:15:38,880
首先，

00:15:38,880 --> 00:15:41,839
他们会构建一个被称为区块头的东西，

00:15:41,839 --> 00:15:44,000
这只是块内所有数据的摘要，

00:15:44,000 --> 00:15:47,839
所有区块内的交易，

00:15:47,839 --> 00:15:49,680
在那个区块头中，

00:15:49,680 --> 00:15:51,199
你有一个被称为版本的东西，

00:15:51,199 --> 00:15:54,800
这就像是数据结构的版本号，

00:15:54,800 --> 00:15:56,639
假设那是1。

00:15:56,639 --> 00:15:59,199
还会有一些被称为

00:15:59,199 --> 00:16:03,680
前一个区块或前一个区块哈希的信息。

00:16:03,680 --> 00:16:05,600
这个工作方式是，

00:16:05,600 --> 00:16:08,800
假设这是区块链，

00:16:08,800 --> 00:16:14,320
他们正在构建的这个候选块必须建立在这些区块之一的顶部。

00:16:14,320 --> 00:16:20,160
所以挖矿者会做的是，

00:16:20,160 --> 00:16:25,040
他们会包含他们想要建立在其顶部的区块的哈希或区块哈希，

00:16:25,040 --> 00:16:28,079
这就像是一个区块的id号。

00:16:28,079 --> 00:16:29,360
所以在这里，

00:16:29,360 --> 00:16:32,800
这是这个区块的区块哈希。

00:16:32,800 --> 00:16:37,360
所以这只是说他们想要建立在哪个区块的顶部，

00:16:37,360 --> 00:16:43,279
因为每个挖矿者基本上都想要建立在区块链的顶部。

00:16:43,279 --> 00:16:47,040
我来讲解“默克尔根”是什么

00:16:47,040 --> 00:16:48,720
基本上如果你把所有的交易ID一起哈希，

00:16:48,720 --> 00:16:52,639
反复的哈希，

00:16:52,639 --> 00:16:55,199
你最后会得到一个单独的哈希，

00:16:55,199 --> 00:16:59,120
这就叫做梅克尔根。

00:16:59,120 --> 00:17:00,240
就像这样，

00:17:00,240 --> 00:17:02,639
这基本上就像一个指纹，

00:17:02,639 --> 00:17:04,959
一个数字指纹，

00:17:04,959 --> 00:17:12,160
总结了区块中的所有交易。

00:17:12,160 --> 00:17:14,319
所以，

00:17:14,319 --> 00:17:17,119
你知道这个区块头，

00:17:17,119 --> 00:17:18,720
它创建了一个独特的指纹，

00:17:18,720 --> 00:17:21,839
用于所有的区块数据，

00:17:21,839 --> 00:17:24,160
但使用的数据比所有的交易数据组合起来要少得多。

00:17:24,160 --> 00:17:28,720
或许你能谈一谈默克尔根

00:17:28,720 --> 00:17:34,160
因为我没有听说过太多关于它的事情。

00:17:34,160 --> 00:17:36,400
你是在哈希每一笔交易，

00:17:36,400 --> 00:17:40,640
然后哈希那些结果吗？

00:17:40,640 --> 00:17:42,960
是的，我会在接下来的技术部分中介绍这个，

00:17:42,960 --> 00:17:44,720
但只要现在你需要知道：

00:17:50,799 --> 00:17:52,720
涵盖所有区块交易的总结就可以了。

00:17:52,720 --> 00:17:54,720
默克尔根是非常有意义的。

00:17:54,720 --> 00:17:57,520
我会在一会儿介绍梅克尔是如何工作的，

00:17:57,520 --> 00:18:00,000
以及为什么使用梅克尔，

00:18:00,000 --> 00:18:02,240
这是一个好问题。

00:18:02,240 --> 00:18:04,000
这是区块头，

00:18:04,000 --> 00:18:07,600
我没有涵盖所有的区块头数据，

00:18:07,600 --> 00:18:09,520
那么这就是是最重要的东西。

00:18:09,520 --> 00:18:14,880
现在我们有了一个区块头，

00:18:14,880 --> 00:18:19,919
下一步就是将这个区块头数据放入哈希函数，

00:18:19,919 --> 00:18:23,200
也就是SHA-256哈希函数中，

00:18:23,200 --> 00:18:27,600
然后这将产生一个随机数作为结果，

00:18:27,600 --> 00:18:31,919
这就是所谓的区块哈希。

00:18:32,000 --> 00:18:34,480
到目前为止你有任何问题吗？

00:18:34,480 --> 00:18:35,919
好的，

00:18:35,919 --> 00:18:38,559
这很好，我们继续，

00:18:38,559 --> 00:18:43,760
但是为什么矿工要这么做呢？

00:18:43,760 --> 00:18:46,240
或者说，这如何帮助将区块挖掘到区块链上呢？

00:18:46,240 --> 00:18:47,600
如果这个区块哈希，

00:18:47,600 --> 00:18:54,960
也就是将区块头放入哈希函数产生的结果，

00:18:54,960 --> 00:19:00,160
生成一个低于“Target”值的块哈希值

00:19:00,160 --> 00:19:02,320
就像这样，

00:19:02,320 --> 00:19:06,640
假设这是当前的目标值，

00:19:07,200 --> 00:19:15,120
这是每个比特币节点内部的一个数字，

00:19:15,120 --> 00:19:19,600
他们都有一个共享的目标值，

00:19:19,600 --> 00:19:23,840
这个目标值与其他节点同步计算。

00:19:23,840 --> 00:19:28,720
他们能让他们的区块哈希值低于这个目标值，

00:19:28,720 --> 00:19:30,320
那么这个区块就会被添加到区块链上，

00:19:30,320 --> 00:19:32,480
这个问题基本上解决了。

00:19:32,480 --> 00:19:34,320
所以，

00:19:34,320 --> 00:19:35,919
到目前为止，

00:19:35,919 --> 00:19:38,480
这是第一次尝试，

00:19:38,480 --> 00:19:40,160
你们可以看到，

00:19:40,160 --> 00:19:43,840
这个数字显然比目标值大，

00:19:43,840 --> 00:19:45,600
所以它不低于目标，

00:19:45,600 --> 00:19:48,160
所以，

00:19:48,160 --> 00:19:55,039
这第一次尝试添加这个区块到区块链上失败了。

00:19:55,039 --> 00:19:59,200
然后，矿工并不放弃。

00:19:59,200 --> 00:20:00,880
在区块头中，

00:20:00,880 --> 00:20:06,480
有一个额外的字段叫做nonce，

00:20:06,480 --> 00:20:12,400
它代表一次性使用的数字。

00:20:12,400 --> 00:20:16,240
这是一个开放的字段，

00:20:16,240 --> 00:20:20,240
矿工可以自由地放入他们自己的数字或数据。

00:20:20,240 --> 00:20:22,960
所以，

00:20:22,960 --> 00:20:24,480
如果区块头的第一次尝试失败，

00:20:24,480 --> 00:20:28,559
他们可以改变nonce值或改变nonce中的数据。

00:20:28,559 --> 00:20:31,120
例如，

00:20:31,120 --> 00:20:33,520
第一次尝试可能他们在那里放了数字零，

00:20:33,520 --> 00:20:35,600
如果那失败了，

00:20:35,600 --> 00:20:37,840
他们会改变nonce，

00:20:37,840 --> 00:20:39,600
然后再次将区块头通过哈希函数。

00:20:39,600 --> 00:20:41,919
因为我们只做了一点小的调整

00:20:41,919 --> 00:20:44,880
就像我之前给你们展示的哈希函数，

00:20:44,880 --> 00:20:50,080
小的调整可以产生完全不同的结果。

00:20:50,080 --> 00:20:54,720
所以，矿工基本上会构造一个区块头，

00:20:54,720 --> 00:20:58,720
并不断改变这个nonce值，

00:20:58,720 --> 00:21:04,159
希望结果会产生一个低于目标值的区块哈希。

00:21:04,159 --> 00:21:08,080
所以，矿工实际上是创建一个区块头，

00:21:08,080 --> 00:21:09,919
然后在末尾添加一个nonce，

00:21:09,919 --> 00:21:12,400
如果不成功，

00:21:12,400 --> 00:21:14,840
他们会不断增加尝试，

00:21:14,840 --> 00:21:17,679
这完全是随机的，

00:21:17,679 --> 00:21:19,200
…这只是纯粹的随机性和纯粹的运气…

00:21:19,200 --> 00:21:25,440
他们可能能够猜到一个有效的随机数，

00:21:25,440 --> 00:21:30,400
产生一个低于目标的区块哈希。

00:21:30,400 --> 00:21:32,640
所以，

00:21:32,640 --> 00:21:38,000
这个特定的非常高的随机数产生了一个成功的区块哈希结果。

00:21:38,000 --> 00:21:39,280
然后，

00:21:39,280 --> 00:21:43,120
这个节点会将该区块添加到他们的区块链中，

00:21:43,120 --> 00:21:50,640
并将这个已解决的候选区块传递给他们连接的所有节点。

00:21:50,640 --> 00:21:58,000
他们会检查并验证区块头确实产生了一个低于目标的区块哈希，

00:21:58,000 --> 00:22:00,880
然后将其添加到文件中，

00:22:00,880 --> 00:22:05,360
剔除包含在该区块中的任何冲突交易，

00:22:05,360 --> 00:22:08,240
然后像这样传递区块。

00:22:08,240 --> 00:22:09,360
他们也会做同样的事情。

00:22:09,360 --> 00:22:13,679
这就是挖矿在基本层面上的工作方式。

00:22:13,679 --> 00:22:19,440
我有个问题，

00:22:19,440 --> 00:22:24,559
你说的目标值，

00:22:24,840 --> 00:22:28,559
每个节点都有自己的目标值，

00:22:28,559 --> 00:22:30,480
对吗？我想过这个问题，

00:22:30,480 --> 00:22:37,919
但是有可能我挖到的区块低于我的目标值，

00:22:37,919 --> 00:22:40,960
然后我把它给我的邻居节点，

00:22:40,960 --> 00:22:44,400
可能目标值已经改变了，

00:22:44,400 --> 00:22:46,799
或者出于某种原因，

00:22:46,799 --> 00:22:49,039
其他节点的目标值不同。

00:22:49,039 --> 00:22:51,600
是的，

00:22:51,600 --> 00:22:53,760
我明白你的问题。

00:22:53,760 --> 00:22:59,360
我想我已经解释过目标了，

00:22:59,360 --> 00:23:02,159
可能我没有解释得很好，

00:23:02,159 --> 00:23:11,919
我再解释一下。

00:23:11,919 --> 00:23:17,440
目标的存在是为了确保每10分钟会有一个新的区块被挖出。

00:23:17,520 --> 00:23:19,760
但是，

00:23:19,760 --> 00:23:29,600
如果有更多的计算机以更快的速度进行哈希运算，

00:23:29,600 --> 00:23:32,880
那么一个区块可能会在10分钟内被挖出。

00:23:32,880 --> 00:23:34,240
因此，

00:23:34,240 --> 00:23:38,559
这个目标值会上下浮动，

00:23:38,559 --> 00:23:44,480
以确保每10分钟挖出一个新的区块。

00:23:44,480 --> 00:23:48,080
当你首次运行比特币并挖出第一个区块时，

00:23:48,080 --> 00:23:53,919
目标值是硬编码在这个值中的。

00:23:53,919 --> 00:23:57,039
然后，每过2016个区块，

00:23:59,200 --> 00:24:02,000
或者大约每两周，

00:24:02,000 --> 00:24:09,120
每个节点都会查看挖出最后2016个区块所需的时间。

00:24:09,120 --> 00:24:14,559
预期的时间显然是20160分钟，

00:24:14,559 --> 00:24:18,880
但如果实际挖出这些区块的时间少于这个时间，

00:24:18,880 --> 00:24:21,120
那么，目标会进行调整。

00:24:21,120 --> 00:24:25,200
目标会按照这个比例进行调整。

00:24:25,200 --> 00:24:26,000
所以，

00:24:26,000 --> 00:24:29,679
这个比例是因为所有的区块都被挖掘得更快，

00:24:29,679 --> 00:24:32,960
所以它是0.9。

00:24:32,960 --> 00:24:34,880
所以你可以看到，

00:24:34,880 --> 00:24:36,720
这个目标会向下调整。

00:24:36,720 --> 00:24:38,880
所以每个节点在接收到一个新的区块后，

00:24:38,880 --> 00:24:41,279
每2016个区块，

00:24:41,279 --> 00:24:45,360
他们都会做这个精确的计算。

00:24:45,360 --> 00:24:47,520
然后每个节点都从这个值开始，

00:24:47,520 --> 00:24:49,520
但是如果每个人都在同一个区块，

00:24:49,520 --> 00:24:53,840
那么每个人都会计算出同样的目标。

00:24:53,840 --> 00:24:56,720
所以基本上每个人都有同样的目标，

00:24:56,720 --> 00:24:59,840
他们都自己计算，

00:24:59,840 --> 00:25:02,000
但是因为他们都接收到同样的区块，

00:25:02,000 --> 00:25:04,159
他们都会计算出同样的目标值。

00:25:04,159 --> 00:25:07,520
所以不是每个人都有不同的目标值，

00:25:07,520 --> 00:25:10,799
个人都有同样的计算目标。

00:25:10,799 --> 00:25:13,360
所以再次强调，

00:25:13,360 --> 00:25:14,880
这每2016个区块就会发生一次，

00:25:14,880 --> 00:25:18,240
同样的事情会发生，

00:25:18,240 --> 00:25:19,440
他们花了多长时间，

00:25:19,440 --> 00:25:22,720
比例是多少，挖掘得更快，

00:25:23,360 --> 00:25:24,240
就再次向下调整，

00:25:24,240 --> 00:25:26,559
就像这样。

00:25:26,960 --> 00:25:29,120
那么，

00:25:29,120 --> 00:25:31,279
这就是Target 是如何工作的。

00:25:31,279 --> 00:25:36,159
到目前为止，

00:25:36,159 --> 00:25:39,520
我已经把这个区块链称为一个共享文件，

00:25:39,520 --> 00:25:41,919
这个共享文件是一个区块链。

00:25:41,919 --> 00:25:45,440
基本上，这个共享文件充满了交易，

00:25:45,440 --> 00:25:48,559
因为交易是以区块的形式添加的，

00:25:48,559 --> 00:25:50,240
这个文件被称为区块链，

00:25:50,240 --> 00:25:52,480
因为每个区块都在彼此之上建立。

00:25:52,480 --> 00:25:54,559
所以对于比特币来说，

00:25:54,559 --> 00:25:56,240
它是一个共享文件，

00:25:56,240 --> 00:25:57,919
这个共享文件被称为区块链。

00:25:57,919 --> 00:26:00,320
所以如果我更新这个图，

00:26:00,320 --> 00:26:06,000
你可以把这个共享文件想象成就是一堆堆叠在一起的区块。

00:26:06,000 --> 00:26:07,520
最后，

00:26:07,520 --> 00:26:09,679
为什么有人会挖矿呢？

00:26:09,679 --> 00:26:11,279
对于矿工来说，

00:26:11,279 --> 00:26:15,679
他们为什么要在他们的电脑上使用所有这些哈希算力

00:26:15,679 --> 00:26:20,799
来尝试从内存池中挖掘交易到区块链呢？

00:26:20,799 --> 00:26:25,520
每次矿工成功挖掘一个区块，

00:26:25,520 --> 00:26:27,919
们都会得到一个叫做区块奖励的东西。

00:26:27,919 --> 00:26:30,159
它开始时是50，

00:26:30,159 --> 00:26:34,559
但大约每四年就会减半。

00:26:34,799 --> 00:26:37,600
所以这就是挖掘一个区块的激励。

00:26:37,600 --> 00:26:40,640
当矿工构建候选区块时，

00:26:40,640 --> 00:26:45,120
他们会得到这个区块奖励。

00:26:45,120 --> 00:26:49,440
第一笔交易是他们自己的。

00:26:49,440 --> 00:26:55,600
矿工会把他们自己的交易放在最顶部，

00:26:55,600 --> 00:26:57,039
这叫做coinbase交易。

00:26:57,039 --> 00:27:01,440
这是一种特殊的交易，

00:27:01,440 --> 00:27:07,440
因为它允许他们向自己发送一定数量的比特币，

00:27:07,440 --> 00:27:12,240
这些比特币之前并不存在。

00:27:12,240 --> 00:27:13,039
所以，

00:27:13,039 --> 00:27:16,320
如果这个区块被挖掘到区块链上，

00:27:16,320 --> 00:27:19,600
他们将能够通过这个coinbase交易接收新的比特币。

00:27:19,600 --> 00:27:21,440
多亏了这个coinbase交易，

00:27:21,440 --> 00:27:25,360
他们在这里放置他们的比特币地址，

00:27:25,360 --> 00:27:28,960
以便他们可以接收区块奖励。

00:27:28,960 --> 00:27:30,640
总结一下挖矿的基本步骤，

00:27:30,640 --> 00:27:34,480
矿工会从内存池中获取交易，

00:27:34,480 --> 00:27:37,200
然后他们会在顶部放置他们的coinbase交易，

00:27:37,200 --> 00:27:40,080
以便如果他们成功挖掘这个区块到区块链上，

00:27:40,080 --> 00:27:41,600
可以接收区块奖励。

00:27:41,600 --> 00:27:43,760
然后他们会创建一个区块头，

00:27:43,760 --> 00:27:45,679
对其进行哈希。

00:27:45,679 --> 00:27:48,000
希望哈希值低于目标值，

00:27:48,000 --> 00:27:49,679
如果不是，

00:27:49,679 --> 00:27:52,000
他们会不断调整nonce，

00:27:52,000 --> 00:27:56,480
直到他们领先于别人找到一个nonce，

00:27:56,480 --> 00:27:58,159
这个nonce产生的区块哈希值低于目标值。

00:27:58,159 --> 00:28:01,440
然后他们会将区块添加到区块链上。

00:28:01,440 --> 00:28:03,840
像这样。你理解了吗?

00:28:04,080 --> 00:28:06,320
你理解了吗?

00:28:06,320 --> 00:28:08,159
okay

00:28:08,159 --> 00:28:16,240
我现在将向你展示一个小型的挖矿模拟器。

00:28:16,240 --> 00:28:27,279
这就是比特币矿机在内部可能看起来的样子。

00:28:27,279 --> 00:28:31,600
他们会进入他们的内存池，

00:28:31,600 --> 00:28:34,080
从内存池中获取交易。

00:28:34,080 --> 00:28:40,000
这个挖矿模拟器正在挖掘一个已经被挖掘过的区块，

00:28:40,000 --> 00:28:41,679
这是很久以前的事情，

00:28:41,679 --> 00:28:43,279
内存池中只有13个交易。

00:28:43,279 --> 00:28:45,440
现在显然更多了。

00:28:45,440 --> 00:28:46,720
然后它们会做什么呢，

00:28:46,720 --> 00:28:48,240
它们会构建区块头，

00:28:48,240 --> 00:28:52,399
我还没有介绍区块头的最后两部分，

00:28:52,399 --> 00:28:53,679
不过别担心，

00:28:53,679 --> 00:28:54,640
我马上就会介绍。

00:28:54,640 --> 00:28:56,399
但这些数据是指前一个区块...

00:28:56,399 --> 00:29:00,640
有默克尔根，版本号。

00:29:00,640 --> 00:29:03,440
然后他们会做的是，

00:29:03,440 --> 00:29:06,720
把所有这些数据压缩成一行数据。

00:29:06,720 --> 00:29:08,480
我在这里留了一些空间用于nonce，

00:29:08,480 --> 00:29:11,520
这是区块头数据，

00:29:11,520 --> 00:29:13,840
这是目标值。

00:29:13,840 --> 00:29:16,320
然后矿工会做的是，

00:29:16,320 --> 00:29:18,080
他们会取这个区块头，

00:29:18,080 --> 00:29:19,760
并在其中放入一个nonce，

00:29:19,760 --> 00:29:22,640
不断增加它，

00:29:22,640 --> 00:29:24,399
正如你现在看到的。

00:29:24,399 --> 00:29:26,240
这是一个非常慢的矿工，

00:29:26,240 --> 00:29:30,720
你可以看到这些是左边的随机数值，

00:29:30,720 --> 00:29:33,919
这些是区块头正在产生的不同的哈希值。

00:29:33,919 --> 00:29:35,760
好的，

00:29:35,760 --> 00:29:39,120
所以当你在顶部创建那个字符串...？

00:29:39,120 --> 00:29:42,080
那并没有包括交易，

00:29:42,080 --> 00:29:45,440
只包括了区块头？

00:29:45,440 --> 00:29:46,159
是的

00:29:46,159 --> 00:29:51,279
哦，好的。

00:29:51,279 --> 00:29:55,600
交易我想是包含在这个默克尔根里，

00:29:55,600 --> 00:29:58,720
这个默克尔根是所有交易的摘要，

00:29:58,720 --> 00:30:03,039
它指向区块中的所有交易。

00:30:03,039 --> 00:30:05,760
这里是这个矿工的代码，

00:30:05,760 --> 00:30:11,600
它只是挖掘了一个区块头，

00:30:11,600 --> 00:30:15,200
我已经在网站上提供了这个代码，

00:30:15,200 --> 00:30:17,200
我会在一会儿给你一个链接。

00:30:17,200 --> 00:30:21,440
对于这个特定的矿工，

00:30:21,440 --> 00:30:29,200
我知道成功的哈希是什么。

00:30:29,520 --> 00:30:34,000
让我们把这个减少100。

00:30:34,000 --> 00:30:37,200
如果我再次启动这个，

00:30:37,200 --> 00:30:41,520
我已经增加了开始的nonce值，

00:30:41,520 --> 00:30:43,840
所以再次强调，这是区块头。

00:30:43,840 --> 00:30:45,200
这次，随机数不是从0开始，

00:30:45,200 --> 00:30:47,360
而是从一个更高的数字开始。

00:30:47,360 --> 00:30:49,679
如果我现在让它运行，

00:30:49,679 --> 00:30:53,919
希望在大约100次之后，

00:30:53,919 --> 00:30:57,760
当它找到一个低于目标值的区块哈希时，它会停止。

00:30:57,919 --> 00:31:01,200
这里我们来看看，

00:31:01,200 --> 00:31:02,880
如果你看到这个，

00:31:02,880 --> 00:31:04,480
区块已经被挖出来了。

00:31:04,480 --> 00:31:08,000
这个特定的区块哈希完全是随机的，

00:31:08,000 --> 00:31:12,320
纯粹是运气使得区块哈希以这么多个零开头，

00:31:12,320 --> 00:31:14,240
这个值低于目标值，

00:31:14,240 --> 00:31:16,080
所以矿工们就是这样做的，

00:31:16,080 --> 00:31:18,640
他们只是抓取一个区块头，

00:31:18,640 --> 00:31:21,360
改变随机数，尽可能快地进行哈希。

00:31:21,360 --> 00:31:23,279
这个理解起来有问题吗？

00:31:23,279 --> 00:31:24,880
好的，

00:31:24,880 --> 00:31:29,440
我会在最后添加这些链接，

00:31:29,440 --> 00:31:32,720
你去网站learnmebitcoin.com看代码部分，

00:31:32,720 --> 00:31:37,519
我已经把挖矿模拟器的代码放在这里了。

00:31:37,519 --> 00:31:40,320
这是用Ruby写的，

00:31:40,320 --> 00:31:44,799
我觉得这是一种简单易读的语言，

00:31:44,799 --> 00:31:47,440
类似于Python。

00:31:47,440 --> 00:31:49,200
我试图让这个尽可能简单，

00:31:49,200 --> 00:31:51,120
所以如果你想开始哈希你自己的区块头，

00:31:51,120 --> 00:31:53,120
你可以这样做。

00:31:53,120 --> 00:31:55,039
你也可以在浏览器上，

00:31:55,039 --> 00:32:00,080
打开learnmeabitcoin.com

00:32:00,080 --> 00:32:04,480
你将能够看到这些最新的区块，

00:32:04,480 --> 00:32:07,200
这些是区块头，

00:32:07,200 --> 00:32:10,640
如果你点击序列化，

00:32:10,880 --> 00:32:14,399
它会显示序列化的代码，

00:32:14,399 --> 00:32:16,399
如果你对这个进行哈希，

00:32:16,399 --> 00:32:21,919
它会产生这个区块头，

00:32:21,919 --> 00:32:23,679
这是一个候选区块,

00:32:23,679 --> 00:32:26,559
在尝试做同样的事情。

00:32:26,559 --> 00:32:30,159
我很好奇，

00:32:30,159 --> 00:32:35,679
这个是在你的机器上运行的吗？

00:32:35,679 --> 00:32:38,159
这是实时的吗？

00:32:38,159 --> 00:32:39,919
是的，这是实时的。

00:32:39,919 --> 00:32:41,840
这是一个实时的候选区块，

00:32:41,840 --> 00:32:45,760
这些都是实时的交易，

00:32:46,000 --> 00:32:54,080
一切都在浏览器上。

00:32:54,559 --> 00:32:58,480
好的，

00:32:58,480 --> 00:33:01,200
这就是基础知识的介绍。

00:33:01,200 --> 00:33:04,559
现在我将从技术角度来讲解，

00:33:04,559 --> 00:33:06,159
基本上我要讲一遍同样的事情，

00:33:06,159 --> 00:33:10,559
但是从程序员的角度来讲解。

00:33:10,559 --> 00:33:16,720
如果你对编程和挖矿感兴趣，

00:33:16,720 --> 00:33:19,039
这基本上就是和之前同样的内容，

00:33:19,039 --> 00:33:21,120
只是从程序员的角度来看。

00:33:21,120 --> 00:33:23,120
再次重复，

00:33:23,120 --> 00:33:27,200
从内存池中获取交易，

00:33:27,200 --> 00:33:30,240
填充你的区块，

00:33:30,240 --> 00:33:34,000
然后你会得到一个候选区块，

00:33:34,000 --> 00:33:38,159
然后你在顶部放置你的coinbase交易。

00:33:38,159 --> 00:33:41,840
一个区块的第一笔交易总是coinbase交易，

00:33:41,840 --> 00:33:45,120
这是矿工放在那里的。

00:33:45,120 --> 00:33:46,960
这样你就可以领取区块奖励，

00:33:46,960 --> 00:33:50,159
当前是比特币12.5个。

00:33:50,159 --> 00:33:51,600
在选择了所有这些交易之后，

00:33:51,600 --> 00:33:56,080
你会将coinbase交易放在区块的顶部的原因是什么？

00:33:56,080 --> 00:33:57,360
每一笔交易都会有一个费用，

00:33:57,360 --> 00:34:02,559
通过你的coinbase交易，

00:34:02,559 --> 00:34:07,760
你可以收集所有这些费用。

00:34:07,760 --> 00:34:12,560
所以，coinbase交易不仅仅是接收12.5个区块奖励，

00:34:12,560 --> 00:34:14,239
你还可以根据这些费用的价值，

00:34:14,239 --> 00:34:17,040
给自己发送13个或更多的比特币。

00:34:17,040 --> 00:34:19,040
所以，

00:34:19,040 --> 00:34:23,520
coinbase交易包括了费用是吗？

00:34:23,520 --> 00:34:25,280
是的，

00:34:25,280 --> 00:34:27,599
它不仅包括挖矿奖励。

00:34:27,599 --> 00:34:31,520
你还有基础级别的区块奖励，

00:34:31,520 --> 00:34:33,760
但是你可以根据每笔交易的费用，

00:34:33,760 --> 00:34:38,239
给自己发送多少比特币。

00:34:38,239 --> 00:34:42,800
所以这意味着矿工们会倾向于选择交易费更高的交易。

00:34:42,800 --> 0:34:50,800
我们已经完成了交易操作。

00:34:50,800 --> 00:34:54,879
我还有一个问题，

00:34:54,879 --> 00:34:59,839
左边是费用，

00:34:59,839 --> 00:35:05,760
右边是挖矿所需的时间。

00:35:05,760 --> 00:35:08,160
这是否意味着，

00:35:08,160 --> 00:35:12,000
如果我们设置的交易费非常低，

00:35:12,000 --> 00:35:16,880
我们的交易可能永远不会被记录在区块中？

00:35:16,880 --> 00:35:19,040
这种情况在你的经验中是否可能发生？

00:35:19,040 --> 00:35:21,280
是的，可能发生的。

00:35:21,280 --> 00:35:23,359
如果你进行一笔交易，

00:35:23,359 --> 00:35:26,079
它首先会进入内存池。

00:35:26,079 --> 00:35:28,640
如果内存池中有很多交易，

00:35:28,640 --> 00:35:36,640
那么你的交易就要和所有其他交易竞争区块中的空间，

00:35:36,640 --> 00:35:38,720
因为一个区块的大小是有限的，

00:35:38,720 --> 00:35:43,839
以前是1MB，

00:35:43,839 --> 00:35:44,880
现在大约是1.7MB，

00:35:44,880 --> 00:35:46,640
它使用了一个叫做权重的不同度量标准，

00:35:46,640 --> 00:35:48,320
但我现在不打算讲这个。

00:35:48,320 --> 00:35:50,160
那么，会发生的情况是，

00:35:50,160 --> 00:35:53,040
如果你设置的交易费太低，

00:35:53,040 --> 00:35:54,960
以至于它没有被记录在区块中，

00:35:54,960 --> 00:35:58,800
而是仍然停留在内存池中，

00:35:58,800 --> 00:36:05,520
如果你的交易在内存池中停留的时间超过72小时，

00:36:05,520 --> 00:36:10,640
那么你的交易就会被从内存池中踢出。

00:36:10,640 --> 00:36:11,440
所以，

00:36:11,440 --> 00:36:15,440
如果你在交易上设置了非常低的交易费，

00:36:15,440 --> 00:36:18,000
那么有可能你的交易永远不会进入候选区块，

00:36:18,000 --> 00:36:20,640
甚至不会被记录在区块链上。

00:36:20,640 --> 00:36:22,320
那么，根据你的经验，

00:36:22,320 --> 00:36:26,480
根据你的经验，

00:36:26,480 --> 00:36:28,320
如果我想给某人寄五美元，

00:36:28,320 --> 00:36:30,720
或者买一杯三美元的咖啡，

00:36:30,720 --> 00:36:35,839
我需要支付的最低费用是多少？

00:36:35,839 --> 00:36:42,960
我知道钱包通常会帮助你处理这个问题，

00:36:42,960 --> 00:36:49,839
但我不确定他们是否设定了这个费用。

00:36:49,839 --> 00:36:52,079
我会做的一种方式是，

00:36:52,079 --> 00:36:54,960
我会看一下这个候选区块。

00:36:54,960 --> 00:36:56,960
一般来说，

00:36:56,960 --> 00:36:58,640
候选区块中的交易是按照费用从高到低排序的，

00:36:58,640 --> 00:37:01,359
虽然不是完全正确，

00:37:01,359 --> 00:37:04,960
但我会向这个候选区块的底部看，

00:37:04,960 --> 00:37:09,920
看看每个费用，

00:37:09,920 --> 00:37:16,960
你可以添加一个比最低费用更高的费用。

00:37:16,960 --> 00:37:23,040
这是在我看来最简单的方法。

00:37:23,040 --> 00:37:25,599
所以，这是按每字节收费？

00:37:25,599 --> 00:37:28,480
是的，这是按字节计费的，

00:37:28,480 --> 00:37:32,400
当你悬停在上面时，

00:37:32,400 --> 00:37:40,000
可以看到每字节的费用。

00:37:40,000 --> 00:37:42,720
这是一个交易的平均字节大小吗？

00:37:42,720 --> 00:37:47,359
这是一个交易，

00:37:47,359 --> 00:37:50,560
然后你可以在上面设置一个费用，

00:37:50,560 --> 00:37:54,960
你基本上是按每个字节付费，

00:37:54,960 --> 00:37:57,520
所以数据越大的交易，

00:37:57,520 --> 00:38:01,119
你就需要设置更高的费用，

00:38:01,119 --> 00:38:05,839
因为矿工会根据每字节的费用选择交易，

00:38:05,839 --> 00:38:07,520
因此，

00:38:07,520 --> 00:38:09,440
交易占用他们在候选区块中的空间，

00:38:09,440 --> 00:38:15,119
他们会优先选最高费用的交易。

00:38:15,119 --> 00:38:16,720
再次回顾一下挖矿，

00:38:16,720 --> 00:38:19,839
把你的coinbase交易放在最上面，

00:38:19,839 --> 00:38:21,359
然后你可以构造区块头，

00:38:21,359 --> 00:38:23,680
同样的，

00:38:23,680 --> 00:38:24,560
你有一个版本号。

00:38:24,560 --> 00:38:26,480
这是一个旧块，

00:38:26,480 --> 00:38:29,440
版本号是1

00:38:29,440 --> 00:38:34,160
版本号的工作方式现在和以前不同，

00:38:34,160 --> 00:38:36,960
它们可以用于投票，

00:38:36,960 --> 00:38:38,079
我现在不打算讲这个，

00:38:38,079 --> 00:38:40,640
我只是要简单地介绍一下区块头，

00:38:40,640 --> 00:38:42,400
然后你有前一个区块的，

00:38:42,400 --> 00:38:45,200
再次引用前一个区号在其上面建立的区块，

00:38:45,200 --> 00:38:47,119
基本上就是区块链的顶端，

00:38:47,119 --> 00:38:51,599
然后是merkle根。

00:38:51,599 --> 00:38:54,079
merkle根的工作方式是，

00:38:54,079 --> 00:38:55,920
你有所有的交易，

00:38:55,920 --> 00:38:57,119
在区块中，

00:38:57,119 --> 00:38:58,560
我只是把这些移动到一边，

00:38:58,560 --> 00:39:00,480
为了说明目的，

00:39:00,480 --> 00:39:02,320
然后你做的就是运行每一对交易，

00:39:02,320 --> 00:39:04,240
every single pair of transactions and

00:39:04,240 --> 00:39:05,839
然后把它们设一起哈希，

00:39:05,839 --> 00:39:08,720
记住这些哈希函数，

00:39:08,720 --> 00:39:12,240
然后就是把这些排列起来，

00:39:12,240 --> 00:39:15,760
这一和二就把它们排列在一起，

00:39:15,760 --> 00:39:17,920
然后一起哈希，

00:39:17,920 --> 00:39:21,200
它们会产生一个摘要或哈希结果，

00:39:21,200 --> 00:39:22,240
然后他们对区块中的每一对交易都这样做，

00:39:22,240 --> 00:39:26,720
你最后有一个交易是单独的，没有配对，

00:39:26,720 --> 00:39:29,440
你所做的就是把它和自己哈希在一起，

00:39:29,440 --> 00:39:31,680
然后就完成了第一轮，

00:39:31,680 --> 00:39:34,800
你从所有这些对中得到这4个哈希值，

00:39:34,800 --> 00:39:36,560
然后再运行一遍

00:39:36,560 --> 00:39:38,320
将所有的哈希值配对并一起哈希，

00:39:38,320 --> 00:39:40,400
然后再继续这样做，

00:39:40,400 --> 00:39:44,880
最终会得到一个单一的哈希结果，

00:39:44,880 --> 00:39:47,760
这称为默克尔根。

00:39:47,760 --> 00:39:51,119
现在的问题是，

00:39:51,119 --> 00:39:53,599
如果你想创建一个区块中所有交易的摘要

00:39:53,599 --> 00:39:56,480
你要怎么做？

00:39:56,480 --> 00:39:57,839
（顺便说一下，你将这里的交易ID进行哈希）

00:39:57,839 --> 00:40:00,160
但是，

00:40:00,160 --> 00:40:04,560
如果你想创建一个摘要或者指纹来表示区块中的所有交易，

00:40:04,560 --> 00:40:07,760
为什么不只是简单地将它们全部一起哈希，

00:40:07,760 --> 00:40:11,599
而是采用这种更复杂的树形结构呢？

00:40:11,599 --> 00:40:13,520
这样做的原因是，

00:40:13,520 --> 00:40:17,839
假设你得到了一个默克尔根，

00:40:17,839 --> 00:40:26,480
你想检查这个交易ID是否存在于这个区块中。

00:40:26,480 --> 00:40:32,400
唯一的检查方法就是取所有其他的交易ID，

00:40:32,400 --> 00:40:34,160
包括你想检查的那一个，

00:40:34,160 --> 00:40:38,720
然后将它们一起哈希，

00:40:38,720 --> 00:40:41,680
得到默克尔根。

00:40:41,680 --> 00:40:44,000
获取哈希，

00:40:44,000 --> 00:40:45,920
抱歉

00:40:45,920 --> 00:40:47,760
但是，

00:40:47,760 --> 00:40:50,000
如果你想检查这个哈希的存在，

00:40:50,000 --> 00:40:52,320
你实际上只需要这个，

00:40:52,320 --> 00:40:54,000
来创建这个，

00:40:54,000 --> 00:40:55,760
如果你有了这个，

00:40:55,760 --> 00:40:57,599
然后你需要这个，

00:40:57,599 --> 00:40:59,280
然后你就可以创建这个，

00:40:59,280 --> 00:41:01,440
只有这个在这里，

00:41:01,440 --> 00:41:03,920
你就可以得到默克尔根了

00:41:03,920 --> 00:41:06,480
我们做的另一个是1…2…3.4……5……7、6…

00:41:06,480 --> 00:41:10,240
它需要七个交易ID，

00:41:10,240 --> 00:41:12,720
但这个只需要三个。

00:41:12,720 --> 00:41:13,920
显然，

00:41:13,920 --> 00:41:14,960
这看起来并不是一个巨大的改进，

00:41:14,960 --> 00:41:16,319
但这只是一个简单的区块，

00:41:16,319 --> 00:41:23,520
如果这是一个包含数千笔交易的更长的区块，

00:41:23,520 --> 00:41:30,079
你需要更少的交易ID来检查单个交易的存在。

00:41:30,079 --> 00:41:32,079
我自己没有做过这个，

00:41:32,079 --> 00:41:34,160
但是显然这样做是有用的，

00:41:34,160 --> 00:41:35,599
也是高效的。

00:41:35,599 --> 00:41:38,640
所以我们有这个树形结构的哈希，

00:41:38,640 --> 00:41:43,839
因为它可以节省在我们的区块中检查交易存在的时间。

00:41:43,839 --> 00:41:48,880
当你说我们哈希两个交易时？

00:41:48,880 --> 00:41:51,520
是的,没错。

00:41:51,520 --> 00:41:57,760
你只需要将交易id连接起来并做一个sha256哈希。

00:41:57,920 --> 00:42:01,040
基本上是哈希交易数据来给你一个交易ID，

00:42:01,040 --> 00:42:02,960
是的，

00:42:02,960 --> 00:42:04,880
然后你再哈希这些ID。

00:42:04,880 --> 00:42:05,420
没错，对的。

00:42:08,319 --> 00:42:11,280
我们有一个叫做Merkel根的东西，

00:42:11,280 --> 00:42:15,359
，还有区块头中的时间，

00:42:15,359 --> 00:42:19,280
这是一个时间戳。

00:42:17,520 --> 00:42:19,280
但是，

00:42:19,280 --> 00:42:25,440
区块头中的时间是用Unix时间编码的，

00:42:25,440 --> 00:42:30,880
也就是从1970年1月1日开始的秒数。

00:42:30,880 --> 00:42:36,880
这个区块的时间戳的人类表示法是2011年5月12日，

00:42:36,880 --> 00:42:38,960
但在Unix时间中，

00:42:38,960 --> 00:42:42,319
那将是这么多秒。

00:42:42,319 --> 00:42:43,599
关于时间的一个简短说明，

00:42:43,599 --> 00:42:46,720
这些并不需要准确，

00:42:46,720 --> 00:42:51,280
只需要在一个特定的最小值和最大值之间。

00:42:51,280 --> 00:42:52,400
因此，

00:42:52,400 --> 00:42:55,520
你可以设置的最小值作为你的区块头的时间

00:42:55,520 --> 00:43:00,079
是最后11个区块的中位数时间，

00:43:00,079 --> 00:43:08,800
或者基本上是区块头中的第六个区块的时间，

00:43:08,800 --> 00:43:12,400
那么你不能有一个时间比这个更低，

00:43:12,400 --> 00:43:14,000
这是最小界限。

00:43:14,000 --> 00:43:19,119
然后最大值，

00:43:19,119 --> 00:43:22,720
基本上你的节点有它自己的时间，

00:43:22,720 --> 00:43:24,160
当你运行它时，

00:43:24,160 --> 00:43:26,000
它只是使用你的计算机的时间，

00:43:26,000 --> 00:43:28,000
然后当其他节点连接到你时，

00:43:28,000 --> 00:43:30,000
他们会发送他们的计算机上的时间给你，

00:43:30,000 --> 00:43:36,560
所以你的节点会跟踪你连接的所有节点的时间差，

00:43:36,560 --> 00:43:38,560
如果你将它们按顺序排列，

00:43:38,560 --> 00:43:42,319
然后取连接到的所有节点的中位数时间，

00:43:42,319 --> 00:43:47,280
这被称为网络平均时间。

00:43:47,280 --> 00:43:53,680
这个时间的最大值是网络平均时间加上两个小时。

00:43:53,680 --> 00:43:55,520
你能快速重温一下这部分吗?

00:43:55,520 --> 00:43:57,839
我是有点困惑，

00:43:57,839 --> 00:44:00,800
为什么要用这个时间，

00:44:00,800 --> 00:44:04,480
这个时间是挖一个区块还是什么？

00:44:04,480 --> 00:44:08,560
哦，不用，

00:44:08,560 --> 00:44:11,200
我认为我没有必要解释这个

00:44:11,200 --> 00:44:12,960
这个时间并不是用来挖矿的，

00:44:12,960 --> 00:44:14,960
而是你电脑当前的时间，

00:44:14,960 --> 00:44:18,000
插入到区块头中。

00:44:18,000 --> 00:44:20,560
但是这个时间并不需要精确，

00:44:20,560 --> 00:44:25,760
只需要在两个特定的值之间即可。

00:44:25,760 --> 00:44:28,720
只要它大于倒数第六个区块的时间，

00:44:28,720 --> 00:44:32,480
或者是最后11个区块的中位数时间，

00:44:32,480 --> 00:44:36,880
不能低于这个值，

00:44:36,880 --> 00:44:38,400
因为如果你放一个低于这个值的时间，

00:44:38,400 --> 00:44:42,160
那么你发送的节点会被拒绝。

00:44:42,160 --> 00:44:43,920
同时，

00:44:43,920 --> 00:44:47,119
最大的时间基本上是当前时间，

00:44:47,119 --> 00:44:49,280
再加上两个小时，

00:44:49,280 --> 00:44:53,920
但是使用的是网络平均时间，

00:44:53,920 --> 00:44:59,680
这就是你所连接的所有节点的平均时间。

00:44:59,680 --> 00:45:01,839
所以不用担心这个，

00:45:01,839 --> 00:45:03,599
但我要说的是，

00:45:03,599 --> 00:45:08,079
时间可以大约落后一小时或提前一两个小时。

00:45:08,079 --> 00:45:09,920
所以如果你看到一个区块通过，

00:45:09,920 --> 00:45:13,359
它的时间在另一个区块之前或之后，

00:45:13,359 --> 00:45:16,240
那并不重要，

00:45:16,240 --> 00:45:22,240
它有这种灵活的上下界限。

00:45:22,240 --> 00:45:25,359
对的，这就是时间。

00:45:25,359 --> 00:45:27,440
接下来是位数，记住Target，

00:45:27,440 --> 00:45:30,800
位数只是Target的紧凑表示。

00:45:30,800 --> 00:45:37,760
你不需要在区块头中放入整个Target，

00:45:37,760 --> 00:45:40,000
你要做什么？

00:45:40,000 --> 00:45:42,880
你需要抓取前三个重要的字节，

00:45:42,880 --> 00:45:47,599
或者在前导零后的第一个六个重要字符，

00:45:47,599 --> 00:45:50,560
然后把它放在那里，

00:45:50,560 --> 00:45:55,760
然后你需要抓取偏移量，

00:45:55,760 --> 00:45:58,560
也就是这三个字节距离右边有多远，

00:45:58,560 --> 00:46:00,880
这里从右边有26个字节，

00:46:00,880 --> 00:46:02,240
或者在十六进制中，

00:46:02,240 --> 00:46:06,160
26是"1a"。

00:46:06,160 --> 00:46:08,640
所以你只需要把那个开始放在那里，

00:46:08,640 --> 00:46:15,040
位数就是Target的紧凑表示。

00:46:15,040 --> 00:46:16,400
然后就是nonce，

00:46:16,400 --> 00:46:18,800
你可以把它设置为零。

00:46:18,800 --> 00:46:22,400
这就是所有的基本数据，

00:46:22,400 --> 00:46:25,839
现在我们已经准备好了区块头的所有字段。

00:46:25,839 --> 00:46:28,720
这些字段是否都有意义？

00:46:28,720 --> 00:46:30,160
很好，现在我们已经准备好了所有的字段，

00:46:30,160 --> 00:46:31,599
可以开始挖矿了。

00:46:31,599 --> 00:46:35,760
我们只需要把所有的数据都放入正确的格式中。

00:46:35,760 --> 00:46:37,839
这只是一些编程，

00:46:37,839 --> 00:46:41,520
确保所有的东西都在正确的顺序和格式中。

00:46:41,520 --> 00:46:44,400
每个字段都应该是十六进制的，

00:46:44,400 --> 00:46:46,640
把所有的东西都转换成十六进制。

00:46:47,680 --> 00:46:49,440
所以1是十六进制的，这不会改变

00:46:49,440 --> 00:46:52,560
但是你需要检查每一个字段，

00:46:52,560 --> 00:46:54,160
确保它都是十六进制的。

00:46:54,160 --> 00:46:56,640
时间现在是十进制的，

00:46:56,640 --> 00:46:58,079
所以我们把它转换成十六进制，

00:46:58,079 --> 00:47:00,079
对每个其他字段都这样做。

00:47:00,079 --> 00:47:02,800
这个过程对每个字段都是一样的。

00:47:02,800 --> 00:47:03,839
其次，

00:47:03,839 --> 00:47:09,599
每个字段必须是固定的字节数。

00:47:09,599 --> 00:47:11,040
比如，这里只有一个字符，

00:47:11,040 --> 00:47:13,760
但版本字段是四个字节，

00:47:13,760 --> 00:47:16,160
如果我们将其转换为四个字节，

00:47:16,160 --> 00:47:17,839
它看起来就像这样。

00:47:17,839 --> 00:47:20,720
一个字节是两个字符，

00:47:20,720 --> 00:47:23,119
所以"00"就是一个字节，

00:47:23,119 --> 00:47:26,640
版本中有四个字节。

00:47:26,640 --> 00:47:29,599
然后你只需要遍历每个字段，

00:47:29,599 --> 00:47:32,000
确保它们都填充到正确的大小。

00:47:32,000 --> 00:47:36,319
所以这已经是32字节了

00:47:36,319 --> 00:47:37,760
这个时间字段已经是四个字节，

00:47:37,760 --> 00:47:40,400
它已经是四位了，

00:47:40,400 --> 00:47:42,640
同样对于nonce字段也是四个字节。

00:47:42,640 --> 00:47:45,119
所以对于每个字段，

00:47:45,119 --> 00:47:49,760
确保你已经用正确的字节数填充了它。

00:47:49,760 --> 00:47:52,720
这意味着，

00:47:52,720 --> 00:47:56,480
计算机可以轻松地读取每个单独的字段。

00:47:56,960 --> 00:48:03,359
这就是所有的数据都在正确的格式和正确的字段大小。

00:48:03,359 --> 00:48:05,280
最后，

00:48:05,280 --> 00:48:10,160
比特币唯一稍微令人沮丧的事情是，

00:48:10,160 --> 00:48:15,440
当你发送数据到节点时，

00:48:15,440 --> 00:48:19,680
你必须以反向字节顺序发送数据，

00:48:19,680 --> 00:48:22,160
这被称为网络字节顺序。

00:48:22,160 --> 00:48:23,200
order

00:48:23,200 --> 00:48:29,200
我们已经将所有这些数据转换为人类可读的字节顺序，

00:48:29,200 --> 00:48:31,520
但是当你处理比特币数据时，

00:48:31,520 --> 00:48:33,520
它必须是反向字节顺序。

00:48:33,520 --> 00:48:35,680
所以你需要遍历每个字段，

00:48:35,680 --> 00:48:37,200
将其转换为网络字节顺序，

00:48:37,200 --> 00:48:39,440
反转每个字节。

00:48:39,440 --> 00:48:45,599
这是我刚开始挖矿时遇到的问题，

00:48:45,599 --> 00:48:47,280
我试图哈希这些块头，

00:48:47,280 --> 00:48:50,000
我不明白为什么我得不到相同的结果，

00:48:51,040 --> 00:48:56,240
原因就是你需要将所有数据转换为网络字节顺序。

00:48:56,240 --> 00:49:01,839
我做了一个小的演示来说明这一点。

00:49:01,839 --> 00:49:02,880
我已经写了一个简单的脚本来反转字节。

00:49:02,880 --> 00:49:13,200
如果我输入a b c d e f 1 2 3 4，

00:49:13,839 --> 00:49:19,839
那么反转字节的方式就是将其分割成每个单独的字节，

00:49:19,839 --> 00:49:23,200
那么，一个字节是两个字符，

00:49:23,200 --> 00:49:24,720
然后你只需要反转字节的顺序，

00:49:24,720 --> 00:49:26,480
就可以得到结果。

00:49:26,480 --> 00:49:28,480
这就是它的工作原理，

00:49:28,480 --> 00:49:31,680
你不仅仅是反转字符串，

00:49:31,680 --> 00:49:34,800
而是在反转每个字节。

00:49:34,800 --> 00:49:35,920
这可能是一个基本的问题，

00:49:35,920 --> 00:49:38,720
但一个字节是两个字符，对吗？

00:49:38,720 --> 00:49:40,400
是的，

00:49:40,400 --> 00:49:41,680
是的，

00:49:41,680 --> 00:49:42,800
2个字符就是1个字节

00:49:42,800 --> 00:49:45,200
是的，这就是我学到的东西。

00:49:45,200 --> 00:49:51,520
我是在看C++...

00:49:51,520 --> 00:49:54,480
我已经很久没有做过C++了，

00:49:54,480 --> 00:49:59,520
字符类型的大小是一个字节。

00:50:01,599 --> 00:50:06,640
我对计算机科学了解地不是很深入，

00:50:06,640 --> 00:50:10,880
我是从上到下的层次来学习的，

00:50:10,880 --> 00:50:17,440
我只是知道两个字符可以转换为一个字节。

00:50:17,440 --> 00:50:22,160
现在我们终于得到了所有正确顺序的数据，

00:50:22,160 --> 00:50:26,559
然后你只需要将每个单独的字段连接在一起，

00:50:26,559 --> 00:50:28,319
这就是区块头，

00:50:28,319 --> 00:50:32,240
现在它已经准备好放入哈希函数中了。

00:50:32,240 --> 00:50:35,440
正如我提到的，

00:50:35,440 --> 00:50:38,480
比特币使用的是SHA-256简单哈希算法，

00:50:38,480 --> 00:50:39,520
但在比特币中，

00:50:39,520 --> 00:50:44,319
所有的东西都被哈希两次。

00:50:44,319 --> 00:50:46,400
这就是它的设计方式，

00:50:46,400 --> 00:50:50,800
我不认为它提供了任何巨大的好处，

00:50:50,800 --> 00:50:53,520
这只是比特币哈希的方式。

00:50:53,520 --> 00:50:55,760
所以你只需要将这个放入哈希函数，

00:50:55,760 --> 00:50:58,480
它会输出结果，

00:50:58,480 --> 00:50:59,920
然后你再哈希这个结果得到另一个结果，

00:50:59,920 --> 00:51:05,520
这就是最终的哈希。

00:51:05,520 --> 00:51:07,680
当你在比特币中哈希东西时，

00:51:07,680 --> 00:51:10,000
是以十六进制表示的，

00:51:10,000 --> 00:51:12,000
你首先将其转换为二进制，

00:51:12,000 --> 00:51:14,800
然后你将二进制数据放入哈希函数，

00:51:14,800 --> 00:51:15,920
它会输出一个二进制结果，

00:51:15,920 --> 00:51:20,079
你再将这个二进制结果放入第二个哈希函数，

00:51:20,079 --> 00:51:24,880
它会输出第二个二进制摘要，

00:51:24,880 --> 00:51:29,359
当你将这个第二个摘要转换回十六进制时，

00:51:29,359 --> 00:51:33,040
将会给你区块哈希，

00:51:33,040 --> 00:51:41,680
但显然这是以网络字节顺序反向的，

00:51:41,680 --> 00:51:42,880
如果我们将其反转，

00:51:42,880 --> 00:51:45,760
那么它就是更符合人类阅览格式。

00:51:45,760 --> 00:51:50,559
如果你将这个与目标进行比较，

00:51:50,559 --> 00:51:53,520
你需要确保它是反向的，

00:51:55,359 --> 00:51:58,880
返回到非网络字节顺序。

00:51:58,880 --> 00:52:01,359
那么我们就到这里，

00:52:01,359 --> 00:52:03,119
我只讲解了这些东西，

00:52:03,119 --> 00:52:05,599
我再多讲可能会让你困扰。

00:52:05,599 --> 00:52:07,200
获取字段很简单，

00:52:07,200 --> 00:52:08,960
将它们放入正确的顺序，

00:52:08,960 --> 00:52:11,839
将它们转换为二进制，然后再将它们切换回来。

00:52:11,839 --> 00:52:14,240
在你试图自己挖掘区块头或哈希区块头时，

00:52:14,240 --> 00:52:15,920
这就是会让你困扰的地方。

00:52:15,920 --> 00:52:20,640
对，这就是区块头，

00:52:20,640 --> 00:52:26,319
已经将字段反向为网络字节顺序。

00:52:23,760 --> 00:52:26,319
然后对其进行双重哈希？

00:52:26,319 --> 00:52:31,359
是的是的，

00:52:31,359 --> 00:52:36,720
将其转换为十六进制，

00:52:36,720 --> 00:52:40,160
再次反向转换。

00:52:40,160 --> 00:52:43,599
i reversed it i reversed it back

00:52:44,000 --> 00:52:44,839
okay

00:52:44,839 --> 00:52:48,319
um yeah and this is how this is

00:52:48,319 --> 00:52:50,559
like if you mind the block this is the

00:52:50,559 --> 00:52:52,319
hash that you would send on to the

00:52:52,319 --> 00:52:54,880
network is that uh

00:52:54,880 --> 00:52:56,720
um let's say that you end up mining a

00:52:56,720 --> 00:52:58,880
block and let's say you get a nuance

00:52:58,880 --> 00:53:01,599
that is like below a target value yeah

00:53:01,599 --> 00:53:02,880
uh

00:53:02,880 --> 00:53:04,720
what do you do next yeah i mean okay i

00:53:04,720 --> 00:53:06,800
think i should cover that now i think um

00:53:06,800 --> 00:53:08,480
so okay um

00:53:08,480 --> 00:53:09,920
you don't actually send the block hash

00:53:09,920 --> 00:53:11,280
um you just send basically the block

00:53:11,280 --> 00:53:12,880
header and the transactions

00:53:12,880 --> 00:53:13,599
so

00:53:13,599 --> 00:53:15,440
okay but i'm just i don't think you have

00:53:15,440 --> 00:53:16,720
to if you're programming you wouldn't

00:53:16,720 --> 00:53:18,319
you might not have to reverse it this is

00:53:18,319 --> 00:53:19,599
just so i can

00:53:19,599 --> 00:53:23,040
display the results correctly uh in a

00:53:23,040 --> 00:53:24,720
sort of a human way

00:53:24,720 --> 00:53:27,359
so again so now like a minor you just

00:53:27,359 --> 00:53:29,520
change the nonce now i'm incrementing it

00:53:29,520 --> 00:53:30,240
from

00:53:30,240 --> 00:53:32,720
um zero one two three four five and so

00:53:32,720 --> 00:53:35,359
on so there you are obviously this is in

00:53:35,359 --> 00:53:36,880
network byte order

00:53:36,880 --> 00:53:40,319
and so on eventually you'll get a

00:53:40,319 --> 00:53:41,359
uh

00:53:41,359 --> 00:53:43,280
hash uh this below the target if you're

00:53:43,280 --> 00:53:44,160
lucky

00:53:44,160 --> 00:53:46,319
then that's mind so when you mind the

00:53:46,319 --> 00:53:47,839
actual block

00:53:47,839 --> 00:53:49,280
so this is done now so this is a

00:53:49,280 --> 00:53:51,280
successful block header

00:53:51,280 --> 00:53:52,000
so

00:53:52,000 --> 00:53:54,319
if you send this block header to anyone

00:53:54,319 --> 00:53:55,760
else they can hash it for themselves and

00:53:55,760 --> 00:53:57,200
they get the same result

00:53:57,200 --> 00:53:58,559
that's what i think that's what they

00:53:58,559 --> 00:54:00,400
call proof of work because you can just

00:54:00,400 --> 00:54:01,599
send this block header to anyone and

00:54:01,599 --> 00:54:03,440
they can prove for themselves that the

00:54:03,440 --> 00:54:05,359
hash is below the target so what you

00:54:05,359 --> 00:54:08,240
what you do then is you send this block

00:54:08,240 --> 00:54:10,480
uh to all the nodes you're connected to

00:54:10,480 --> 00:54:12,400
and what you're actually sending them is

00:54:12,400 --> 00:54:14,480
all of the transaction data concatenated

00:54:14,480 --> 00:54:16,480
together for each transaction

00:54:16,480 --> 00:54:17,440
um

00:54:17,440 --> 00:54:18,880
before that you put like a little

00:54:18,880 --> 00:54:20,559
transaction counter

00:54:20,559 --> 00:54:22,559
which is just a byte

00:54:22,559 --> 00:54:25,200
it's a it's a very very variable sized

00:54:25,200 --> 00:54:26,960
byte i haven't covered it but it's on

00:54:26,960 --> 00:54:28,720
the website um

00:54:28,720 --> 00:54:30,079
just tells you how many transactions are

00:54:30,079 --> 00:54:31,839
in the block and then before that you

00:54:31,839 --> 00:54:33,520
have the block header so this is what

00:54:33,520 --> 00:54:35,359
gets sent to

00:54:35,359 --> 00:54:37,599
um all the nodes so you don't have to

00:54:37,599 --> 00:54:38,480
send the

00:54:38,480 --> 00:54:39,839
block hash because they can calculate it

00:54:39,839 --> 00:54:42,400
for themselves

00:54:43,119 --> 00:54:44,800
so um

00:54:44,800 --> 00:54:47,599
that's how mining works um what i

00:54:47,599 --> 00:54:50,079
thought i would do now is um try and

00:54:50,079 --> 00:54:53,200
show you how you could uh

00:54:53,200 --> 00:54:56,800
mine a actual live block

00:54:56,800 --> 00:54:58,160
so yeah

00:54:58,160 --> 00:55:01,359
right so um if you run a bitcoin node

00:55:01,359 --> 00:55:05,040
um you have the um bitcoin cli um

00:55:05,040 --> 00:55:06,880
command which allows you to ask the

00:55:06,880 --> 00:55:08,640
bitcoin no questions and one of them you

00:55:08,640 --> 00:55:12,480
can ask them is to get block template

00:55:12,480 --> 00:55:14,559
so what that will do that will take your

00:55:14,559 --> 00:55:16,800
current memory pool and

00:55:16,800 --> 00:55:20,240
gather the highest value transactions

00:55:20,240 --> 00:55:21,839
that would fill up a

00:55:21,839 --> 00:55:22,720
block

00:55:22,720 --> 00:55:24,960
and

00:55:25,119 --> 00:55:27,680
give them to you so this is showing me

00:55:27,680 --> 00:55:29,119
all of the transactions that would make

00:55:29,119 --> 00:55:30,400
a

00:55:30,400 --> 00:55:32,319
candidate block

00:55:32,319 --> 00:55:37,520
so um let me just move this down sorry

00:55:38,000 --> 00:55:38,880
um

00:55:38,880 --> 00:55:40,720
so

00:55:40,720 --> 00:55:44,079
uh if we to if i just quickly examine um

00:55:44,079 --> 00:55:45,359
the information

00:55:45,359 --> 00:55:48,079
inside here if you if you um use bitcoin

00:55:48,079 --> 00:55:50,640
cli help get block template that will

00:55:50,640 --> 00:55:52,640
show you um all the fields that will

00:55:52,640 --> 00:55:55,119
give you all the fields they'll produce

00:55:55,119 --> 00:55:57,920
um but if i just quickly

00:55:57,920 --> 00:55:59,520
um

00:55:59,520 --> 00:56:02,319
what we want to see basically to minor

00:56:02,319 --> 00:56:04,319
block is to create a block header from

00:56:04,319 --> 00:56:06,240
all these transactions

00:56:06,240 --> 00:56:09,680
so bitcoin cli get block template

00:56:09,680 --> 00:56:11,520
and i'm going to use um

00:56:11,520 --> 00:56:14,319
grep just to search for the fields that

00:56:14,319 --> 00:56:15,680
we want

00:56:15,680 --> 00:56:19,200
i'm using rg which is a variant of grep

00:56:19,200 --> 00:56:21,760
and so we want to find we want to have a

00:56:21,760 --> 00:56:22,720
version

00:56:22,720 --> 00:56:24,160
number

00:56:24,160 --> 00:56:27,599
we want the previous block

00:56:27,920 --> 00:56:30,480
then we want the merkle root

00:56:30,480 --> 00:56:31,359
um

00:56:31,359 --> 00:56:32,559
then we want

00:56:32,559 --> 00:56:33,440
time

00:56:33,440 --> 00:56:34,799
then bits

00:56:34,799 --> 00:56:36,400
then there's a nonce but

00:56:36,400 --> 00:56:37,920
we're going to provide our own nuns so

00:56:37,920 --> 00:56:39,440
we don't need that

00:56:39,440 --> 00:56:41,359
so looking at the

00:56:41,359 --> 00:56:45,000
i spelt that wrong

00:56:45,200 --> 00:56:47,520
there we are so

00:56:47,520 --> 00:56:49,280
looking at the results of block get

00:56:49,280 --> 00:56:51,200
block template it's given us the version

00:56:51,200 --> 00:56:52,960
the previous block hash it's also giving

00:56:52,960 --> 00:56:56,160
us the time current time and bits

00:56:56,160 --> 00:56:58,480
so it's changing the current time

00:56:58,480 --> 00:57:00,000
so what it's not giving us is a miracle

00:57:00,000 --> 00:57:01,440
root

00:57:01,440 --> 00:57:02,880
um

00:57:02,880 --> 00:57:05,520
for some i don't know why it's not um

00:57:05,520 --> 00:57:07,440
but what you can do

00:57:07,440 --> 00:57:12,160
um what it is giving you is um

00:57:12,160 --> 00:57:13,520
this is just a

00:57:13,520 --> 00:57:15,440
json parser

00:57:15,440 --> 00:57:17,520
it has given you um

00:57:17,520 --> 00:57:19,440
a list of

00:57:19,440 --> 00:57:20,799
transactions

00:57:20,799 --> 00:57:22,400
and it has given you all the transaction

00:57:22,400 --> 00:57:25,040
ids so if we just go through each one

00:57:25,040 --> 00:57:27,040
and say give us

00:57:27,040 --> 00:57:29,599
the transaction ids

00:57:29,599 --> 00:57:33,920
now let's need to put that in quotes

00:57:36,240 --> 00:57:37,599
there we are so these are all the

00:57:37,599 --> 00:57:39,680
transaction ids

00:57:39,680 --> 00:57:41,760
in this candidate block

00:57:41,760 --> 00:57:43,200
so now we've got all those transaction

00:57:43,200 --> 00:57:44,400
ids we just need to create our own

00:57:44,400 --> 00:57:46,480
merkle route for them

00:57:46,480 --> 00:57:47,200
so

00:57:47,200 --> 00:57:49,839
um luckily i've written my own script

00:57:49,839 --> 00:57:51,760
and that will take in a list of

00:57:51,760 --> 00:57:53,599
transactions and create a miracle route

00:57:53,599 --> 00:57:55,359
from them

00:57:55,359 --> 00:57:56,960
um i've made this available on the

00:57:56,960 --> 00:57:58,960
website i'll show it in the moment

00:57:58,960 --> 00:58:00,720
so if i just do that

00:58:00,720 --> 00:58:02,880
then we have a miracle root

00:58:02,880 --> 00:58:05,839
so now um we've got all the data we need

00:58:05,839 --> 00:58:07,280
to mine a

00:58:07,280 --> 00:58:08,799
both or basically to construct a block

00:58:08,799 --> 00:58:10,640
header

00:58:10,640 --> 00:58:12,480
so if you just bare with me for five

00:58:12,480 --> 00:58:14,400
minutes i'm gonna go through each field

00:58:14,400 --> 00:58:16,079
and um

00:58:16,079 --> 00:58:18,720
yeah so first of all uh we need to get

00:58:18,720 --> 00:58:20,640
the version

00:58:20,640 --> 00:58:23,119
oh that's done wrong

00:58:23,119 --> 00:58:25,200
okay

00:58:25,200 --> 00:58:27,440
so there we are using get a get block

00:58:27,440 --> 00:58:29,119
template this is the current version uh

00:58:29,119 --> 00:58:32,079
like i said they've changed a bit so um

00:58:32,079 --> 00:58:33,040
this is

00:58:33,040 --> 00:58:34,640
they've been used to vote for voting so

00:58:34,640 --> 00:58:36,960
this is why it's a very high number but

00:58:36,960 --> 00:58:38,160
i'm not going to spend it now just take

00:58:38,160 --> 00:58:39,680
it as it is

00:58:39,680 --> 00:58:40,480
um

00:58:40,480 --> 00:58:41,920
so this is the version number but

00:58:41,920 --> 00:58:44,559
obviously it's in uh decimal so to

00:58:44,559 --> 00:58:46,240
convert that into

00:58:46,240 --> 00:58:49,440
hexadecimal first first so there we are

00:58:49,440 --> 00:58:50,400
and then

00:58:50,400 --> 00:58:52,480
now it's in hexadecimal this is already

00:58:52,480 --> 00:58:54,559
um four bytes

00:58:54,559 --> 00:58:57,119
so i just swap the byte order or swap

00:58:57,119 --> 00:58:59,920
the endianness because sometimes

00:58:59,920 --> 00:59:01,280
um

00:59:01,280 --> 00:59:03,119
the byte order is referred to referred

00:59:03,119 --> 00:59:05,359
to as endianness

00:59:05,359 --> 00:59:06,720
um

00:59:06,720 --> 00:59:09,359
so there we are so this is the

00:59:09,359 --> 00:59:10,160
uh

00:59:10,160 --> 00:59:12,480
version all set up and ready to go so

00:59:12,480 --> 00:59:13,599
i'll just

00:59:13,599 --> 00:59:15,119
trim the end off that

00:59:15,119 --> 00:59:16,640
because i'm going to concatenate it all

00:59:16,640 --> 00:59:20,160
together so if i save this as a

00:59:20,160 --> 00:59:22,640
variable

00:59:25,680 --> 00:59:26,880
there we have so just

00:59:26,880 --> 00:59:29,359
echo that out to check

00:59:29,359 --> 00:59:31,520
so that's the version done so next up

00:59:31,520 --> 00:59:33,839
after the version is the

00:59:33,839 --> 00:59:37,520
version previous block

00:59:37,599 --> 00:59:39,599
so previous block

00:59:39,599 --> 00:59:40,799
hash

00:59:40,799 --> 00:59:42,559
so this is the block hash for the

00:59:42,559 --> 00:59:44,559
previous block

00:59:44,559 --> 00:59:47,119
let me just trim off the

00:59:47,119 --> 00:59:49,520
uh quotes

00:59:49,520 --> 00:59:51,040
and then

00:59:51,040 --> 00:59:52,640
uh it's already in hex decimal it's

00:59:52,640 --> 00:59:55,440
already 32 bytes so what i need to do is

00:59:55,440 --> 00:59:57,680
sort the byte order or put it into

00:59:57,680 --> 00:59:59,040
little endian

00:59:59,040 --> 01:00:01,760
so there we are and then i can save this

01:00:01,760 --> 01:00:03,599
then

01:00:03,599 --> 01:00:07,200
as the previous block variable

01:00:11,119 --> 01:00:15,040
next up then is the miracle root

01:00:15,040 --> 01:00:16,000
uh

01:00:16,000 --> 01:00:18,400
obviously we don't get a miracle root

01:00:18,400 --> 01:00:21,359
um from the get block template um

01:00:21,359 --> 01:00:23,839
command but what does give us is the

01:00:23,839 --> 01:00:25,440
list of transactions

01:00:25,440 --> 01:00:28,559
and for each of those it will give us um

01:00:28,559 --> 01:00:30,480
a transaction id

01:00:30,480 --> 01:00:31,440
oops

01:00:31,440 --> 01:00:33,599
oh well i just lost that

01:00:33,599 --> 01:00:35,280
oh there it is

01:00:35,280 --> 01:00:37,440
so there we go

01:00:37,440 --> 01:00:41,760
and from these i can get the merkle root

01:00:41,760 --> 01:00:44,000
there we are and then it's already in

01:00:44,000 --> 01:00:46,079
hexadecimal it's already in

01:00:46,079 --> 01:00:48,079
32 bytes i just need to sort the byte

01:00:48,079 --> 01:00:49,599
order

01:00:49,599 --> 01:00:50,960
again

01:00:50,960 --> 01:00:52,960
uh there we are i'll save that as a

01:00:52,960 --> 01:00:54,240
variable

01:00:54,240 --> 01:00:56,799
i'm going to call

01:00:58,640 --> 01:01:00,559
nearly there i know it's a bit laborious

01:01:00,559 --> 01:01:03,680
but uh so that's yeah so version

01:01:03,680 --> 01:01:05,920
previous block miracle root uh then we

01:01:05,920 --> 01:01:07,040
have the time

01:01:07,040 --> 01:01:08,839
um for some reason

01:01:08,839 --> 01:01:10,480
um

01:01:10,480 --> 01:01:12,640
even though the get plot template

01:01:12,640 --> 01:01:14,000
doesn't give you the merkel route it

01:01:14,000 --> 01:01:15,119
does give you

01:01:15,119 --> 01:01:17,520
the current time on your computer

01:01:17,520 --> 01:01:19,280
um

01:01:19,280 --> 01:01:21,200
actually it gives you a

01:01:21,200 --> 01:01:24,880
valid time i'm not sure if this is um

01:01:24,880 --> 01:01:25,839
i don't know but this is definitely a

01:01:25,839 --> 01:01:27,760
valid time but what you could do if you

01:01:27,760 --> 01:01:29,440
want to use that if you want to use the

01:01:29,440 --> 01:01:30,480
get blocked

01:01:30,480 --> 01:01:32,079
template time you can use the date

01:01:32,079 --> 01:01:34,400
function from a programming language

01:01:34,400 --> 01:01:36,240
so if you just this gives you the number

01:01:36,240 --> 01:01:37,599
of seconds

01:01:37,599 --> 01:01:39,680
in unix times if i just use that

01:01:39,680 --> 01:01:42,799
um just need to get it into hexadecimal

01:01:42,799 --> 01:01:44,000
like so

01:01:44,000 --> 01:01:46,720
one two three four five six seven so 24

01:01:46,720 --> 01:01:47,920
bytes

01:01:47,920 --> 01:01:48,799
uh

01:01:48,799 --> 01:01:51,960
then we

01:01:52,079 --> 01:01:53,599
it to and

01:01:53,599 --> 01:01:56,319
uh reverse bite order

01:01:56,319 --> 01:01:58,160
there we are so there is that's the time

01:01:58,160 --> 01:01:59,040
ready

01:01:59,040 --> 01:02:00,799
enough

01:02:00,799 --> 01:02:02,240
and

01:02:02,240 --> 01:02:04,480
that's the time done

01:02:04,480 --> 01:02:07,440
lastly uh bits

01:02:07,440 --> 01:02:09,119
which is the compact version of the

01:02:09,119 --> 01:02:11,359
target

01:02:11,359 --> 01:02:14,079
there it is you just trim off the

01:02:14,079 --> 01:02:16,240
uh

01:02:16,960 --> 01:02:18,079
quotes

01:02:18,079 --> 01:02:21,839
and then put into reverse byte order

01:02:22,400 --> 01:02:24,720
and there it is so now we've got all the

01:02:24,720 --> 01:02:28,160
basic block header data

01:02:28,160 --> 01:02:29,200
uh

01:02:29,200 --> 01:02:31,599
ready

01:02:32,160 --> 01:02:36,160
in the right format so if i

01:02:36,160 --> 01:02:38,240
just construct the block header from

01:02:38,240 --> 01:02:39,839
each individ each of those individual

01:02:39,839 --> 01:02:40,960
fields

01:02:40,960 --> 01:02:43,359
that is the version

01:02:43,359 --> 01:02:46,799
the previous block

01:02:46,839 --> 01:02:50,400
the miracle root

01:02:50,400 --> 01:02:52,000
then

01:02:52,000 --> 01:02:53,119
time

01:02:53,119 --> 01:02:55,280
and then bits

01:02:55,280 --> 01:02:58,640
so check what that looks like

01:02:58,960 --> 01:03:00,640
there it is there's our block header and

01:03:00,640 --> 01:03:02,480
so all we have all we haven't put there

01:03:02,480 --> 01:03:04,160
now is the nonce

01:03:04,160 --> 01:03:05,040
so

01:03:05,040 --> 01:03:06,960
if we wanted to

01:03:06,960 --> 01:03:08,960
mine this we just need to create a loop

01:03:08,960 --> 01:03:10,079
that will

01:03:10,079 --> 01:03:12,400
keep hashing this

01:03:12,400 --> 01:03:13,280
uh

01:03:13,280 --> 01:03:15,520
block header and we'll adjust the nonce

01:03:15,520 --> 01:03:17,599
increment it with every attempt

01:03:17,599 --> 01:03:20,480
so the nonce um will look like we'll

01:03:20,480 --> 01:03:22,640
start off with zero

01:03:22,640 --> 01:03:24,000
um but obviously we need to get this in

01:03:24,000 --> 01:03:25,920
the right format um so we need to

01:03:25,920 --> 01:03:28,839
convert that to um

01:03:28,839 --> 01:03:30,960
uh extradition

01:03:30,960 --> 01:03:32,240
sorry thank you

01:03:32,240 --> 01:03:36,319
uh then at least so like so

01:03:37,119 --> 01:03:38,880
uh but obviously this needs to be um

01:03:38,880 --> 01:03:40,640
four bytes in length so i made a little

01:03:40,640 --> 01:03:42,000
function that will just make sure it's

01:03:42,000 --> 01:03:43,359
the right size

01:03:43,359 --> 01:03:45,280
and then convert the swap end in

01:03:45,280 --> 01:03:46,720
obviously it's not very interesting

01:03:46,720 --> 01:03:48,559
because i've used the number zero but if

01:03:48,559 --> 01:03:50,000
i wish to use like a much higher nonce

01:03:50,000 --> 01:03:50,960
value

01:03:50,960 --> 01:03:52,559
uh like that

01:03:52,559 --> 01:03:55,039
then like so it's prepared it for me

01:03:55,039 --> 01:03:56,319
so i'm not going to append this to it

01:03:56,319 --> 01:03:57,440
yet what i'm going to do i'm going to

01:03:57,440 --> 01:04:00,640
create a loop so while true

01:04:00,640 --> 01:04:02,000
do

01:04:02,000 --> 01:04:03,760
you want to

01:04:03,760 --> 01:04:05,440
oh wait there before that i want to set

01:04:05,440 --> 01:04:08,400
a variable to

01:04:08,400 --> 01:04:11,680
an increment incremented variable ready

01:04:11,680 --> 01:04:14,559
so while true

01:04:14,559 --> 01:04:15,599
uh

01:04:15,599 --> 01:04:16,960
do

01:04:16,960 --> 01:04:18,079
want to

01:04:18,079 --> 01:04:19,760
create the nonce

01:04:19,760 --> 01:04:21,839
which is going to be like i just showed

01:04:21,839 --> 01:04:23,280
you um

01:04:23,280 --> 01:04:25,039
echo

01:04:25,039 --> 01:04:26,400
i

01:04:26,400 --> 01:04:28,960
uh they want to get it in deck

01:04:28,960 --> 01:04:31,039
hex decimal

01:04:31,039 --> 01:04:34,559
four byte field size swap endian

01:04:34,559 --> 01:04:35,359
uh

01:04:35,359 --> 01:04:37,760
trim off the end

01:04:37,760 --> 01:04:39,440
uh so that's the non stun

01:04:39,440 --> 01:04:42,319
then our attempt at

01:04:42,319 --> 01:04:44,319
trying to mine the block will be just

01:04:44,319 --> 01:04:45,280
the

01:04:45,280 --> 01:04:48,000
uh block header we created

01:04:48,000 --> 01:04:51,039
plus the nonce at the end

01:04:51,039 --> 01:04:52,160
and then what we want to do is we want

01:04:52,160 --> 01:04:53,440
to hash that

01:04:53,440 --> 01:04:55,039
um all together so i've made a little

01:04:55,039 --> 01:04:57,760
function that will hash for me um

01:04:57,760 --> 01:05:00,319
called hash 256 because this

01:05:00,319 --> 01:05:02,480
is just the the double hash converts the

01:05:02,480 --> 01:05:04,480
binary then double hashes it i'm going

01:05:04,480 --> 01:05:08,960
to hash 256 um the attempt

01:05:08,960 --> 01:05:09,839
and

01:05:09,839 --> 01:05:12,400
every after every attempt we want to

01:05:12,400 --> 01:05:15,920
uh increment the nonce so let

01:05:15,920 --> 01:05:18,559
uh i must plus so just increment the

01:05:18,559 --> 01:05:20,559
notes from

01:05:20,559 --> 01:05:21,680
this

01:05:21,680 --> 01:05:23,760
number here actually

01:05:23,760 --> 01:05:25,599
uh and then done so hopefully this will

01:05:25,599 --> 01:05:27,920
work there we are so now

01:05:27,920 --> 01:05:30,240
this is hashing

01:05:30,240 --> 01:05:31,200
um

01:05:31,200 --> 01:05:33,839
very slowly uh a block header the

01:05:33,839 --> 01:05:36,000
current block header obviously it's very

01:05:36,000 --> 01:05:37,680
slow it took me a long time but this is

01:05:37,680 --> 01:05:40,559
actually mine trying to mine a block

01:05:40,559 --> 01:05:42,319
um

01:05:42,319 --> 01:05:44,000
so if that was

01:05:44,000 --> 01:05:44,960
lucky

01:05:44,960 --> 01:05:46,400
what you'd probably do you'd have some

01:05:46,400 --> 01:05:48,480
code in there that would stop

01:05:48,480 --> 01:05:51,119
um when you if yeah if it reaches the

01:05:51,119 --> 01:05:52,799
target target yeah and then what you do

01:05:52,799 --> 01:05:55,839
then there's a function and bitcoin cli

01:05:55,839 --> 01:05:59,280
called um submit block

01:05:59,520 --> 01:06:01,760
and you would just submit

01:06:01,760 --> 01:06:05,839
the header the transaction count

01:06:06,400 --> 01:06:08,960
and all the transaction data so if you

01:06:08,960 --> 01:06:10,799
constructed a successful block header

01:06:10,799 --> 01:06:12,000
you would send that to all the nodes

01:06:12,000 --> 01:06:13,760
you're connected to and you'd use that

01:06:13,760 --> 01:06:15,280
do that using the

01:06:15,280 --> 01:06:17,280
submit block um

01:06:17,280 --> 01:06:19,599
bitcoin cli command

01:06:19,599 --> 01:06:21,839
is there a way to uh get the target

01:06:21,839 --> 01:06:24,559
value from the bitcoin cli

01:06:24,559 --> 01:06:27,039
uh yeah so um i think it's included in

01:06:27,039 --> 01:06:31,680
um bitcoin cli get block template

01:06:31,680 --> 01:06:35,119
yeah so um i think it's it's

01:06:35,119 --> 01:06:36,480
extending the block

01:06:36,480 --> 01:06:37,520
yeah so there it is so this is the

01:06:37,520 --> 01:06:39,599
current target so you could grab that

01:06:39,599 --> 01:06:42,160
target and then stick that summer into

01:06:42,160 --> 01:06:44,079
yeah into the for loop

01:06:44,079 --> 01:06:46,480
yeah but obviously um

01:06:46,480 --> 01:06:48,400
that that hashing there was very very

01:06:48,400 --> 01:06:49,200
slow

01:06:49,200 --> 01:06:51,599
oh yeah yeah i i totally get it yeah you

01:06:51,599 --> 01:06:53,200
probably want to do that yeah

01:06:53,200 --> 01:06:55,039
in a single programming language this is

01:06:55,039 --> 01:06:57,280
just on bash just for quick sort of

01:06:57,280 --> 01:06:58,960
illustration purposes but that just goes

01:06:58,960 --> 01:07:01,520
to show like how basically how simple uh

01:07:01,520 --> 01:07:03,599
mining is really the hardest part is

01:07:03,599 --> 01:07:05,520
just getting the data in the right order

01:07:05,520 --> 01:07:07,440
um but after that it's just you just

01:07:07,440 --> 01:07:09,680
increment a nonsense hash it and

01:07:09,680 --> 01:07:11,119
hopefully you get a result a lucky

01:07:11,119 --> 01:07:14,119
result

01:07:14,319 --> 01:07:15,760
um

01:07:15,760 --> 01:07:18,480
i think yeah so that's everything i

01:07:18,480 --> 01:07:21,039
wanted to explain about how mining works

01:07:21,039 --> 01:07:22,480
um

01:07:22,480 --> 01:07:23,839
that's all the technical stuff but

01:07:23,839 --> 01:07:25,119
obviously is

01:07:25,119 --> 01:07:27,440
probably a lot simpler than it's made

01:07:27,440 --> 01:07:29,760
out to be

01:07:29,760 --> 01:07:30,559
um

01:07:30,559 --> 01:07:32,400
on the website i've made all this code

01:07:32,400 --> 01:07:35,119
available so each those little um hex

01:07:35,119 --> 01:07:36,640
decimal converters and decimal

01:07:36,640 --> 01:07:37,760
converters

01:07:37,760 --> 01:07:40,960
and the swap endianness they're all here

01:07:40,960 --> 01:07:42,559
there's a miracle root function on here

01:07:42,559 --> 01:07:44,240
written in php

01:07:44,240 --> 01:07:46,960
um it's not the prettiest um but it will

01:07:46,960 --> 01:07:48,160
take a

01:07:48,160 --> 01:07:49,200
list of

01:07:49,200 --> 01:07:50,880
transaction ids and create american

01:07:50,880 --> 01:07:52,400
route for you

01:07:52,400 --> 01:07:54,400
i might not want to use it in production

01:07:54,400 --> 01:07:55,599
you might want to use a different

01:07:55,599 --> 01:07:57,760
library i'm sure there's loads of

01:07:57,760 --> 01:07:59,039
bitcoin libraries out there with their

01:07:59,039 --> 01:08:01,520
own merkle root um functions for you to

01:08:01,520 --> 01:08:03,760
use

01:08:04,559 --> 01:08:05,760
um

01:08:05,760 --> 01:08:07,760
is there any questions about

01:08:07,760 --> 01:08:09,920
that sort of mining process no i mean

01:08:09,920 --> 01:08:11,520
this this was really awesome great

01:08:11,520 --> 01:08:13,200
thanks a lot

01:08:13,200 --> 01:08:15,359
uh

01:08:16,000 --> 01:08:18,479
just curious any any experience with

01:08:18,479 --> 01:08:21,198
those heavy duty miners

01:08:21,198 --> 01:08:23,198
no i've not actually mined myself

01:08:23,198 --> 01:08:25,359
because like we said like it's so

01:08:25,359 --> 01:08:27,120
inefficient to mine on your laptop if

01:08:27,120 --> 01:08:28,960
you wanted to mine now it's not a hobby

01:08:28,960 --> 01:08:30,399
thing you have to sort of

01:08:30,399 --> 01:08:33,120
you know buy a professional mining rig

01:08:33,120 --> 01:08:34,640
and run it like a proper business which

01:08:34,640 --> 01:08:37,040
is a shame because that takes mining out

01:08:37,040 --> 01:08:38,880
of the hands of the average person then

01:08:38,880 --> 01:08:40,560
so

01:08:40,560 --> 01:08:41,920
um

01:08:41,920 --> 01:08:43,359
yeah so i think if you want to get into

01:08:43,359 --> 01:08:44,880
mind you you would have to really commit

01:08:44,880 --> 01:08:46,319
to it

01:08:46,319 --> 01:08:48,238
it's not just right gone yeah right

01:08:48,238 --> 01:08:50,080
right even those guys would be doing

01:08:50,080 --> 01:08:51,759
like at a fundamental level they would

01:08:51,759 --> 01:08:53,759
be doing the same thing right just

01:08:53,759 --> 01:08:54,799
faster

01:08:54,799 --> 01:08:56,158
yes so they're just doing the exact same

01:08:56,158 --> 01:08:57,600
thing constructing block header and just

01:08:57,600 --> 01:08:58,960
hashing it as fast as you can like this

01:08:58,960 --> 01:09:00,560
whole construction of the block header

01:09:00,560 --> 01:09:02,880
is simple and takes a

01:09:02,880 --> 01:09:05,359
absolute fraction of a second to do and

01:09:05,359 --> 01:09:08,080
then the whole mining then the whole

01:09:08,080 --> 01:09:10,080
meat of mining is hashing as fast as

01:09:10,080 --> 01:09:12,400
possible

01:09:13,600 --> 01:09:14,000
um

01:09:14,000 --> 01:09:15,359
[Music]

01:09:15,359 --> 01:09:16,640
i think i've

01:09:16,640 --> 01:09:18,238
don't think i've missed anything i think

01:09:18,238 --> 01:09:19,839
i've covered everything i wanted to

01:09:19,839 --> 01:09:21,759
sorry i know that's a bit repetitive in

01:09:21,759 --> 01:09:24,960
parts uh no no no this was a great

01:09:24,960 --> 01:09:26,960
explanation again yeah thanks a lot for

01:09:26,960 --> 01:09:28,000
this yeah

01:09:28,000 --> 01:09:29,600
but i think if you're starting out with

01:09:29,600 --> 01:09:31,679
bitcoin um

01:09:31,679 --> 01:09:33,279
one of the best ways to learn i think is

01:09:33,279 --> 01:09:34,880
to try and

01:09:34,880 --> 01:09:36,479
mine your own block header i think it's

01:09:36,479 --> 01:09:38,158
quite simple to do and i think mining is

01:09:38,158 --> 01:09:40,000
one of the sort of first fundamental

01:09:40,000 --> 01:09:41,839
parts of how bitcoin works so if you can

01:09:41,839 --> 01:09:44,479
figure out how to mine a block header

01:09:44,479 --> 01:09:46,158
or hash a block header that's a great

01:09:46,158 --> 01:09:47,839
stepping stone i'll give you the tools

01:09:47,839 --> 01:09:50,158
then to figure out about the all the um

01:09:50,158 --> 01:09:52,960
hexadecimal and network byte order and

01:09:52,960 --> 01:09:54,960
how to hash and then you can take those

01:09:54,960 --> 01:09:56,560
tools then and use them in other parts

01:09:56,560 --> 01:09:58,000
of bitcoin like in you know with

01:09:58,000 --> 01:10:01,040
transactions and all that

01:10:01,040 --> 01:10:02,719
so this would be my first place to start

01:10:02,719 --> 01:10:04,960
if you were to try coding with

01:10:04,960 --> 01:10:06,000
bitcoin

01:10:06,000 --> 01:10:07,600
i mean you you're obviously probably not

01:10:07,600 --> 01:10:08,560
going to

01:10:08,560 --> 01:10:10,560
set up your minor but as a sort of

01:10:10,560 --> 01:10:11,679
learning experience this is a great

01:10:11,679 --> 01:10:14,320
place to start

01:10:15,280 --> 01:10:17,199
so yeah if you want to browse block

01:10:17,199 --> 01:10:18,880
headers just go into livia bitcoin this

01:10:18,880 --> 01:10:20,560
is the blockchain

01:10:20,560 --> 01:10:21,920
and you can browse to each individual

01:10:21,920 --> 01:10:23,600
block and see all the different block

01:10:23,600 --> 01:10:25,520
headers and test for yourself

01:10:25,520 --> 01:10:27,520
then you can get the same

01:10:27,520 --> 01:10:28,960
block cache results

01:10:28,960 --> 01:10:31,280
nice

01:10:31,280 --> 01:10:32,400
yep

01:10:32,400 --> 01:10:35,280
so uh thank you very much for that uh

01:10:35,280 --> 01:10:37,120
that was good to do

01:10:37,120 --> 01:10:38,320
thanks

01:10:38,320 --> 01:10:42,520
no worries so yeah