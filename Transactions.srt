
00:00:00,230 --> 00:00:06,210
所以在这节课中，我将介绍比特币交易，它们是如何基本的工作。

00:00:06,210 --> 00:00:11,580
所以，希望在演讲结束后，你能理解交易是如何进行的，

00:00:11,580 --> 00:00:14,219
它们看起来是什么样的，

00:00:14,219 --> 00:00:18,510
以及如何构建你自己的交易。

00:00:18,510 --> 00:00:20,130
所以我像上次一样将这个演讲分成了三个部分，

00:00:20,130 --> 00:00:23,519
我将从比特币交易的基础开始，

00:00:23,519 --> 00:00:27,359
我将解释它们看起来是什么样的，数据是如何表示的，等等。

00:00:27,359 --> 00:00:28,920
我将叙述你需要知道的关于交易结构和它们如何工作的所有内容。

00:00:28,920 --> 00:00:33,300
在那之后，我将介绍数据。

00:00:33,300 --> 00:00:37,440
不仅仅是给你一个交易实际做什么的视觉表示，

00:00:37,440 --> 00:00:40,379
我还将展示它们的数据。

00:00:40,379 --> 00:00:43,680
所以，而不仅仅是给你一个交易实际做什么的视觉表示，

00:00:43,680 --> 00:00:46,340
我将展示它们的数据。

00:00:46,340 --> 00:00:50,100
如果你们要看实际的，我将向你们展示数据是如何描述它的以及它是如何工作的。

00:00:50,100--> 00:00:55,289
等我讲完之后你就会知道它们是怎么工作的，数据是什么样子的。

00:00:50,100 --> 00:00:52,020
所以，如果你看一下实际的交易，我会向你展示数据是如何

00:00:52,020 --> 00:00:58,590
我会向你展示数据是如何描述和工作的，

00:00:58,590 --> 00:01:01,680
在我解释了它们的工作原理和数据外观后，

00:01:01,680 --> 00:01:04,229
我会开始做一些例子，

00:01:04,229 --> 00:01:07,049
所以我会从头开始构建一个交易，

00:01:07,049 --> 00:01:11,159
只是为了向你展示如何创建你自己的比特币交易，

00:01:11,159 --> 00:01:16,799
所以，是的，我现在开始第一部分，

00:01:16,799 --> 00:01:28,020
所以，我现在开始讲解比特币交易的基础知识，接着上面的内容。

00:01:28,020 --> 00:01:30,840
如果你还记得，

00:01:30,840 --> 00:01:34,350
这些计算机中的每一台都代表了网络上的一个比特币节点，

00:01:34,350 --> 00:01:36,090
这就是整个网络，它们共享的是这个叫做区块链的文件。

00:01:36,090 --> 00:01:37,920
所以，当你想进行交易，

00:01:37,920 --> 00:01:41,210
给某人发送一些钱时，

00:01:41,210 --> 00:01:46,799
你需要做的就是创建一行数据。

00:01:46,799 --> 00:01:57,250
这个小绿线代表了一个比特币交易，它只是一堆数据。

00:01:57,250 --> 00:02:00,280
你可以将这个数据插入到网络上的任何节点，

00:02:00,280 --> 00:02:04,000
然后它们会将其存储在它们的内存池中，

00:02:04,000 --> 00:02:09,399
并将其传递给它们连接的节点，

00:02:09,399 --> 00:02:12,340
如此反复，

00:02:12,340 --> 00:02:16,450
直到每个人都在他们的内存池中拷贝了这个交易。

00:02:16,450 --> 00:02:27,370
然后，所有这些节点将竞争尝试从他们的内存池中挖掘交易到这个叫做区块链的文件。

00:02:27,370 --> 00:02:29,709
假设这个节点成功了，

00:02:29,709 --> 00:02:32,260
挖掘完成后，

00:02:32,260 --> 00:02:33,550
它会将挖掘到的区块传递给它连接的其他节点，

00:02:33,550 --> 00:02:35,500
他们会将其添加到他们的区块链中，

00:02:35,500 --> 00:02:37,800
如此反复过程，

00:02:37,800 --> 00:02:41,110
直到所有节点都添加了这个区块。

00:02:41,110 --> 00:02:44,890
当这个区块被添加到他们的文件时，

00:02:44,890 --> 00:02:47,350
可以查看这个区块链并看到其中的交易，

00:02:47,350 --> 00:02:48,820
因为这个交易现在是区块链的一部分，

00:02:48,820 --> 00:02:55,600
这个比特币的所有权已经从这个人转移到了这个人。

00:02:55,600 --> 00:02:58,090
所以今天我要讲的是，

00:02:58,090 --> 00:03:03,370
这个过程是如何工作的，

00:03:03,370 --> 00:03:08,440
你如何创建这样一行数据，

00:03:08,440 --> 00:03:16,209
以及这如何表示比特币所有权的转移。

00:03:16,209 --> 00:03:19,870
让我们看看比特币交易的基础。

00:03:19,870 --> 00:03:21,750
这条绿线代表了数据，

00:03:21,750 --> 00:03:28,600
它将把这个比特币的所有权从我转移到你。

00:03:28,600 --> 00:03:30,940
如果我放大这个绿线，

00:03:30,940 --> 00:03:32,470
它依然代表交易数据。

00:03:32,470 --> 00:03:34,000
我还不打算向你展示数据，

00:03:34,000 --> 00:03:41,350
这只是实际数据的简单表示。

00:03:35,110 --> 00:03:41,350
首先，这是区块链，

00:03:41,350 --> 00:03:47,950
假设这代表着从上次的延续下来的区块链。

00:03:47,950 --> 00:03:50,290
从上次的演示中我们知道，

00:03:50,290 --> 00:03:54,040
它只是一堆包含交易的区块。

00:03:54,040 --> 00:04:00,150
所以区块链就是一个大型的交易数据文件。

00:04:00,150 --> 00:04:05,069
我们今天要看的是交易，

00:04:05,069 --> 00:04:10,530
是一种很好的方式来可视化区块链中的交易数据，

00:04:07,530 --> 00:04:10,530
区块链是一堆不同批次的比特币，所以每一批都是这样。

00:04:10,530 --> 00:04:13,230
所以每一批都是这样。

00:04:13,230 --> 00:04:21,570
所以这里的每一个小橙色的盒子代表一个独立的比特币批次，

00:04:21,570 --> 00:04:26,040
每一个比特币批次都有一个锁在上面，

00:04:26,040 --> 00:04:31,530
这就是人们可以安全拥有比特币的原因，

00:04:31,530 --> 00:04:33,270
因为只有能解锁它们的人才能够花费它们，

00:04:33,270 --> 00:04:35,550
把它们发送给别人。

00:04:35,550 --> 00:04:39,030
所以基本上，你可以想象一下区块链像什么，

00:04:39,030 --> 00:04:41,520
就是一堆像银行里的那样的锁箱，

00:04:41,520 --> 00:04:49,440
里面装的都是不同数量的比特币。

00:04:49,440 --> 00:04:52,770
现在我要构建一个交易，

00:04:52,770 --> 00:04:54,169
把比特币从我这里转移到你那里。

00:04:54,169 --> 00:04:59,400
如果我要构建一个交易，

00:04:59,400 --> 00:05:00,840
在数据的第一部分，

00:05:00,840 --> 00:05:02,880
我们会从区块链中选择一批比特币，

00:05:02,880 --> 00:05:08,580
每一批比特币都有它们自己的唯一参考编码，

00:05:08,580 --> 00:05:10,380
所以你可以选择它们。

00:05:10,380 --> 00:05:12,720
所以在这个第一部分，

00:05:12,720 --> 00:05:16,260
你会选择一批比特币。

00:05:16,260 --> 00:05:17,850
我在这里放一些参考代码。

00:05:17,850 --> 00:05:19,530
选择你想要发送的比特币批次，

00:05:19,530 --> 00:05:29,220
这第一部分的第二半部分，

00:05:29,220 --> 00:05:33,300
你需要能够解锁这批比特币，

00:05:33,300 --> 00:05:38,760
你要做的是输入一些解锁代码或者使用你的私钥

00:05:38,760 --> 00:05:44,940
来证明你可以解锁这个比特币批次，

00:05:44,940 --> 00:05:47,010
前一半完成后，

00:05:47,010 --> 00:05:49,110
你只需要选择一批比特币并解锁它们，

00:05:49,110 --> 00:05:54,630
然后后一半的交易你只需创建一批新的比特币，

00:05:54,630 --> 00:05:57,240
并在第二部分中为其上锁。

00:05:57,240 --> 00:05:59,340
这是原来的比特币批次，

00:05:59,340 --> 00:06:01,800
它被锁定给我们，

00:06:01,800 --> 00:06:04,800
在这个交易中，

00:06:04,800 --> 00:06:07,440
我们打开了这个批次，

00:06:07,440 --> 00:06:10,530
从中创建了一个新的批次，

00:06:10,530 --> 00:06:14,649
并在上面放了一个新的锁。

00:06:14,649 --> 00:06:17,349
这个锁是锁定给这个人的地址，就像一个账号。

00:06:17,349 --> 00:06:21,519
所以这是一个非常简单的交易，

00:06:21,519 --> 00:06:23,979
只是选择一些比特币

00:06:23,979 --> 00:06:26,709
解锁它们，创建一个新的批次，

00:06:26,709 --> 00:06:29,109
上一个新的锁，并将它们锁定给这个人。

00:06:29,109 --> 00:06:34,299
并将它们锁定给这个人。

00:06:34,299 --> 00:06:37,209
所以当你想要进行交易时，

00:06:37,209 --> 00:06:39,069
最好不要把它想象成拥有一些比特币，

00:06:39,069 --> 00:06:40,719
然后通过互联网转给别人，

00:06:40,719 --> 00:06:41,979
这不是真正的交易工作方式。

00:06:41,979 --> 00:06:44,559
真正发生的是，

00:06:44,559 --> 00:06:47,349
你有一套密钥，如地址和私钥，

00:06:47,349 --> 00:06:49,719
别人也有他们自己的地址和私钥，

00:06:49,719 --> 00:06:53,979
当你想要发送给他们一些比特币时，

00:06:51,729 --> 00:06:53,979
你只需进入区块链，

00:06:53,979 --> 00:06:58,419
选择你可以用你的私钥解锁的比特币批次，

00:06:58,419 --> 00:07:00,159
锁定到对方的地址，

00:07:00,159 --> 00:07:06,099
这样他们就可以用他们的私钥将它们发送出去。

00:07:06,0999 --> 00:07:12,129
这样他们就可以用他们的私钥将它们发送出去。

00:07:12,129 --> 00:07:13,449
例如，

00:07:13,449 --> 00:07:15,069
如果他们想要将这批比特币发送给别人，

00:07:15,069 --> 00:07:16,689
他们只需使用他们的私钥解锁我们为他们创建的这个特定的锁，

00:07:16,689 --> 00:07:18,339
然后他们就可以发送出去。

00:07:18,339 --> 00:07:26,469
所以你可以看到比特币形成了这样一个交易链，

00:07:26,469 --> 00:07:31,569
从一个人传递到另一个人。

00:07:31,569 --> 00:07:33,999
到目前为止，

00:07:33,999 --> 00:07:36,459
我一直把这些比特币的批次称为比特币，

00:07:36,459 --> 00:07:37,929
但它们的技术术语是输出，

00:07:37,929 --> 00:07:40,569
所以从现在开始，

00:07:40,569 --> 00:07:43,329
我将使用“输出”这个词来描述这些比特币的批次。

00:07:43,329 --> 00:07:45,159
显然，所有这些批次都被称为输出，

00:07:45,159 --> 00:07:48,639
这就是所有这些橙色框框里的东西，都是输出。

00:07:48,639 --> 00:07:54,879
但是要明确的是，

00:07:54,879 --> 00:07:57,239
当我们在交易中花费一个输出时

00:07:57,239 --> 00:08:00,609
我们称之为输入。

00:08:00,609 --> 00:08:02,849
所以每一笔交易都会消耗一个输入，

00:08:02,849 --> 00:08:10,110
并创建一个新的输出。

00:08:10,110 --> 00:08:12,300
然后，我们将这笔交易发送到比特币网络中，

00:08:12,300 --> 00:08:15,509
希望它能被挖掘到区块链上的一个区块中。

00:08:15,509 --> 00:08:17,190
假设这是一个新的交易区块，

00:08:17,190 --> 00:08:20,910
这是我们的交易被挖掘到区块链上的情况。

00:08:20,910 --> 00:08:23,400
如果我们将刚刚发生的事情可视化，

00:08:23,400 --> 00:08:28,139
我们花费了这个输出，

00:08:28,139 --> 00:08:29,699
所以我将其灰色化，

00:08:29,699 --> 00:08:31,470
它不能再被花费了。

00:08:31,470 --> 00:08:35,250
在这个新的区块中，

00:08:35,250 --> 00:08:37,380
由于我的交易，

00:08:37,380 --> 00:08:41,070
我创建了这个新的输出，

00:08:41,070 --> 00:08:42,750
这个新的输出属于这个人。

00:08:42,750 --> 00:08:49,470
所以这就是交易在非常基本的层面上是如何工作的。

00:08:49,470 --> 00:08:51,420
在最后一个例子中，

00:08:51,420 --> 00:08:54,300
我发送了一个整批的比特币，

00:08:54,300 --> 00:08:57,060
我花费了一个整批的比特币，

00:08:57,060 --> 00:08:59,490
并创建了十个比特币作为我要发送的金额。

00:08:59,490 --> 00:09:02,250
但是你实际上并不需要使用整批的比特币，

00:09:02,250 --> 00:09:04,920
如果你想发送的比特币少于十个，

00:09:04,920 --> 00:09:06,839
那么你可以这样做，

00:09:06,839 --> 00:09:08,820
你可以创建一个输出，

00:09:08,820 --> 00:09:11,459
你创建一个输出，

00:09:11,459 --> 00:09:14,580
向某人发送10-8，

00:09:14,580 --> 00:09:17,339
但显然还剩下两个，所以你会创建另一批比特币作为找零。

00:09:17,339 --> 00:09:19,650
所以你会创建另一批比特币作为找零。

00:09:19,650 --> 00:09:24,570
我们已经从这里取出了输入，

00:09:24,570 --> 00:09:27,779
创建了一个8的输出，

00:09:27,779 --> 00:09:30,089
这个输出被发送给这个人，

00:09:30,089 --> 00:09:32,130
然后我们会处理我们自己的找零，

00:09:32,130 --> 00:09:34,350
并将其锁定到我们自己的地址上。

00:09:34,350 --> 00:09:37,860
这就是你如何处理找零，

00:09:37,860 --> 00:09:39,959
当你进行交易时，

00:09:39,959 --> 00:09:47,850
你基本上是自己处理自己的找零。

00:09:47,850 --> 00:09:49,770
到目前为止，

00:09:49,770 --> 00:09:51,990
我一直在使用整个比特币的整数，

00:09:51,990 --> 00:09:55,380
但你实际上可以将比特币分解成非常小的数字。

00:09:55,380 --> 00:09:57,360
例如，

00:09:57,360 --> 00:09:59,190
我可以发送非常小的金额，

00:09:59,190 --> 00:10:01,290
并将剩余的部分作为找零发送给自己。

00:10:01,290 --> 00:10:05,130
这是完全可以的，

00:10:05,130 --> 00:10:08,370
没有任何真正的限制，

00:10:08,370 --> 00:10:11,459
没有关于分解比特币的限制。

00:10:11,459 --> 00:10:14,010
这种货币的最小单位被称为Satoshi，

00:10:14,010 --> 00:10:17,040
它有八个小数位。

00:10:17,040 --> 00:10:18,110
这就是你可以将比特币分解的程度，

00:10:18,110 --> 00:10:20,060
不能再进一步分解了。

00:10:20,060 --> 00:10:22,090
同样，

00:10:23,500 --> 00:10:27,350
假设你有这批10个比特币，

00:10:27,350 --> 00:10:29,570
但你想向某人发送30个比特币。

00:10:29,570 --> 00:10:33,250
你可以做的是，

00:10:33,250 --> 00:10:35,810
如果你拥有两个或多个属于你的输出，

00:10:35,810 --> 00:10:42,050
你可以将它们一起收集作为输入，

00:10:42,050 --> 00:10:45,260
以创建这个更大的输出，

00:10:45,260 --> 00:10:47,120
而不是创建两个单独的交易。

00:10:47,120 --> 00:10:54,620
只要你能解锁它们，

00:10:54,620 --> 00:10:59,450
你就可以从区块链中选择任意数量的输入作为你的交易。

00:10:59,450 --> 00:11:03,320
再次，这是10和25，

00:11:03,320 --> 00:11:05,450
我向这个人发送了30，

00:11:05,450 --> 00:11:08,330
所以在这个交易中显然还剩下5。

00:11:08,330 --> 00:11:09,770
在这个交易中，

00:11:09,770 --> 00:11:10,310
显然有五个剩余。

00:11:10,310 --> 00:11:12,200
所以你需要把这个当作你自己的零钱来处理。

00:11:12,200 --> 00:11:14,840
就像我之前说的，

00:11:14,840 --> 00:11:16,820
每一笔交易你都需要处理你自己的零钱。

00:11:16,820 --> 00:11:22,520
而且，当这笔交易被记录到区块链上时，

00:11:22,520 --> 00:11:24,200
同样的，我们都会有这个30的输出，

00:11:24,200 --> 00:11:27,080
锁定给这个人，

00:11:27,080 --> 00:11:29,210
然后我们会有这个输出给我们自己，

00:11:29,210 --> 00:11:32,480
锁定给我们。

00:11:32,480 --> 00:11:37,400
而我们从区块链中选择的这两个都被灰色去掉了，

00:11:37,400 --> 00:11:39,020
因为它们在这笔交易中已经被花费了。

00:11:39,020 --> 00:11:47,960
这就是区块链和ISO交易在区块链中的工作方式。

00:11:47,960 --> 00:11:51,380
所以，

00:11:51,380 --> 00:11:53,810
你在最后一张幻灯片中说，

00:11:53,810 --> 00:12:00,560
一笔交易可以有来自多笔交易的输入，这对吗？

00:12:00,560 --> 00:12:04,250
你可以有任意多的输入，

00:12:04,250 --> 00:12:06,680
并创建一些输出。

00:12:06,680 --> 00:12:08,870
这些输入都必须是你自己的，这对吗？

00:12:08,870 --> 00:12:11,510
是的，只要你能解锁它们就行。

00:12:11,510 --> 00:12:13,130
我想说的是，

00:12:13,130 --> 00:12:14,210
如果它们是你的，

00:12:14,210 --> 00:12:16,010
如果你有解锁这些的钥匙，

00:12:16,010 --> 00:12:18,350
那就没问题，我们就假设你拥有它们。

00:12:18,350 --> 00:12:26,050
所以，你可以从人们给你的交易中获取多个输入。

00:12:26,050 --> 00:12:28,250
比如说，

00:12:28,250 --> 00:12:31,340
有三个人分别给我5美元，

00:12:31,340 --> 00:12:35,060
我想给某人14美元。

00:12:35,060 --> 00:12:38,480
我可以使用这三笔交易的输入，

00:12:38,480 --> 00:12:42,530
创建一个14美元的输出和一个1美元的输出，

00:12:42,530 --> 00:12:51,740
返回给我自己。

00:12:51,740 --> 00:12:59,180
我只是在这里展示了一笔单独的交易。

00:12:59,180 --> 00:13:01,630
如果你回到过去，

00:13:01,630 --> 00:13:04,010
把所有的交易都可视化，

00:13:04,010 --> 00:13:07,580
就像它们被添加到区块链上一样。

00:13:07,580 --> 00:13:11,420
这是第一笔交易，

00:13:11,420 --> 00:13:14,030
然后我们有另一笔交易，

00:13:14,030 --> 00:13:16,730
花费了这个输出，

00:13:16,730 --> 00:13:18,770
然后我们有另一个区块的交易，

00:13:18,770 --> 00:13:25,220
每笔交易都会消耗一笔交易，

00:13:25,220 --> 00:13:28,370
如此这般，

00:13:28,370 --> 00:13:31,130
每一笔新的交易都会构建这种图结构。

00:13:31,130 --> 00:13:32,930
所以，

00:13:32,930 --> 00:13:35,540
就像你刚才问的，

00:13:35,540 --> 00:13:38,150
你可以从不同的交易中取出不同的输出，

00:13:38,150 --> 00:13:42,580
将它们集合在一起，创建一个单一的交易。

00:13:42,580 --> 00:13:44,510
但是，如你所见，

00:13:44,510 --> 00:13:47,030
每一笔交易都是相互连接的，

00:13:47,030 --> 00:13:50,030
它们创建了一个直接的输出链，

00:13:50,030 --> 00:13:55,640
输入、输出等等。

00:13:55,640 --> 00:13:57,530
所以，当你为自己进行比特币交易时，

00:13:57,530 --> 00:14:02,330
你只需从区块链图中选择任何可用的输出，

00:14:02,330 --> 00:14:04,610
然后从它们中创建新的输出。

00:14:04,610 --> 00:14:07,850
一对一的线，

00:14:07,850 --> 00:14:12,290
一对一的交易，

00:14:12,290 --> 00:14:15,110
将对比特币交易图产生这样的影响。

00:14:15,110 --> 00:14:20,810
像这样的比特币交易图

00:14:20,810 --> 00:14:25,580
所以，这可能是最好的方式来可视化区块链。

00:14:25,580 --> 00:14:26,990
我意思是，你可以把它想象成只有单个的输出，

00:14:26,990 --> 00:14:32,300
但实际上它们是通过一系列的交易相互连接的。

00:14:32,300 --> 00:14:35,060
区块链看起来就像这样，

00:14:35,060 --> 00:14:39,220
但显然规模要大得多。

00:14:40,910 --> 00:14:43,800
这些橙色的输出还没有被花费

00:14:43,800 --> 00:14:46,079
所以它们被称为未花费的交易输出，

00:14:46,079 --> 00:14:49,230
或者被称为UTXO。

00:14:49,230 --> 00:14:54,839
所以，如果你看到UTXO这个术语，

00:14:54,839 --> 00:14:57,170
它基本上是指这些未花费的比特币。

00:14:57,170 --> 00:15:00,120
这些是重要的，

00:15:00,120 --> 00:15:07,199
因为它们通常被你的比特币客户端保存在内存中，

00:15:07,199 --> 00:15:16,019
以便可以更快地访问。

00:15:16,019 --> 00:15:19,709
到目前为止，

00:15:19,709 --> 00:15:21,300
显然我一直在引用这些原始的交易。

00:15:21,300 --> 00:15:23,850
那么最初的比特币是从哪里来的呢？

00:15:23,850 --> 00:15:31,829
每当一个区块被挖出并添加到区块链上，

00:15:31,829 --> 00:15:39,510
每个区块都会产生一批新的比特币，

00:15:39,510 --> 00:15:41,399
这就是所谓的区块奖励。

00:15:41,399 --> 00:15:44,730
当矿工挖出一个区块时，

00:15:44,730 --> 00:15:48,110
他们会从区块奖励中创建一个输出，

00:15:48,110 --> 00:15:50,399
并将其锁定到他们自己的地址上。

00:15:50,399 --> 00:15:56,760
他们是如何做到这一点的呢？

00:15:56,760 --> 00:16:00,269
在每一个区块的交易中，

00:16:00,269 --> 00:16:02,579
矿工会构建一个交易区块，

00:16:02,579 --> 00:16:04,170
但是在区块的顶部，

00:16:04,170 --> 00:16:06,480
有一个特殊的交易，

00:16:06,480 --> 00:16:08,339
这就是所谓的coinbase交易，

00:16:08,339 --> 00:16:11,160
这是矿工的专属交易。

00:16:11,160 --> 00:16:12,480
通过这个coinbase交易，

00:16:12,480 --> 00:16:14,760
矿工可以收集区块奖励。

00:16:14,760 --> 00:16:18,000
就像我说的，

00:16:18,000 --> 00:16:19,610
每当一个新的区块被添加时，

00:16:19,610 --> 00:16:25,170
矿工就会创建一些之前不存在的新比特币。

00:16:25,170 --> 00:16:27,350
所以，

00:16:27,690 --> 00:16:36,030
可以说比特币交易树的第一层只包含coinbase交易吗？

00:16:36,030 --> 00:16:40,800
是的，

00:16:40,800 --> 00:16:47,340
coinbase交易就是根。

00:16:47,340 --> 00:17:01,500
每一个今天被花费的比特币都可以追溯到某个coinbase交易。

00:17:01,500 --> 00:17:06,540
所以如果你在这个图表上看到，

00:17:06,540 --> 00:17:14,490
所有这些交易都有一个源头，

00:17:14,490 --> 00:17:18,569
这就是区块奖励。

00:17:18,569 --> 00:17:24,810
最后，

00:17:24,810 --> 00:17:27,200
在这个初步的介绍中，

00:17:27,200 --> 00:17:32,010
你可能对交易费用如何工作感兴趣。

00:17:32,010 --> 00:17:36,660
当你进行一笔交易，

00:17:36,660 --> 00:17:44,190
如果你想加上手续费，

00:17:44,190 --> 00:17:50,970
你基本上不会使用你花费的全部金额。

00:17:48,930 --> 00:17:50,970
比如说，这笔输入是10，

00:17:50,970 --> 00:17:53,760
如果你创建了8个输出，

00:17:53,760 --> 00:17:55,770
那么你就用完了全部金额，

00:17:55,770 --> 00:17:57,840
但是如果你没有全部用完，

00:17:57,840 --> 00:18:00,510
你就会创建一个余额，

00:18:00,510 --> 00:18:02,850
这个余额就是手续费。

00:18:02,850 --> 00:18:05,130
所以，

00:18:05,130 --> 00:18:07,380
当你想在交易中加上手续费时，

00:18:07,380 --> 00:18:09,450
你不会为其创建一个单独的输出，

00:18:09,450 --> 00:18:13,710
你只需要留下一部分未被使用的输入就可以了。

00:18:13,710 --> 00:18:16,830
比如说，

00:18:16,830 --> 00:18:18,720
这笔交易的手续费是0.1比特币，

00:18:18,720 --> 00:18:21,029
我们将其发送到网络中，

00:18:21,029 --> 00:18:27,779
最终它会进入网络中所有节点的内存池。

00:18:27,779 --> 00:18:30,690
你之所以要在交易中加上手续费，

00:18:30,690 --> 00:18:33,210
是因为矿工在创建候选区块时，

00:18:33,210 --> 00:18:34,799
只能填充一定数量或一定大小的交易。

00:18:34,799 --> 00:18:38,730
以前，

00:18:38,730 --> 00:18:42,600
这个数量基本上是1MB的交易，

00:18:42,600 --> 00:18:45,059
现在这个度量已经改变为权重，

00:18:45,059 --> 00:18:48,390
但目前大约是1.7MB的交易。

00:18:48,390 --> 00:18:49,799
所以，

00:18:49,799 --> 00:18:52,500
如果内存池中的交易超过1.7MB，

00:18:52,500 --> 00:18:58,559
矿工会选择手续费最高的交易。

00:18:58,559 --> 00:19:00,140
他们之所以这么做，

00:19:00,140 --> 00:19:04,200
是因为他们可以收集所有这些手续费，

00:19:04,200 --> 00:19:09,720
假设这些黄色的小圆盘代表费用使用最高费用的交易，

00:19:09,720 --> 00:19:14,520
可以回收这些交易剩余的部分，

00:19:14,520 --> 00:19:16,770
放入coinbase交易中。

00:19:16,770 --> 00:19:19,620
所以现在，

00:19:19,620 --> 00:19:24,870
他们不仅会在coinbase交易中给自己发送区块奖励（目前是12.5比特币），

00:19:24,870 --> 00:19:26,690
给自己发送区块奖励（目前是12.5比特币），

00:19:26,690 --> 00:19:34,919
还会包括他们所包含的交易的所有手续费。

00:19:34,919 --> 00:19:37,980
然后，这个区块被挖出，

00:19:37,980 --> 00:19:40,230
这个coinbase交易回收了所有的手续费，

00:19:40,230 --> 00:19:42,210
并创建了一个新的比特币批次，

00:19:42,210 --> 00:19:45,260
其中包含了区块奖励。

00:19:45,260 --> 00:19:48,720
这样解释清楚了吗？

00:19:48,720 --> 00:19:52,950
好的，那么我们已经覆盖了所有的基础知识，

00:19:52,950 --> 00:19:54,840
也就是交易的结构，

00:19:54,840 --> 00:19:58,200
如何从输入创建输出的可视化表示。

00:19:58,200 --> 00:20:04,710
然后现在我要讲解的是数据，

00:20:04,710 --> 00:20:08,190
如果我们查看内部数据，

00:20:08,190 --> 00:20:15,530
你如何可以从数据本身构建你自己的交易。

00:20:15,530 --> 00:20:17,450
这将会更加技术性一些，

00:20:17,450 --> 00:20:21,680
所以如果你是一个技术人员，

00:20:21,680 --> 00:20:25,550
这应该涵盖了所有你感兴趣的交易的内部机制。

00:20:25,550 --> 00:20:30,440
这更适合编程和技术人员。

00:20:30,440 --> 00:20:34,640
从之前的图表中，

00:20:34,640 --> 00:20:36,440
我们可以看到，

00:20:36,440 --> 00:20:38,540
我之前使用绿线来表示数据，

00:20:38,540 --> 00:20:40,460
这个黑框就像是我的编辑器，

00:20:40,460 --> 00:20:44,150
我们将从头开始创建一个交易。

00:20:44,150 --> 00:20:46,100
每个交易都以版本号开始，

00:20:46,100 --> 00:20:49,070
这个版本号描述了交易的结构，

00:20:49,070 --> 00:20:52,580
目前的版本号是1，

00:20:52,580 --> 00:20:57,560
我相信大多数的交易都使用版本号1，

00:20:54,590 --> 00:20:57,560
所以我们在这里输入1，

00:20:57,560 --> 00:20:59,180
这没问题，

00:20:59,180 --> 00:21:06,650
但是因为这是一个交易数据，

00:21:06,650 --> 00:21:10,130
它有一个特定的结构，

00:21:10,130 --> 00:21:14,450
所以这个版本号实际上是四个字节长，

00:21:14,450 --> 00:21:16,520
所以我们在这里输入1，

00:21:16,520 --> 00:21:17,690
但是我们需要用零来填充它，

00:21:17,690 --> 00:21:19,250
使其长度为四个字节，

00:21:19,250 --> 00:21:22,550
每两个字符等于一个字节，

00:21:22,550 --> 00:21:25,010
所以这是八个字符长，

00:21:25,010 --> 00:21:28,220
也就是四个字节。

00:21:28,220 --> 00:21:32,510
我们有这些字段大小的原因是，

00:21:30,530 --> 00:21:32,510
交易中的每一项都有自己的字段大小，

00:21:32,510 --> 00:21:36,980
交易中的每一项都有自己的字段大小，

00:21:36,980 --> 00:21:43,580
这使得解码交易更加容易。

00:21:43,580 --> 00:21:45,050
其次，除了四个字节长之外，

00:21:45,050 --> 00:21:48,110
它还必须是十六进制的，这里的计数是1，

00:21:48,110 --> 00:21:49,340
所以在十六进制中也是相同的。

00:21:49,340 --> 00:21:53,570
最后，可能令人最尴尬的是，

00:21:53,570 --> 00:21:56,390
从我们人类的角度来看，

00:21:56,390 --> 00:22:00,890
这些数据必须是网络字节顺序，

00:22:00,890 --> 00:22:03,670
所以你必须反转字节的顺序。

00:22:05,479 --> 00:22:07,519
首先，

00:22:07,519 --> 00:22:09,859
你需要输入计数，

00:22:09,859 --> 00:22:12,889
也就是说你需要在这个交易中使用多少输入。

00:22:12,889 --> 00:22:16,190
假设你有三个，我们在这有三个，

00:22:16,190 --> 00:22:18,320
我们在这有三个，

00:22:18,320 --> 00:22:21,349
但在这个我只会使用一个输出，

00:22:21,349 --> 00:22:22,849
所以我在这里输入1，

00:22:22,849 --> 00:22:24,769
这是一个字节长。

00:22:24,769 --> 00:22:31,209
然而，这是一个特殊的字段，

00:22:31,209 --> 00:22:35,809
称为可变整数，

00:22:35,809 --> 00:22:38,389
或者缩写为变量。

00:22:38,389 --> 00:22:41,749
我认为这是一个技术术语，

00:22:41,749 --> 00:22:48,729
有时也被称为紧凑大小，

00:22:48,729 --> 00:22:51,979
可变整数和变量是我习惯使用的。

00:22:51,979 --> 00:22:55,909
如果你想选择的输出量小于252，

00:22:55,909 --> 00:22:59,629
或者换句话说，

00:22:59,629 --> 00:23:02,149
以十六进制表示为FC，

00:23:02,149 --> 00:23:04,159
那么你就只需要留下一个字节，

00:23:04,159 --> 00:23:07,789
所以你可以把它放在这里。

00:23:07,789 --> 00:23:12,169
如果你想发送超过252个输入，

00:23:12,169 --> 00:23:14,599
那么，

00:23:14,599 --> 00:23:20,989
你就在前面加上字母FD，

00:23:20,989 --> 00:23:24,709
然后接下来的两个字节告诉你你使用了多少输入，

00:23:24,709 --> 00:23:27,859
当然是以十六进制表示。

00:23:27,859 --> 00:23:29,959
同样，如果你想要的数字超过两个字节，

00:23:29,959 --> 00:23:31,669
你就在前面加上Fe，

00:23:31,669 --> 00:23:33,649
那就意味着接下来的四个字节告诉你输入的数量。

00:23:33,649 --> 00:23:36,649
如果它甚至比这个还要大，

00:23:36,649 --> 00:23:38,329
那么你就在前面加上FF，

00:23:38,329 --> 00:23:45,019
接下来的八个字节告诉你你想要收集多少输入。

00:23:45,019 --> 00:23:49,429
但对于绝大多数交易，

00:23:49,429 --> 00:23:55,999
你可能不会收集到这么多，

00:23:55,999 --> 00:24:01,380
如果你自己构建的话，

00:24:01,380 --> 00:24:03,299
你可能只会使用一个字节，

00:24:03,299 --> 00:24:05,250
所以大多数时候，

00:24:05,250 --> 00:24:08,900
这个输入字段的大小是一个字节。

00:24:08,960 --> 00:24:12,690
好的，

00:24:12,690 --> 00:24:14,850
这可能是最技术的部分，

00:24:14,850 --> 00:24:16,110
现在我们继续输入，

00:24:16,110 --> 00:24:21,360
这应该会简单一些。

00:24:21,360 --> 00:24:24,059
我们需要从区块链中选择一个输入，

00:24:24,059 --> 00:24:26,610
所以我们首先需要获取交易ID。

00:24:26,610 --> 00:24:29,429
每个交易都有自己的唯一ID号，

00:24:29,429 --> 00:24:32,460
称为交易ID，

00:24:32,460 --> 00:24:38,390
你只需要把它放在输入代码的第一部分就可以选择它，

00:24:38,390 --> 00:24:42,470
它的长度是32个字节，

00:24:42,470 --> 00:24:44,880
也是十六进制的，

00:24:44,880 --> 00:24:47,070
而且还要是网络字节顺序，

00:24:47,070 --> 00:24:49,830
所以需要反转一下。

00:24:49,830 --> 00:24:52,260
你选择这个并输入到一个区块链浏览器中，

00:24:52,260 --> 00:24:54,419
你就能找到它，

00:24:54,419 --> 00:24:56,909
因为它已经被反转了。

00:24:56,909 --> 00:24:58,740
如果你把它反转回来，

00:24:58,740 --> 00:25:01,289
你就能在区块链中找到它。

00:25:01,289 --> 00:25:05,010
但我们想要一个特定的输出，

00:25:05,010 --> 00:25:11,669
所以一个交易就像我之前给你们展示的那样，

00:25:11,669 --> 00:25:12,780
它可以创建多个输出，

00:25:12,780 --> 00:25:15,570
所以你做的就是使用V out，

00:25:15,570 --> 00:25:19,559
这是向量输出的简称，

00:25:19,559 --> 00:25:21,780
每一个输出都从0开始，

00:25:21,780 --> 00:25:24,360
有自己的数字，所以这个只有一个输出，

00:25:24,360 --> 00:25:27,450
我在这里输入0，

00:25:27,450 --> 00:25:30,110
但是这个也是4字节长的十六进制，

00:25:30,110 --> 00:25:34,100
然后得到我的数据。

00:25:34,580 --> 00:25:38,280
接下来讲的主要部分

00:25:38,280 --> 00:25:41,340
我们基本上已经完成了，

00:25:41,340 --> 00:25:44,630
所以呢，这只是一个快速的问题，

00:25:44,630 --> 00:25:48,690
假设我们有多个交易，

00:25:48,690 --> 00:25:51,150
多个输出，

00:25:51,150 --> 00:25:54,030
那是可能的，对吧？

00:25:54,030 --> 00:25:57,360
所以假设我们有两个交易，

00:25:57,360 --> 00:25:59,850
每个交易都有两个输出，

00:25:59,850 --> 00:26:04,230
那么在Z行，

00:26:04,230 --> 00:26:11,490
1会变成0，对吧？

00:26:11,490 --> 00:26:14,130
输入字段，这个，

00:26:14,130 --> 00:26:17,280
这个输入计数会变成4，对吧？

00:26:17,280 --> 00:26:20,030
所有的交易我们使用了多少输入？

00:26:20,030 --> 00:26:24,630
是的，是的，是的，

00:26:24,630 --> 00:26:27,780
然后我们会列出所有的交易ID，

00:26:27,780 --> 00:26:30,240
这两个是一个接一个的，

00:26:30,240 --> 00:26:30,630
好的，

00:26:30,630 --> 00:26:32,610
如果你想选择两个不同的输出，

00:26:32,610 --> 00:26:37,700
这个代码就是为了我们这个单一的输出，就是这个，

00:26:37,700 --> 00:26:40,350
就是这个，

00:26:40,350 --> 00:26:42,840
如果你有两个，

00:26:42,840 --> 00:26:49,770
你就可以在这个后面重复这个。

00:26:49,770 --> 00:26:51,659
那么我们在这里，

00:26:51,659 --> 00:26:53,460
已经成功地选择了这个交易的这个特定输出，

00:26:53,460 --> 00:26:54,480
那么交易ID给了你

00:26:54,480 --> 00:26:56,309
通过V out选择了特定的按钮，

00:26:56,309 --> 00:27:00,900
这就引用了这个输出，

00:27:00,900 --> 00:27:02,909
但显然它有一个锁在上面，

00:27:02,909 --> 00:27:05,580
为了能够花费这个并把它发送给另一个人，

00:27:05,580 --> 00:27:07,140
你必须能够解锁它，

00:27:07,140 --> 00:27:10,890
但在比特币交易中，

00:27:10,890 --> 00:27:15,360
你需要先构建整个交易结构才能解锁它，

00:27:15,360 --> 00:27:18,510
在你解锁它之前，你不能进行交易。

00:27:18,510 --> 00:27:19,950
现在我要跳过这个

00:27:19,950 --> 00:27:24,360
解锁码它被称为签名脚本

00:27:24,360 --> 00:27:28,770
这里的签名和这里的所有代码将被称为脚本，

00:27:28,770 --> 00:27:30,270
因为它有自己的脚本语言。

00:27:30,270 --> 00:27:33,720
它也被称为第二脚本，

00:27:33,720 --> 00:27:35,010
你也可以给它想一个更友好的名字

00:27:35,010 --> 00:27:39,600
你也可以称之为最后的解锁代码。

00:27:39,600 --> 00:27:44,100
每个输入都有一个序列号，

00:27:44,100 --> 00:27:46,470
这个序列号并不常用，

00:27:46,470 --> 00:27:52,679
我将这个序列号设置为一个小于最大可能值的数值，

00:27:52,679 --> 00:27:58,169
那么你就可以在之后替换这个交易。

00:27:58,169 --> 00:28:00,330
例如，

00:28:00,330 --> 00:28:02,130
如果你在这个交易上设置了一个很低的费用，

00:28:02,130 --> 00:28:04,740
你可以创建一个新的交易，

00:28:04,740 --> 00:28:06,200
这个新的交易有一个更高的序列号，

00:28:06,200 --> 00:28:10,080
它就能够替换已经在网络上的那个交易。

00:28:10,080 --> 00:28:13,770
我通常会将这个序列号设置为最大的十六进制值，

00:28:13,770 --> 00:28:17,580
我会这样做。

00:28:17,580 --> 00:28:21,370
从这里开始，

00:28:21,370 --> 00:28:24,350
我通常设置的全部FS。

00:28:24,350 --> 00:28:25,850
如果你想选择另一个输入，

00:28:25,850 --> 00:28:29,660
我会在这段代码后面重复整个过程，

00:28:29,660 --> 00:28:34,990
因为你说这里可以快速解析。

00:28:34,990 --> 00:28:37,400
接下来，

00:28:37,400 --> 00:28:38,930
我们已经完成了输入的选择，

00:28:38,930 --> 00:28:42,560
我想从中创建一些输出。

00:28:42,560 --> 00:28:44,330
同样，这是一个可变整数，

00:28:44,330 --> 00:28:46,070
所以如果你想快速创建很多输出，

00:28:46,070 --> 00:28:48,500
超过252个或者更多，

00:28:48,500 --> 00:28:50,540
你就需要使用可变整数代码。

00:28:50,540 --> 00:28:52,430
但是因为我这里只使用了两个，

00:28:52,430 --> 00:28:55,270
所以可以放在一个字节里。

00:28:55,270 --> 00:28:57,680
我之前没有提到的原因是为了在数据中节省空间，

00:28:57,680 --> 00:29:01,400
这样你就可以更有效地使用那些数据。

00:29:01,400 --> 00:29:05,420
使用这种方式处理数据，

00:29:05,420 --> 00:29:08,840
以便输出具有良好结构。

00:29:08,840 --> 00:29:11,030
首先你要输入你想发送的比特币的数量，

00:29:11,030 --> 00:29:13,490
但你不是输入比特币的数量，

00:29:13,490 --> 00:29:14,780
而是输入聪的数量。

00:29:14,780 --> 00:29:18,740
比如说，我想要发送大约0.02个比特币。

00:29:18,740 --> 00:29:20,300
你必须把它转换成聪，

00:29:20,300 --> 00:29:26,570
因为聪是最小的单位。

00:29:26,570 --> 00:29:28,880
这是输出的第一部分，

00:29:28,880 --> 00:29:31,220
它必须是一个实际的十进制数，

00:29:31,220 --> 00:29:32,960
必须是8个字节长。

00:29:32,960 --> 00:29:36,500
这个也是以字节的反序排列的，

00:29:36,500 --> 00:29:38,740
所以当你浏览代码时，

00:29:38,740 --> 00:29:41,630
这看起来像是乱码，

00:29:41,630 --> 00:29:43,730
但如果你把字节顺序反过来，

00:29:43,730 --> 00:29:47,000
转换成十进制，它就输出给你数量。

00:29:47,000 --> 00:29:50,210
在这之后，

00:29:50,210 --> 00:29:53,150
你提到了这个长度为8字节的数字，

00:29:53,150 --> 00:29:55,100
这让我觉得可能存在一种限制，

00:29:55,100 --> 00:29:58,880
即在一次交易中你可以发送的最大数量。

00:29:58,880 --> 00:30:01,700
交易是8字节的十六进制，

00:30:01,700 --> 00:30:03,470
我认为是一个非常非常大的数字，

00:30:03,470 --> 00:30:06,440
我有一个想法。

00:30:06,440 --> 00:30:09,470
我认为它应该能覆盖大多数情况，

00:30:09,470 --> 00:30:13,460
但如果真的出现问题，

00:30:13,460 --> 00:30:16,060
那可有一个好问题要解决。

00:30:17,500 --> 00:30:22,730
在设置了金额之后，

00:30:22,730 --> 00:30:27,280
下一步就是简单地对其进行加锁。

00:30:27,280 --> 00:30:30,440
锁也有自己的脚本语言，

00:30:30,440 --> 00:30:32,240
大小可以变化。

00:30:32,240 --> 00:30:36,159
因为它们的大小可以变化，

00:30:34,450 --> 00:30:37,450
所以它们没有固定的大小，

00:30:37,450 --> 00:30:38,980
像交易ID或版本号那样，

00:30:38,980 --> 00:30:42,330
我们必须再次使用这个可变的整数。

00:30:42,330 --> 00:30:45,970
大多数签名，典型的签名大约是19，

00:30:45,970 --> 00:30:50,679
我认为这是25字节，

00:30:50,679 --> 00:30:53,619
这只是告诉你即将到来的锁的大小，

00:30:53,619 --> 00:30:58,869
你把锁放在那里。

00:30:58,869 --> 00:31:00,759
这里充满了一些代码，

00:31:00,759 --> 00:31:04,720
创建一个脚本，

00:31:04,720 --> 00:31:06,639
将其锁定到特定的地址。

00:31:06,639 --> 00:31:10,359
这是我们锁定的地址，

00:31:10,359 --> 00:31:13,269
我们在这里使用了公钥，

00:31:13,269 --> 00:31:16,869
但这里我不打算深入研究这个，

00:31:16,869 --> 00:31:22,029
但这里的代码对应于这个特定的地址。

00:31:22,029 --> 00:31:25,659
这些灰色的东西，

00:31:25,659 --> 00:31:28,359
它们只是锁定代码，

00:31:28,359 --> 00:31:31,090
锁定到这个特定公钥的代码。

00:31:31,090 --> 00:31:32,769
所以如果你想创建自己的锁，

00:31:32,769 --> 00:31:36,190
你可以复制粘贴这段代码，

00:31:36,190 --> 00:31:41,830
然后用你想发送的人的公钥替换这个公钥。

00:31:41,830 --> 00:31:48,999
这个公钥可以从这个地址派生出来。

00:31:48,999 --> 00:31:54,059
所以这个锁定代码显然会对不同的公钥有所不同。

00:31:54,059 --> 00:31:57,429
在典型的交易中

00:31:57,429 --> 00:31:59,639
7609编码会改变的只是这里的绿色部分，

00:31:59,639 --> 00:32:05,799
这个76 a 914 a a C指的是脚本中的特定代码。

00:32:05,799 --> 00:32:07,600
基本上就是说，

00:32:07,600 --> 00:32:12,100
当这个地址已经被锁定到这个公钥时，

00:32:12,100 --> 00:32:14,109
如果你想发送它，

00:32:14,109 --> 00:32:20,799
我必须提供一个签名。

00:32:20,799 --> 00:32:25,559
这基本上就是将要运行的脚本，

00:32:25,559 --> 00:32:27,909
你知道吗

00:32:27,909 --> 00:32:32,769
你把它放在堆栈上，

00:32:32,769 --> 00:32:34,570
检查它是否相等。

00:32:34,570 --> 00:32:37,509
这些是操作码，

00:32:37,509 --> 00:32:39,249
它们指的是OP重复，

00:32:39,249 --> 00:32:42,279
相信我，我在这里忽略了这些，

00:32:42,279 --> 00:32:44,450
我认为签名脚本和代码值得我后面单独解释一下。

00:32:44,450 --> 00:32:48,379
这是锁定代码，

00:32:48,379 --> 00:32:50,960
我并不期望你现在就能理解。

00:32:50,960 --> 00:32:55,669
就像你之前问的，

00:32:55,669 --> 00:32:58,580
因为我说了两个输出，

00:32:58,580 --> 00:33:03,980
我在这里创建了另一个输出，

00:33:03,980 --> 00:33:06,320
结构和上次一样。

00:33:06,320 --> 00:33:08,419
这部分是我发送的金额，

00:33:08,419 --> 00:33:11,389
然后这是即将出现的锁定代码的大小，

00:33:11,389 --> 00:33:14,659
这是实际的锁定代码，

00:33:14,659 --> 00:33:16,190
地址不同。

00:33:16,190 --> 00:33:18,230
你可以看到这个以8/8 AC结尾，

00:33:18,230 --> 00:33:20,359
就像那个一样，

00:33:20,359 --> 00:33:24,859
它以7 6 8 9开始。

00:33:24,859 --> 00:33:25,009
所以，我们在这里改变的只是我锁定的地址。

00:33:25,009 --> 00:33:32,239
我们在这里改变的只是我锁定的地址。

00:33:32,239 --> 00:33:33,950
最后，

00:33:33,950 --> 00:33:35,809
我们有所谓的时间锁，

00:33:35,809 --> 00:33:38,929
这是交易的最后部分。

00:33:38,929 --> 00:33:44,149
锁定时间基本上允许你对交易进行后期处理。

00:33:44,149 --> 00:33:49,460
你在这里设置的锁定时间小于5亿，

00:33:49,460 --> 00:33:51,649
那么这就是指一个特定的区块高度。

00:33:51,649 --> 00:33:54,320
如果你回到过去，

00:33:54,320 --> 00:33:56,629
我们说我们已经完成了14个区块，

00:33:56,629 --> 00:33:58,609
我们在这里设置的锁定时间是16，

00:33:58,609 --> 00:34:03,590
那么这意味着这个交易只能在：区块高度为16或更高的情况下被挖出。

00:34:03,590 --> 00:34:06,700
区块高度为16或更高的情况下被挖出。

00:34:07,389 --> 00:34:12,859
同样，如果你将锁定时间设定为大于500万，

00:34:12,859 --> 00:34:16,909
那么这里的500万表示的是最多500万个区块，

00:34:16,909 --> 00:34:18,770
如果超过这个数，

00:34:18,770 --> 00:34:23,960
那么你就在指定一个特定的Unix时间，

00:34:23,960 --> 00:34:29,330
也就是从1970年1月1日开始的秒数。

00:34:29,330 --> 00:34:32,960
无论如何，这个锁定时间都会将交易

00:34:32,960 --> 00:34:35,179
锁定到一个特定的区块或一个特定的时间点。

00:34:35,179 --> 00:34:38,449
但如果你不使用它，

00:34:38,449 --> 00:34:42,050
你可能就不会使用它，

00:34:42,050 --> 00:34:44,060
只需将其设定为零，

00:34:44,060 --> 00:34:47,889
这意味着它可以立即被挖掘。

00:34:47,889 --> 00:34:52,790
然后我们就有了一个交易。

00:34:52,790 --> 00:34:55,099
再次回顾一下，四个主要部分：

00:34:55,099 --> 00:34:58,700
你有一个版本号，

00:34:58,700 --> 00:35:01,130
通常是1，然后你有输入，

00:35:01,130 --> 00:35:03,920
你只选择一个输入，

00:35:03,920 --> 00:35:06,080
涉及到解锁代码的我还没有说，

00:35:06,080 --> 00:35:08,420
我们会回来的。

00:35:08,420 --> 00:35:10,280
在输入之后，你有输出，从中创建输出，

00:35:10,280 --> 00:35:12,530
然后你有一个锁定时间，

00:35:12,530 --> 00:35:14,960
这就是任何交易的四个主要部分。

00:35:14,960 --> 00:35:17,589
好的，

00:35:17,660 --> 00:35:22,089
现在进入这幻灯片的最后一部分，

00:35:22,089 --> 00:35:24,619
接下来，

00:35:24,619 --> 00:35:27,019
我将介绍这个签名的实际过程，

00:35:27,019 --> 00:35:28,700
以便能够解锁这个输出，

00:35:28,700 --> 00:35:31,640
也就是这个输入。

00:35:31,640 --> 00:35:34,640
在这部分，我会快速过一些东西，

00:35:34,640 --> 00:35:37,309
可能无法在时间内解释清楚，

00:35:37,309 --> 00:35:39,740
因为我认为签名本身可能还需要一些视频。

00:35:39,740 --> 00:35:42,769
但是，

00:35:42,769 --> 00:35:44,599
如果你正在重看这个视频，

00:35:44,599 --> 00:35:47,269
并且你想从头开始构建你自己的交易，

00:35:47,269 --> 00:35:50,059
我只是想涵盖你需要做的所有事情，

00:35:50,059 --> 00:35:52,750
以便能够创建签名，

00:35:51,200 --> 00:35:52,750
来签署这个交易。

00:35:52,750 --> 00:35:57,380
所以，如果有些东西不明白，

00:35:57,380 --> 00:35:59,269
不用担心，

00:35:59,269 --> 00:36:02,690
也许当你回来的时候就会明白了。

00:36:02,690 --> 00:36:07,670
所以，我们有这个交易，

00:36:07,670 --> 00:36:09,500
我们有这个需要解锁的输入。

00:36:09,500 --> 00:36:11,990
这个输入已经被锁定到我们的地址，

00:36:11,990 --> 00:36:16,400
我们有对应这个地址的私钥，

00:36:16,400 --> 00:36:23,000
我们需要使用私钥，

00:36:23,000 --> 00:36:28,940
来证明我们是这个地址的所有者。

00:36:28,940 --> 00:36:33,740
或者一个非常简单但不好的方法，

00:36:33,740 --> 00:36:37,369
就是将你的私钥直接塞入交易中，

00:36:37,369 --> 00:36:38,720
这样可以证明你拥有私钥，

00:36:38,720 --> 00:36:40,759
但问题在于，

00:36:40,759 --> 00:36:43,819
当你这样做发送到网络中时，

00:36:43,819 --> 00:36:47,329
你基本上就把你的私钥给了网络中的每一个人，

00:36:47,329 --> 00:36:49,519
因为你的私钥已经被暴露了。

00:36:49,519 --> 00:36:51,950
所以，如果你有其他的输出被锁定到这个地址，

00:36:51,950 --> 00:36:54,589
他们可以使用私钥解锁它们并花费它们，

00:36:54,589 --> 00:36:56,359
或者他们可以不转发这个交易，

00:36:56,359 --> 00:36:59,269
他们可以直接拿你的私钥并创建一个新的交易，

00:36:59,269 --> 00:37:03,410
然后发送到他们自己的地址，

00:37:03,410 --> 00:37:05,839
所以这是很不好的。

00:37:05,839 --> 00:37:08,390
所以我们需要一个更智能的方式来使用我们的私钥来解锁这个锁，

00:37:08,390 --> 00:37:11,509
来证明我们拥有这个地址，

00:37:11,509 --> 00:37:13,940
而不是真的给出私钥本身，

00:37:13,940 --> 00:37:18,079
这就是数字签名的作用。

00:37:18,079 --> 00:37:19,880
就像我说的，

00:37:19,880 --> 00:37:24,450
这个私钥和地址实际上是相互关联的，

00:37:24,450 --> 00:37:27,000
地址实际上是由你的私钥创建的，

00:37:27,000 --> 00:37:30,810
我现在不打算讲解这是如何工作的，

00:37:30,810 --> 00:37:32,070
但是私钥和数字签名，

00:37:32,070 --> 00:37:40,710
是通过一些数学运算使用椭圆曲线相互连接的。

00:37:40,710 --> 00:37:41,820
所以你可以做的是，

00:37:41,820 --> 00:37:44,150
因为这些是通过椭圆曲线连接的，

00:37:44,150 --> 00:37:48,810
你可以使用更多的数学运算从你的私钥创建一个签名，

00:37:48,810 --> 00:37:53,970
这将能够解锁这个地址。

00:37:53,970 --> 00:37:55,800
我会简单地介绍一下，

00:37:55,800 -->00:38:00,180
你如何为这个交易创建一个数字签名，

00:38:00,180 --> 00:38:04,430
你需要拿到私钥和你想要签名的交易，

00:38:04,430 --> 00:38:08,490
然后将它们放入这个椭圆曲线中。

00:38:08,490 --> 00:38:10,470
你使用了一些椭圆曲线数学，

00:38:10,470 --> 00:38:13,790
这将给你一个签名。

00:38:13,790 --> 00:38:16,320
目前，

00:38:16,320 --> 00:38:21,360
右侧的输入只有屏幕上显示的信息

00:38:21,360 --> 00:38:27,030
对，就像它仍然在那里，

00:38:27,030 --> 00:38:32,700
对，是的，

00:38:32,700 --> 00:38:38,460
然后你使用这个未签名的交易和你的私钥放入这个函数，

00:38:37,110 --> 00:38:38,460
和你的私钥放入这个函数，

00:38:38,460 --> 00:38:40,410
这将给你一个签名。

00:38:40,410 --> 00:38:44,040
这个签名将被放入交易中。

00:38:44,040 --> 00:38:45,660
我简化了这一点，

00:38:45,660 --> 00:38:48,840
这可能是你想忽略的部分，

00:38:48,840 --> 00:38:51,720
因为它很难保留。

00:38:51,720 --> 00:38:53,040
但是，如果你以技术思维观看这个，

00:38:53,040 --> 00:38:55,590
或者实际在做这个，

00:38:55,590 --> 00:38:58,140
你需要做的是，

00:38:58,140 --> 00:39:01,740
首先，当你想要签名一个交易时，

00:39:01,740 --> 00:39:03,180
你必须先剔除任何已存在的签名。

00:39:03,180 --> 00:39:04,890
如果你已经签名了一个输入，

00:39:04,890 --> 00:39:07,470
就把签名去掉。

00:39:07,470 --> 00:39:19,020
然后你需要在脚本签名将要放置的地方放置一个占位符代码，

00:39:19,020 --> 00:39:29,559
这个占位符代码是我们试图解锁的输入的锁定代码或脚本公钥。

00:39:23,820 --> 00:39:25,950
这只是一个占位符，

00:39:25,950 --> 00:39:27,720
所以我们知道要签名哪个输入。

00:39:27,720 --> 00:39:29,559
然后，

00:39:29,559 --> 00:39:34,970
你将所谓的sig hash类型附加到交易数据的末尾，

00:39:34,970 --> 00:39:38,239
我不完全确定这是用来做什么的，

00:39:38,239 --> 00:39:41,989
但对于典型的签名，

00:39:41,989 --> 00:39:43,640
你只需要在这里输入数字1，

00:39:43,640 --> 00:39:45,380
这显然是一个网络字节或字节顺序，

00:39:45,380 --> 00:39:45,980
bytes long

00:39:45,980 --> 00:39:48,619
长度为4字节。

00:39:48,619 --> 00:39:52,099
然后你把所有这些都通过hash256进行两次哈希，

00:39:52,099 --> 00:39:54,980
你会得到这个摘要，

00:39:54,980 --> 00:40:01,489
然后这个消息会进入这个椭圆曲线，

00:40:01,489 --> 00:40:03,289
然后它会输出一个签名，

00:40:03,289 --> 00:40:10,670
你需要将这个签名编码成DER格式，

00:40:10,670 --> 00:40:12,890
我认为大多数库都会给你这种编码签名的选项，

00:40:12,890 --> 00:40:15,769
然后最后你需要将相同的哈希类型附加到实际的签名本身，

00:40:15,769 --> 00:40:18,259
所以这只是一个哈希类型，

00:40:18,259 --> 00:40:22,009
我们将其放入数学运算中，

00:40:22,009 --> 00:40:29,299
然后我们在末尾附加相同的数字，

00:40:29,299 --> 00:40:31,730
这是4字节，

00:40:31,730 --> 00:40:32,599
这是1字节，

00:40:32,599 --> 00:40:35,420
我认为这是一个错误，

00:40:35,420 --> 00:40:37,039
当帐户正在开发时，

00:40:37,039 --> 00:40:40,460
有这些不同大小的字节，

00:40:40,460 --> 00:40:43,700
但它们都是相同的数字，

00:40:43,700 --> 00:40:44,930
在这个数字的末尾。

00:40:44,930 --> 00:40:48,079
所以这就是如果你在做技术性的工作，

00:40:48,079 --> 00:40:49,309
但我只是简化了这个，

00:40:49,309 --> 00:40:53,119
只是为了向你展示交易数据进入这个曲线。

00:40:53,119 --> 00:40:55,789
所以当你创建这个签名时，

00:40:55,789 --> 00:40:58,609
你使用了这个椭圆曲线，

00:40:58,609 --> 00:41:01,369
地址上就可以看到这个签名，

00:41:01,369 --> 00:41:04,579
然后，好的，

00:41:04,579 --> 00:41:11,509
这个签名只能由我从中创建的公钥的所有者创建。

00:41:11,509 --> 00:41:14,630
那么这就足够了，

00:41:14,630 --> 00:41:16,249
足够解锁这个输入，

00:41:16,249 --> 00:41:20,930
通过这样做，

00:41:20,930 --> 00:41:22,640
我们可以把这个签名放在这里，

00:41:22,640 --> 00:41:24,529
我们不会泄露我们的公钥或私钥。

00:41:24,529 --> 00:41:30,289
这个签名过程的另一个好处是，

00:41:30,289 --> 00:41:37,430
因为这个签名是由我们创建的这个交易结构制作的，

00:41:37,430 --> 00:41:39,890
当我们把这个签名放在这里时，

00:41:39,890 --> 00:41:42,859
如果我们把这个交易发送到网络中，

00:41:42,859 --> 00:41:51,380
有人试图修改交易的结构，

00:41:51,380 --> 00:41:58,549
比如改变比特币的地址，

00:41:58,549 --> 00:42:00,170
试图偷走你的比特币，

00:42:00,170 --> 00:42:02,450
那么这个签名就不再有效，

00:42:02,450 --> 00:42:06,799
这个交易就不再有效。

00:42:06,799 --> 00:42:13,369
因为这个签名只适用于产生它的交易。

00:42:13,369 --> 00:42:19,069
这个签名保护了你创建的交易的结构，

00:42:19,069 --> 00:42:21,079
它只能用于这个特定的交易。

00:42:21,079 --> 00:42:28,509
这就是你如何创建一个签名来

00:42:28,509 --> 00:42:32,710
解锁一个输入的基本方法，

00:42:32,710 --> 00:42:35,619
这被称为脚本签名。

00:42:35,619 --> 00:42:38,359
但在脚本签名中，

00:42:38,359 --> 00:42:41,569
你不仅仅放入签名，

00:42:41,569 --> 00:42:48,799
我之前给你展示的锁定代码中

00:42:48,799 --> 00:42:57,829
也需要你将公钥（也就是地址的原始版本）放入脚本签名中。

00:42:57,829 --> 00:42:59,749
虽然它被称为脚本签名，

00:42:59,749 --> 00:43:03,650
但它也需要一个公钥才能使解锁代码工作。

00:43:03,650 --> 00:43:09,799
显然，这个公钥的大小可以改变，

00:43:09,799 --> 00:43:15,920
所以你需要在这里放一个可变整数来描述它的长度。

00:43:15,920 --> 00:43:17,660
签名的大小也可以变化，

00:43:17,660 --> 00:43:21,200
所以它有自己的可变整数。

00:43:21,200 --> 00:43:24,650
在整个脚本签名之前，

00:43:24,650 --> 00:43:28,400
你需要放一个可变整数。

00:43:28,400 --> 00:43:31,039
通过这样，

00:43:31,039 --> 00:43:33,890
我们可以固定的字段大小和可变的字段大小，

00:43:33,890 --> 00:43:37,819
这意味着你可以解码这个交易并获取正确的数据量，

00:43:37,819 --> 00:43:40,420
所以你知道哪部分是哪部分。

00:43:41,050 --> 00:43:43,190
再次，

00:43:43,190 --> 00:43:44,600
我们将其发送到网络中，

00:43:44,600 --> 00:43:46,610
因为你已经放入了解锁它的签名，

00:43:46,610 --> 00:43:47,960
它们将发送到网络中，

00:43:47,960 --> 00:43:50,840
最终交易将被挖掘出来，

00:43:50,840 --> 00:43:55,040
从而形成这样的图。

00:43:55,040 --> 00:43:58,130
在这个过程中，

00:43:58,130 --> 00:44:06,140
每个网络节点都负责检查交易的有效性。

00:44:06,140 --> 00:44:07,460
好的，

00:44:07,460 --> 00:44:14,000
所以如果我篡改了Cynthia的脚本，

00:44:14,000 --> 00:44:21,020
节点会标记出来并切忽略这个交易。

00:44:21,020 --> 00:44:34,940
如果你试图发送一个错误的脚本，

00:44:34,940 --> 00:44:44,570
它事实上是一个数字签名，

00:44:44,570 --> 00:44:46,640
它只不过是由私钥签署的交易的哈希。

00:44:49,370 --> 00:44:50,560
这是对的。

00:44:50,560 --> 00:44:58,070
我的感觉是，

00:44:58,070 --> 00:45:02,360
节点可能会使用公钥重新签署，

00:45:02,360 --> 00:45:07,940
并检查两者是否一致。

00:45:07,940 --> 00:45:10,010
是的，

00:45:10,010 --> 00:45:15,920
你已经弄清楚了。

00:45:15,920 --> 00:45:18,500
回到这个幻灯片，

00:45:18,500 --> 00:45:23,150
你在之前的一个幻灯片中提到了占位符，

00:45:23,150 --> 00:45:25,880
你能再重复一下吗？

00:45:25,880 --> 00:45:30,710
我是说，会不会是一些占位符文本，

00:45:30,710 --> 00:45:33,020
或者它只是一个占位符？

00:45:33,020 --> 00:45:43,040
占位符是当我们之前创建这个锁，

00:45:43,040 --> 00:45:49,010
并放入一些锁定代码时的代码。

00:45:49,010 --> 00:45:50,299
例如，

00:45:50,299 --> 00:45:54,270
假设你想花费这个输入，

00:45:54,270 --> 00:46:05,789
这里的占位符就是这个锁内的代码。

00:46:05,789 --> 00:46:08,849
这有点混乱，

00:46:08,849 --> 00:46:12,569
我不知道为什么它必须是锁内的代码，

00:46:12,569 --> 00:46:14,670
但我相信它可以是任何其他东西，

00:46:14,670 --> 00:46:16,380
但它只需要是这个输入的实际锁定代码，

00:46:16,380 --> 00:46:17,520
老实说，

00:46:17,520 --> 00:46:19,230
这使得创建交易变得有些尴尬，

00:46:19,230 --> 00:46:24,329
需要回去获取这个输入的实际锁定代码，

00:46:24,329 --> 00:46:27,030
并将其作为占位符使用，

00:46:27,030 --> 00:46:32,430
但这就是它的工作方式。

00:46:32,430 --> 00:46:34,349
让我们再次概述一下整个过程，

00:46:34,349 --> 00:46:38,579
我们对整个块进行哈希处理，

00:46:38,579 --> 00:46:40,200
这就是我们要签名的内容。

00:46:40,200 --> 00:46:41,460
我简化了这个过程，

00:46:41,460 --> 00:46:44,369
说你只需要将交易数据放入椭圆曲线，

00:46:44,369 --> 00:46:46,680
这在某种程度上你是是正确的，

00:46:46,680 --> 00:46:48,690
但更准确的说法是，

00:46:48,690 --> 00:46:51,180
你实际上是附加了一个哈希类型，

00:46:51,180 --> 00:46:53,420
然后哈希它，

00:46:53,420 --> 00:46:58,099
最后将其放入这个椭圆曲线数学公式中。

00:46:58,609 --> 00:47:05,940
通常你可以找到一个叫做ECDSA的库，

00:47:05,940 --> 00:47:11,160
也就是椭圆曲线数字签名算法，

00:47:11,160 --> 00:47:16,529
我们通常可以用它来进行签名。

00:47:16,529 --> 00:47:19,470
还有一个问题是，

00:47:19,470 --> 00:47:22,170
我们是否需要对每一个我们试图花费的输出进行这个操作？

00:47:22,170 --> 00:47:25,579
对于每一个输入，

00:47:25,579 --> 00:47:29,430
我们都会重复这个过程。

00:47:29,430 --> 00:47:32,609
你需要记住移除所有已存在的签名，

00:47:32,609 --> 00:47:35,339
然后对每一个单独的输入进行签名。

00:47:35,339 --> 00:47:38,490
your site one and then for each one you

00:47:38,490 --> 00:47:40,500
want to get the blank structure and then

00:47:40,500 --> 00:47:45,930
sign that for each individual so we will

00:47:45,930 --> 00:47:47,819
then at the end plug in all the

00:47:47,819 --> 00:47:49,890
signatures one of the do just shove them

00:47:49,890 --> 00:47:53,190
into into this oh yeah okay sorry

00:47:53,190 --> 00:47:55,319
in this one I only had one so let's say

00:47:55,319 --> 00:47:57,329
we had multiple you know Al this is this

00:47:57,329 --> 00:48:00,119
is one then why do then if I had another

00:48:00,119 --> 00:48:01,470
input I would just take all this

00:48:01,470 --> 00:48:02,670
signature out

00:48:02,670 --> 00:48:04,290
and I would just sign the next one I put

00:48:04,290 --> 00:48:05,430
the placeholder into the next wouldn't

00:48:05,430 --> 00:48:07,470
sign it to get the signature and so on

00:48:07,470 --> 00:48:09,390
as the one got it and at the very end

00:48:09,390 --> 00:48:12,390
you'll just plug in D and at the end at

00:48:12,390 --> 00:48:14,280
the end you just will just shove in all

00:48:14,280 --> 00:48:16,590
the script SIG's in the show back in

00:48:16,590 --> 00:48:21,120
yeah I got it okay

00:48:21,120 --> 00:48:23,160
so just to summarize this was our

00:48:23,160 --> 00:48:25,350
transaction we created that signature

00:48:25,350 --> 00:48:30,660
we'll put it put it in there so like I

00:48:30,660 --> 00:48:32,730
said before a transaction has four major

00:48:32,730 --> 00:48:35,460
parts you have the vision you have the

00:48:35,460 --> 00:48:38,070
inputs and the input has their own sort

00:48:38,070 --> 00:48:39,810
of mini structure thrown sub structure

00:48:39,810 --> 00:48:41,700
so it has a track it refers to a

00:48:41,700 --> 00:48:44,000
transaction ID then it refers to a

00:48:44,000 --> 00:48:46,920
specific output then you have a variable

00:48:46,920 --> 00:48:48,300
integer to tell you the size of that

00:48:48,300 --> 00:48:51,330
come in script sig and then after that

00:48:51,330 --> 00:48:54,360
you have a seeing it with a sequence and

00:48:54,360 --> 00:48:56,730
that's an input next step we have

00:48:56,730 --> 00:48:58,140
outputs and they have their own

00:48:58,140 --> 00:49:00,510
structure again but they're quite simple

00:49:00,510 --> 00:49:02,250
they just have a value which is 8 bytes

00:49:02,250 --> 00:49:04,500
long then you have a very variable

00:49:04,500 --> 00:49:06,420
integer to tell you the size of the

00:49:06,420 --> 00:49:08,250
upcoming unlocking code which is called

00:49:08,250 --> 00:49:11,310
the script pub key and then finally you

00:49:11,310 --> 00:49:14,300
have the lock time and that is a

00:49:14,300 --> 00:49:17,490
transaction and they're all the same the

00:49:17,490 --> 00:49:19,260
only difference is they have varying

00:49:19,260 --> 00:49:21,150
number of inputs varying number of

00:49:21,150 --> 00:49:24,270
outputs and they obviously have referred

00:49:24,270 --> 00:49:26,910
to different transactions and have

00:49:26,910 --> 00:49:29,820
different signatures but you understand

00:49:29,820 --> 00:49:31,620
the structure then you understand the

00:49:31,620 --> 00:49:33,420
structure of every single Bitcoin

00:49:33,420 --> 00:49:35,060
transaction that they could possibly be

00:49:35,060 --> 00:49:39,570
except for a seg wit this is like an old

00:49:39,570 --> 00:49:42,840
cell transaction you do have segregated

00:49:42,840 --> 00:49:46,830
witness now which basically on a very

00:49:46,830 --> 00:49:49,620
basic level all it does instead of

00:49:49,620 --> 00:49:52,860
having this signature code in the middle

00:49:52,860 --> 00:49:55,440
of transactions a base link it basically

00:49:55,440 --> 00:49:57,240
gets moved to the end at the end of a

00:49:57,240 --> 00:49:59,340
transaction and that's called the

00:49:59,340 --> 00:50:02,100
witness so that's why it's called it's

00:50:02,100 --> 00:50:04,740
basically like separating the signatures

00:50:04,740 --> 00:50:07,950
from the transaction or sometimes a

00:50:07,950 --> 00:50:10,860
signature is called a witness and that's

00:50:10,860 --> 00:50:12,120
why it's called segregated witness

00:50:12,120 --> 00:50:14,250
because it's at segregating the witness

00:50:14,250 --> 00:50:14,430
day

00:50:14,430 --> 00:50:17,369
two signatures from the structure of the

00:50:17,369 --> 00:50:18,030
transaction

00:50:18,030 --> 00:50:23,160
I think covering and segue witness would

00:50:23,160 --> 00:50:26,339
be his own video but I want to do this

00:50:26,339 --> 00:50:28,160
or at least this is a basic and

00:50:28,160 --> 00:50:30,869
transaction and these are still valid

00:50:30,869 --> 00:50:31,619
and you can still make these

00:50:31,619 --> 00:50:32,970
transactions perfectly fine on the

00:50:32,970 --> 00:50:42,920
network so maybe distant one line or

00:50:44,300 --> 00:50:48,059
it's basically a Bitcoin proposal yes

00:50:48,059 --> 00:50:51,390
oh yeah it's a segregated witness is a

00:50:51,390 --> 00:50:53,849
change the transaction data structure

00:50:53,849 --> 00:50:57,119
and it just okay okay it just moves the

00:50:57,119 --> 00:50:59,339
so yeah as you have this is like the

00:50:59,339 --> 00:51:02,520
typical basic transaction but I was

00:51:02,520 --> 00:51:03,720
segregated witness will have another

00:51:03,720 --> 00:51:06,450
field or section called the witness area

00:51:06,450 --> 00:51:09,359
and the signatures basically get moved

00:51:09,359 --> 00:51:11,130
to the end of the transaction and that's

00:51:11,130 --> 00:51:15,359
called a witness area somewhat like let

00:51:15,359 --> 00:51:16,740
me rephrase the question this is a

00:51:16,740 --> 00:51:19,980
change in the Bitcoin core goodness or

00:51:19,980 --> 00:51:23,970
is it a change that exchanges need to

00:51:23,970 --> 00:51:30,390
make it's well it's because I keep

00:51:30,390 --> 00:51:32,010
hearing this that you know this person

00:51:32,010 --> 00:51:33,690
has to implement send witty and that

00:51:33,690 --> 00:51:35,400
person has to implement said with yet

00:51:35,400 --> 00:51:38,940
and they haven't done it and I'm still a

00:51:38,940 --> 00:51:41,220
little confused but anyway we can hear

00:51:41,220 --> 00:51:43,980
well if you didn't if you created your

00:51:43,980 --> 00:51:46,049
own software and you've only have ever

00:51:46,049 --> 00:51:47,849
been able to create to these kind of

00:51:47,849 --> 00:51:50,520
structures transactions then you would

00:51:50,520 --> 00:51:52,740
have to unless you are using the Bitcoin

00:51:52,740 --> 00:51:53,790
core software to create your

00:51:53,790 --> 00:51:56,640
transactions which you know if you've

00:51:56,640 --> 00:51:57,720
made your own software to create these

00:51:57,720 --> 00:51:59,910
then you need to write your own software

00:51:59,910 --> 00:52:02,190
to create your own security witness

00:52:02,190 --> 00:52:05,099
transactions guard yeah make sense in

00:52:05,099 --> 00:52:06,900
fairness technically I don't think that

00:52:06,900 --> 00:52:12,030
terribly different difficult so I don't

00:52:12,030 --> 00:52:13,260
know why some places are taking so long

00:52:13,260 --> 00:52:15,299
I think it might be just caution maybe

00:52:15,299 --> 00:52:19,530
I'm not sure got it so at this point of

00:52:19,530 --> 00:52:21,869
time if I send a transaction with with

00:52:21,869 --> 00:52:24,059
segregated witness the Bitcoin core will

00:52:24,059 --> 00:52:27,450
understand it yes okay

00:52:27,450 --> 00:52:32,069
all right so that's the that's what

00:52:32,069 --> 00:52:34,140
we're done so that's the basic stone and

00:52:34,140 --> 00:52:36,329
that's the beta done so I'm gonna do an

00:52:36,329 --> 00:52:37,859
out I'm going to do some examples just

00:52:37,859 --> 00:52:40,859
to create a transaction transaction from

00:52:40,859 --> 00:52:42,440
scratch

00:52:42,440 --> 00:52:47,490
alright so this is my website before the

00:52:47,490 --> 00:52:50,119
transaction transaction from scratch

00:52:50,119 --> 00:52:54,240
what I would say is well here's a page

00:52:54,240 --> 00:52:55,740
I've got to the glossary go to

00:52:55,740 --> 00:52:59,880
transaction data I've broken down the

00:52:59,880 --> 00:53:02,490
transactions here so if you wanted to

00:53:02,490 --> 00:53:04,530
decode your own transaction which i

00:53:04,530 --> 00:53:05,460
think is a good idea

00:53:05,460 --> 00:53:07,530
I think decode in this transaction data

00:53:07,530 --> 00:53:09,390
is a very good place to start I think

00:53:09,390 --> 00:53:10,650
trying to build one because the

00:53:10,650 --> 00:53:13,349
signatures is a bit tricky you might get

00:53:13,349 --> 00:53:15,599
a bit stuck at some point but decoding

00:53:15,599 --> 00:53:16,829
it I think would be a good place to

00:53:16,829 --> 00:53:18,359
start for getting to grips with how

00:53:18,359 --> 00:53:22,290
transactions work and I saw it was handy

00:53:22,290 --> 00:53:24,150
to have your own decoder just for your

00:53:24,150 --> 00:53:27,390
own reference purposes but if you wanted

00:53:27,390 --> 00:53:30,030
to you know dig into the transaction

00:53:30,030 --> 00:53:34,940
data here's the page on my website or

00:53:34,940 --> 00:53:37,170
alternatively you could just look at any

00:53:37,170 --> 00:53:40,650
block of transactions on the browser so

00:53:40,650 --> 00:53:43,349
for example this one this is a bit of a

00:53:43,349 --> 00:53:44,730
complex one there's taking loads of

00:53:44,730 --> 00:53:46,230
inputs in and spitting rows of it the

00:53:46,230 --> 00:53:48,480
outputs out but if you click on see

00:53:48,480 --> 00:53:52,109
realized and you can break down the

00:53:52,109 --> 00:53:55,380
transaction into its component parts so

00:53:55,380 --> 00:53:58,049
that might be helpful when when you want

00:53:58,049 --> 00:53:59,760
to understand the structure of a

00:53:59,760 --> 00:54:03,900
transaction but what I'm going to now

00:54:03,900 --> 00:54:05,420
what I'm gonna do now I'm going to

00:54:05,420 --> 00:54:10,760
construct my own transaction

00:54:11,450 --> 00:54:15,349
I swear I can't give it up get rid of

00:54:15,349 --> 00:54:18,109
this little thing here sorry don't how

00:54:18,109 --> 00:54:24,380
to do that brother so I've got some I've

00:54:24,380 --> 00:54:27,799
made a little script called transaction

00:54:27,799 --> 00:54:30,440
builder and I'm going to build my own

00:54:30,440 --> 00:54:33,650
transaction so first thing I need is I

00:54:33,650 --> 00:54:39,049
need to be able to know which outputs I

00:54:39,049 --> 00:54:41,869
can spend so luckily for me I've created

00:54:41,869 --> 00:54:46,430
a transaction beforehand and I've locked

00:54:46,430 --> 00:54:49,910
these outputs to address his value so

00:54:49,910 --> 00:54:54,380
I'm gonna spend one of these outputs so

00:54:54,380 --> 00:54:55,849
I'll spend this one this is the one I

00:54:55,849 --> 00:54:57,549
want to spend and send to somewhere else

00:54:57,549 --> 00:55:00,170
so first of all in the transaction

00:55:00,170 --> 00:55:01,549
builder facing a need it's a version

00:55:01,549 --> 00:55:03,589
number so I'll stick the version 1 in

00:55:03,589 --> 00:55:06,950
there and so that has turned that number

00:55:06,950 --> 00:55:11,359
1 into hexadecimal network byte order

00:55:11,359 --> 00:55:15,980
and it's turned into a 4 byte field next

00:55:15,980 --> 00:55:17,930
step we need to select the inputs so I

00:55:17,930 --> 00:55:20,720
need a transaction ID and a output

00:55:20,720 --> 00:55:23,020
number so this is the transaction ID

00:55:23,020 --> 00:55:26,270
I'll put that in there and I want this

00:55:26,270 --> 00:55:30,280
one here that's output 0 so there we are

00:55:30,280 --> 00:55:33,740
that's the only one I want to spend so

00:55:33,740 --> 00:55:36,380
that's not done so if you look here

00:55:36,380 --> 00:55:40,460
that's the number of inputs this here is

00:55:40,460 --> 00:55:44,000
the transaction ID in Reverse byte order

00:55:44,000 --> 00:55:50,530
so a 4 a 4 and this here is the 4 byte

00:55:54,090 --> 00:55:59,460
it's the 4-byte output number this here

00:55:59,460 --> 00:56:02,550
is the variable integer to see to tell

00:56:02,550 --> 00:56:04,080
me the upcoming size of the signature

00:56:04,080 --> 00:56:05,730
but I haven't put it in there yet so at

00:56:05,730 --> 00:56:07,500
zero and this is the sequence number

00:56:07,500 --> 00:56:11,120
done using so next up now I need to

00:56:11,120 --> 00:56:13,650
choose my way I need to create my

00:56:13,650 --> 00:56:16,970
outputs so this were here this is a

00:56:16,970 --> 00:56:20,910
naught point naught 5 BTC but I want

00:56:20,910 --> 00:56:23,520
this to be in satoshis so let me just

00:56:23,520 --> 00:56:28,350
configure that yeah so that's not point

00:56:28,350 --> 00:56:33,090
naught naught 5 1 so I put the value

00:56:33,090 --> 00:56:36,840
here and the address I want to send it

00:56:36,840 --> 00:56:40,230
to I think I'll send it to my donation

00:56:40,230 --> 00:56:41,760
address here and the top of the website

00:56:41,760 --> 00:56:47,310
so there we go and but because I want

00:56:47,310 --> 00:56:51,630
this to get mind I haven't put a fee on

00:56:51,630 --> 00:56:53,880
this so what I'll do instead of sending

00:56:53,880 --> 00:56:54,660
the whole amount

00:56:54,660 --> 00:57:00,990
I'll send c49 this this amount so that

00:57:00,990 --> 00:57:02,490
puts a little fee on it I don't know

00:57:02,490 --> 00:57:03,960
what that's gonna be in fee per byte

00:57:03,960 --> 00:57:06,120
under guessing but that will leave a

00:57:06,120 --> 00:57:09,570
remainder in the transaction and again

00:57:09,570 --> 00:57:12,450
put the address there so that's a book

00:57:12,450 --> 00:57:15,150
created last up then so this is output

00:57:15,150 --> 00:57:17,910
been added to the transaction code when

00:57:17,910 --> 00:57:22,190
I put and this is the is this right

00:57:22,190 --> 00:57:25,940
yeah I'm sure here somewhere

00:57:26,180 --> 00:57:28,680
so a quick question here so at this

00:57:28,680 --> 00:57:31,260
point is it signed or it it still yes

00:57:31,260 --> 00:57:32,880
Tony's resigned and you have to create

00:57:32,880 --> 00:57:35,070
yeah okay the whole structure first

00:57:35,070 --> 00:57:39,090
before it gets on alright got it so it

00:57:39,090 --> 00:57:41,570
has your code just plugged in the place

00:57:41,570 --> 00:57:46,020
he'll do that in a moment and so last up

00:57:46,020 --> 00:57:48,510
is a long time so there we are so now

00:57:48,510 --> 00:57:50,850
we've created the structure we've chosen

00:57:50,850 --> 00:57:52,410
the inputs and we've creating the output

00:57:52,410 --> 00:57:54,060
from it so now we've got the whole

00:57:54,060 --> 00:57:56,010
structure this is you've got the data we

00:57:56,010 --> 00:57:59,370
need to be able to sign it so to be able

00:57:59,370 --> 00:58:00,330
to sign it

00:58:00,330 --> 00:58:04,190
I need the private key for this address

00:58:04,190 --> 00:58:06,300
you should never expose your private key

00:58:06,300 --> 00:58:08,970
but in this example here it is this is

00:58:08,970 --> 00:58:12,690
my private key for this output so there

00:58:12,690 --> 00:58:13,710
we are that's the private key that

00:58:13,710 --> 00:58:16,680
corresponds to this address but like I

00:58:16,680 --> 00:58:21,180
said we need to get the locking code so

00:58:21,180 --> 00:58:22,710
that we can use a placeholder when we

00:58:22,710 --> 00:58:25,080
sign it it's a bit annoying but if you

00:58:25,080 --> 00:58:26,250
click on this little lock here on the

00:58:26,250 --> 00:58:29,970
browser this is the locking code as you

00:58:29,970 --> 00:58:34,160
can see those you know it corresponds to

00:58:34,160 --> 00:58:37,950
up codes and this is the public key

00:58:37,950 --> 00:58:41,120
that's the address so I need this

00:58:41,120 --> 00:58:43,470
locking code to be used as a placeholder

00:58:43,470 --> 00:58:47,550
when I sign the transaction so there we

00:58:47,550 --> 00:58:47,700
are

00:58:47,700 --> 00:58:50,640
I'll sign this now and this is the D

00:58:50,640 --> 00:58:54,330
completed transaction data so because

00:58:54,330 --> 00:58:55,770
it's all signed this is ready to go I

00:58:55,770 --> 00:58:59,370
can use I can if I want to I can just

00:58:59,370 --> 00:59:01,760
quickly decode it so I've written my own

00:59:01,760 --> 00:59:03,470
[Music]

00:59:03,470 --> 00:59:05,700
transaction decoder is quite handy to

00:59:05,700 --> 00:59:08,370
have so I can look at this and it's

00:59:08,370 --> 00:59:11,370
showing me the inputs there's one here

00:59:11,370 --> 00:59:15,000
the transaction ID and one output and to

00:59:15,000 --> 00:59:16,440
be unlocked to this address here the

00:59:16,440 --> 00:59:17,700
beer address which is my donation

00:59:17,700 --> 00:59:21,600
address and if you do you get kind CLI

00:59:21,600 --> 00:59:23,580
if you download a Bitcoin core it has

00:59:23,580 --> 00:59:25,670
his own decoder

00:59:25,670 --> 00:59:27,829
transaction you can do the same thing

00:59:27,829 --> 00:59:32,650
and it will decode it for you as well so

00:59:33,190 --> 00:59:35,450
now we've got the transaction it's all

00:59:35,450 --> 00:59:37,609
been signed ready to go what I can do I

00:59:37,609 --> 00:59:41,829
can go Bitcoin CLI send your transaction

00:59:41,829 --> 00:59:45,200
so I'll put that in there and there we

00:59:45,200 --> 00:59:45,349
are

00:59:45,349 --> 00:59:48,589
it has just given me a transaction ID so

00:59:48,589 --> 00:59:51,230
this is the transaction and this is the

00:59:51,230 --> 00:59:54,079
transaction ID for it so I can take this

00:59:54,079 --> 00:59:56,859
transaction ID and I can go into my

00:59:56,859 --> 00:59:59,660
blockchain Explorer and I can enter the

00:59:59,660 --> 01:00:01,640
transaction ID try and find it

01:00:01,640 --> 01:00:03,950
okay hasn't found it yet it's probably

01:00:03,950 --> 01:00:05,900
taking some time for to propagate the

01:00:05,900 --> 01:00:12,589
network so I keep refreshing okay give

01:00:12,589 --> 01:00:16,039
it good ten seconds gone so yeah we are

01:00:16,039 --> 01:00:18,559
looking for this in the men buoy or in

01:00:18,559 --> 01:00:20,450
the blacklist would have gone so I've

01:00:20,450 --> 01:00:22,730
created this transaction I sent in to a

01:00:22,730 --> 01:00:25,160
node and it's now gonna be being sent on

01:00:25,160 --> 01:00:25,549
the network

01:00:25,549 --> 01:00:28,809
and it's gonna enter this nodes mempool

01:00:28,809 --> 01:00:31,759
so it it should be a plain ring if I

01:00:31,759 --> 01:00:33,710
click on this memory pool it should be

01:00:33,710 --> 01:00:36,470
appearing yeah somebody here I just

01:00:36,470 --> 01:00:41,539
deleted the page it's there okay so they

01:00:41,539 --> 01:00:42,890
release their art it's just received it

01:00:42,890 --> 01:00:46,069
five seconds ago they are so I can click

01:00:46,069 --> 01:00:48,319
on this now and there is the transaction

01:00:48,319 --> 01:00:51,349
I just made I'm watching Explorer so now

01:00:51,349 --> 01:00:53,089
it's on the network now I know it's been

01:00:53,089 --> 01:00:56,059
sent on the network it's a very low fee

01:00:56,059 --> 01:01:00,410
I don't think it's gonna get mind but

01:01:00,410 --> 01:01:01,970
again I can just look at the code and

01:01:01,970 --> 01:01:04,549
this should be the exact same code dye

01:01:04,549 --> 01:01:07,519
created so basically you send code into

01:01:07,519 --> 01:01:10,039
the network and that describes this

01:01:10,039 --> 01:01:12,589
transaction with the movement of inputs

01:01:12,589 --> 01:01:18,769
to outputs is that yeah it's better

01:01:18,769 --> 01:01:21,170
converter two US dollars here I mean I

01:01:21,170 --> 01:01:22,880
haven't no I guess I could request my

01:01:22,880 --> 01:01:25,069
brother sir asked me the same thing I'm

01:01:25,069 --> 01:01:26,420
still working I have to work on it yeah

01:01:26,420 --> 01:01:30,559
I think this is about $80 at the moment

01:01:30,559 --> 01:01:33,319
so I'm probably gonna want to make sure

01:01:33,319 --> 01:01:35,569
this transaction gets mind before I put

01:01:35,569 --> 01:01:38,890
the video out because exactly

01:01:39,000 --> 01:01:42,150
private key and how yeah and what is the

01:01:42,150 --> 01:01:49,440
fee like approximate 0.0002 well if the

01:01:49,440 --> 01:01:52,950
works off a fee per bite because a node

01:01:52,950 --> 01:01:55,230
can only fit up there block with so many

01:01:55,230 --> 01:01:59,460
bytes exchanged small fee per weight but

01:01:59,460 --> 01:02:00,600
I haven't updated the Explorer to use

01:02:00,600 --> 01:02:02,010
weight and it's more of a complex thing

01:02:02,010 --> 01:02:03,540
to use but if we look it over

01:02:03,540 --> 01:02:05,400
if you look at all these transactions if

01:02:05,400 --> 01:02:06,270
you go towards the bottom there

01:02:06,270 --> 01:02:10,170
generally ordered by their fee per fee

01:02:10,170 --> 01:02:13,290
per byte it's slow maybe ask them you

01:02:13,290 --> 01:02:15,480
know the smallest ones about 100 odd you

01:02:15,480 --> 01:02:17,490
know no point no not 100 to Satoshi's

01:02:17,490 --> 01:02:19,530
right so well some of you get included

01:02:19,530 --> 01:02:23,610
for Less but there's just a rough

01:02:23,610 --> 01:02:24,780
estimate but it looks like my

01:02:24,780 --> 01:02:28,620
transaction is just slightly too low the

01:02:28,620 --> 01:02:32,130
fee to get mine just yet so I could

01:02:32,130 --> 01:02:34,140
create another one just show you but I

01:02:34,140 --> 01:02:35,760
mean that's good enough you know just to

01:02:35,760 --> 01:02:36,990
show you that how when you get a

01:02:36,990 --> 01:02:39,750
transaction it just gets goes into the

01:02:39,750 --> 01:02:47,730
memory pool like so I've made this code

01:02:47,730 --> 01:02:49,620
available on the website so if you go to

01:02:49,620 --> 01:02:52,610
code transaction builder dot RB

01:02:52,610 --> 01:02:55,650
the code is all here mm-hm I written it

01:02:55,650 --> 01:02:59,280
in Ruby I tried to make it as simple as

01:02:59,280 --> 01:03:00,440
possible I did want to do it

01:03:00,440 --> 01:03:03,570
procedurally procedurally because I

01:03:03,570 --> 01:03:04,680
thought that'd be an easier way to do I

01:03:04,680 --> 01:03:06,630
couldn't do it that way I thought we it

01:03:06,630 --> 01:03:08,250
seemed easier to do it in an

01:03:08,250 --> 01:03:12,360
object-oriented way so okay it's not

01:03:12,360 --> 01:03:14,460
terribly long it's about 300 lines long

01:03:14,460 --> 01:03:18,870
at the code but the basic parts is you

01:03:18,870 --> 01:03:21,060
have I start with some utilities just

01:03:21,060 --> 01:03:22,410
for getting all the data in the correct

01:03:22,410 --> 01:03:26,310
format then the main transaction class

01:03:26,310 --> 01:03:28,920
that has version inputs outputs and lock

01:03:28,920 --> 01:03:31,110
time so it has an array of inputs and a

01:03:31,110 --> 01:03:34,350
real outputs so and then you have an

01:03:34,350 --> 01:03:35,790
input class which has you know the

01:03:35,790 --> 01:03:38,640
transaction ID the V out scripts ax

01:03:38,640 --> 01:03:40,040
equals and then

01:03:40,040 --> 01:03:43,550
then you have an output object which

01:03:43,550 --> 01:03:45,320
just hasn't value and the script and the

01:03:45,320 --> 01:03:49,700
script pub key and so if you want I

01:03:49,700 --> 01:03:51,860
think he'd be good to create you you've

01:03:51,860 --> 01:03:52,940
wanted to build your own name

01:03:52,940 --> 01:03:54,560
transaction builder from scratch I think

01:03:54,560 --> 01:03:55,790
it's a good way to do it you know in

01:03:55,790 --> 01:03:57,650
your own programming language but if you

01:03:57,650 --> 01:03:59,030
wanted to see if you're making some

01:03:59,030 --> 01:04:00,110
mistakes you want to see what squares

01:04:00,110 --> 01:04:01,700
going wrong and you could always come in

01:04:01,700 --> 01:04:03,320
here for example probably the trick is

01:04:03,320 --> 01:04:07,030
trickiest part is just this signing part

01:04:07,030 --> 01:04:10,310
obviously here's the signing method and

01:04:10,310 --> 01:04:12,860
it's a bit long but it's just basically

01:04:12,860 --> 01:04:14,300
getting all the data in the right order

01:04:14,300 --> 01:04:17,300
I'd have any common commented it so it

01:04:17,300 --> 01:04:18,530
might be helpful for trying to figure

01:04:18,530 --> 01:04:24,880
out which parts might be missing okay so

01:04:24,940 --> 01:04:29,990
there's any questions with that no like

01:04:29,990 --> 01:04:31,730
yeah I think that so I think that

01:04:31,730 --> 01:04:33,230
basically tempers you know if you wanted

01:04:33,230 --> 01:04:35,090
to create your own transaction you know

01:04:35,090 --> 01:04:37,070
this should it's quite helped I think

01:04:37,070 --> 01:04:38,360
this my websites quite helpful for

01:04:38,360 --> 01:04:39,920
finding the correct data to be able to

01:04:39,920 --> 01:04:41,300
you know create your own transactions

01:04:41,300 --> 01:04:42,470
and just browse it and see what's going

01:04:42,470 --> 01:04:45,320
on definitely definitely

01:04:45,320 --> 01:04:47,750
are you using some sort of API or are is

01:04:47,750 --> 01:04:49,850
this being pulled from like a real old

01:04:49,850 --> 01:04:52,280
yeah this is an this is basically well

01:04:52,280 --> 01:04:54,440
enough a Bitcoin core node and but what

01:04:54,440 --> 01:04:58,060
I do I so I but I put it into my own

01:04:58,060 --> 01:05:00,740
database but it's basically running live

01:05:00,740 --> 01:05:02,990
off a Bitcoin core node so when you make

01:05:02,990 --> 01:05:04,940
a transaction I said new block I've just

01:05:04,940 --> 01:05:10,490
been added so yeah it's all life okay so

01:05:10,490 --> 01:05:13,250
you're hosting the website on the same

01:05:13,250 --> 01:05:17,180
node or it's on a different machine and

01:05:17,180 --> 01:05:19,100
you just pull data into a database and

01:05:19,100 --> 01:05:22,070
then have the website read data off it's

01:05:22,070 --> 01:05:23,510
actually on the same machine it probably

01:05:23,510 --> 01:05:25,010
would make sense to have the node on a

01:05:25,010 --> 01:05:27,980
different machine and then how can they

01:05:27,980 --> 01:05:29,150
- I'll have this website just mean the

01:05:29,150 --> 01:05:33,170
database but I don't the machines needs

01:05:33,170 --> 01:05:35,600
to be handling handling it okay so at

01:05:35,600 --> 01:05:38,570
the moment Wow but this is running off a

01:05:38,570 --> 01:05:40,640
machine in Switzerland so that's why

01:05:40,640 --> 01:05:41,990
when I made this transaction I'm in the

01:05:41,990 --> 01:05:44,579
UK at the moment I sent it from my

01:05:44,579 --> 01:05:47,910
I sent this from my local node from the

01:05:47,910 --> 01:05:50,279
UK so yeah but then again it only takes

01:05:50,279 --> 01:05:53,640
a few seconds I think for a transaction

01:05:53,640 --> 01:05:55,650
to propagate the entire network so it

01:05:55,650 --> 01:05:57,119
might have been my website was a little

01:05:57,119 --> 01:05:59,699
bit slow at decoding the transaction and

01:05:59,699 --> 01:06:03,259
then and then storing it in the database

01:06:04,039 --> 01:06:08,369
so that's the Bitcoin CLI give you

01:06:08,369 --> 01:06:11,279
access to all this data like memory pool

01:06:11,279 --> 01:06:13,679
and transactions in the memory pool or

01:06:13,679 --> 01:06:16,199
you yeah and it does give you all the

01:06:16,199 --> 01:06:19,019
data so I mean you could use the website

01:06:19,019 --> 01:06:21,989
but you can actually get all this data

01:06:21,989 --> 01:06:25,939
from Bitcoin CLI I'm not sure what is

01:06:25,939 --> 01:06:28,650
are they okay that last the mempool so

01:06:28,650 --> 01:06:31,469
Bitcoin CLI get more mempool these are

01:06:31,469 --> 01:06:33,779
all the transactions ID transaction IDs

01:06:33,779 --> 01:06:37,439
coming in there yeah and if you wanted

01:06:37,439 --> 01:06:47,519
to get Bitcoin there we are so that's

01:06:47,519 --> 01:06:48,809
the transaction data for that one I just

01:06:48,809 --> 01:06:50,729
selected so it's all there you know you

01:06:50,729 --> 01:06:52,229
can get all that out to the out of the

01:06:52,229 --> 01:06:53,269
in politic

01:06:53,269 --> 01:07:00,119
Bitcoin see like a nice yep so I think

01:07:00,119 --> 01:07:03,630
that's everything I wanted to cover yes

01:07:03,630 --> 01:07:07,859
at all before no no that's it great

01:07:07,859 --> 01:07:13,670
thanks a lot sir yeah looking forward to

01:07:13,670 --> 01:07:16,679
yeah I think the next what I'd like to

01:07:16,679 --> 01:07:20,420
do is probably covering the keys and

01:07:20,420 --> 01:07:24,209
addresses so these public keys probably

01:07:24,209 --> 01:07:25,650
probably keep every key in address how

01:07:25,650 --> 01:07:27,089
they all connect together through this

01:07:27,089 --> 01:07:29,789
you know this lip decay of how they

01:07:29,789 --> 01:07:33,059
created because that explained a lot

01:07:33,059 --> 01:07:34,529
about how this signature stuff works

01:07:34,529 --> 01:07:35,910
because at the moment I just saw said

01:07:35,910 --> 01:07:38,489
this is a signature and it works but I

01:07:38,489 --> 01:07:40,049
could explain how it actually does work

01:07:40,049 --> 01:07:44,730
using this mathematics nice nicer

01:07:44,730 --> 01:07:47,040
yeah looking forward to it yeah just

01:07:47,040 --> 01:07:48,810
just let me know whenever yeah whenever

01:07:48,810 --> 01:07:51,119
you're ready I'll stop I'll stop

01:07:51,119 --> 01:07:52,500
chipping away at some keys and the

01:07:52,500 --> 01:07:54,390
dresses stuff but if I give you an email

01:07:54,390 --> 01:07:56,310
in a while to let you know when I think

01:07:56,310 --> 01:07:59,550
you might be ready yeah so thank you

01:07:59,550 --> 01:08:02,250
very much thanks a thanks for those

01:08:02,250 --> 01:08:04,550
really good