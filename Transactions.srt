00:00:00,230 --> 00:00:03,449
所以在这节课中，

00:00:03,449 --> 00:00:06,210
我将向大家介绍比特币交易的基本原理。

00:00:06,210 --> 00:00:09,480
希望在本次演讲结束后，

00:00:09,480 --> 00:00:11,580
大家能够理解比特币交易是如何进行的，

00:00:11,580 --> 00:00:14,219
比特币是什么样的，

00:00:14,219 --> 00:00:18,510
以及如何构建自己的比特币交易。

00:00:18,510 --> 00:00:20,130
我会像上次一样，将演讲分为三个部分。

00:00:20,130 --> 00:00:23,519
首先，我将从比特币交易的基础知识讲起，

00:00:23,519 --> 00:00:27,359
解释交易的外观、数据表示等方面。

00:00:27,359 --> 00:00:28,920
我会详细讲解你需要了解的关于交易结构和工作原理的所有内容。

00:00:28,920 --> 00:00:33,300
接下来，我会介绍交易数据。

00:00:33,300 --> 00:00:37,440
我不仅会给出交易的视觉表示，

00:00:37,440 --> 00:00:40,379
还会展示实际的数据。

00:00:40,379 --> 00:00:43,680
这样，你们不仅能看到交易的视觉表示，

00:00:43,680 --> 00:00:50,100
还能了解数据是如何描述和工作的。

00:00:50,100--> 00:00:55,289
等我讲完之后你就会知道它们是怎么工作的，数据是什么样子的。

00:00:50,100 --> 00:00:52,020
所以，如果你看一下实际的交易，

00:00:52,020 --> 00:01:01,680
讲解完工作原理和数据的外观之后，

00:01:01,680 --> 00:01:11,159
我会通过一些实例来演示如何从头开始构建一个交易，

00:01:11,159 --> 00:01:16,799
是的，我将开始第一部分，

00:01:16,799 --> 00:01:23,490
接着之前的内容，

00:01:23,490 --> 00:01:28,020
我开始讲解比特币交易的基础知识。

00:01:28,020 --> 00:01:30,840
如果你还记得之前的内容，

00:01:30,840 --> 00:01:34,350
网络上的每台计算机都代表一个比特币节点，

00:01:34,350 --> 00:01:36,090
它们共同构成了整个网络，并共享一个称为区块链的文件。

00:01:36,090 --> 00:01:37,920
并共享一个称为区块链的文件。

00:01:37,920 --> 00:01:41,210
因此，当你想要进行一笔交易，

00:01:41,210 --> 00:01:45,630
向某人发送一些比特币时，

00:01:45,630 --> 00:01:46,799
你需要做的就是创建一行数据。

00:01:46,799 --> 00:01:55,300
这条小绿线代表了一笔比特币交易，

00:01:55,300 --> 00:01:57,250
它本质上是一串数据。

00:01:57,250 --> 00:02:00,280
你可以把这串数据发送到网络中的任何一个节点，

00:02:00,280 --> 00:02:04,000
节点会把它保存在自己的内存池中，

00:02:04,000 --> 00:02:09,399
并把它转发给其他相连的节点。

00:02:09,399 --> 00:02:12,340
这个过程会一直重复，

00:02:12,340 --> 00:02:16,450
直到所有节点都在自己的内存池中复制了这笔交易。

00:02:16,450 --> 00:02:20,670
接下来，

00:02:20,670 --> 00:02:27,370
这些节点会竞争将内存池中的交易打包进区块链这个文件中。

00:02:27,370 --> 00:02:29,709
如果某个节点成功地挖掘出了一个区块，

00:02:29,709 --> 00:02:33,550
它就会把这个区块发送给其他相连的节点，

00:02:33,550 --> 00:02:37,800
这些节点随后会把这个区块加入到自己的区块链副本中。

00:02:37,800 --> 00:02:41,110
直到所有节点都更新了自己的区块链副本。

00:02:41,110 --> 00:02:44,890
当这个区块被加入到区块链中后，

00:02:44,890 --> 00:02:47,350
我们就可以查看区块链并找到这笔交易，

00:02:47,350 --> 00:02:48,820
因为它现在已经成为区块链的一部分了。

00:02:48,820 --> 00:02:55,600
比特币的所有权就从一个人转移到了另一个人。

00:02:55,600 --> 00:02:58,090
今天，我要讲解的是

00:02:58,090 --> 00:03:03,370
这个过程是如何运作的，

00:03:03,370 --> 00:03:08,440
你如何创建这样一串数据，

00:03:08,440 --> 00:03:16,209
以及它是如何代表比特币所有权转移的。

00:03:16,209 --> 00:03:19,870
我们来看看比特币交易的基础知识。

00:03:19,870 --> 00:03:21,750
这条绿线代表的就是交易数据，

00:03:21,750 --> 00:03:28,600
它将比特币的所有权从我转移到你。

00:03:28,600 --> 00:03:30,940
如果我们放大这条绿线，

00:03:30,940 --> 00:03:32,470
它仍然代表着交易数据。

00:03:32,470 --> 00:03:34,000
我现在还不打算向你展示具体的数据内容，

00:03:34,000 --> 00:03:41,350
这里只是对实际数据的简化表示。

00:03:35,110 --> 00:03:41,350
首先，这是区块链。

00:03:41,350 --> 00:03:47,950
假设这代表的是之前演示中提到的区块链的延续。

00:03:47,950 --> 00:03:50,290
从上次的演示中我们知道，

00:03:50,290 --> 00:03:54,040
区块链由一系列包含交易记录的区块组成。

00:03:54,040 --> 00:03:55,900
因此，

00:03:55,900 --> 00:04:00,150
区块链本质上是一个记录了大量交易数据的文件。

00:04:00,150 --> 00:04:05,069
我们今天要探讨的是区块链交易，

00:04:05,069 --> 00:04:10,530
以一种直观的方式来展示区块链中的交易数据。

00:04:07,530 --> 00:04:10,530
区块链本质上是由一系列不同批次的比特币组成的，

00:04:10,530 --> 00:04:13,230
每一批比特币都像是这一个小橙色的盒子，

00:04:13,230 --> 00:04:21,570
所以每一个小橙盒代表一个独立的比特币批次。

00:04:21,570 --> 00:04:26,040
每个盒子都上了锁，

00:04:26,040 --> 00:04:31,530
这就是人们能够安全持有比特币的原因，

00:04:31,530 --> 00:04:33,270
因为只有拥有钥匙的人才能花费这些比特币，

00:04:33,270 --> 00:04:35,550
将它们转发给其他人。

00:04:35,550 --> 00:04:39,030
你可以想象一下区块链像什么？

00:04:39,030 --> 00:04:41,520
区块链就像是银行里的一排保险箱，

00:04:41,520 --> 00:04:49,440
每个保险箱里都装着不同数量的比特币。

00:04:49,440 --> 00:04:52,770
现在，如果我想构建一个交易，

00:04:52,770 --> 00:04:54,169
将比特币从我这里转移到你那里，

00:04:54,169 --> 00:04:59,400
我需要做的第一步

00:04:59,400 --> 00:05:02,880
是在交易数据的第一部分中选择一批区块链上的比特币。

00:05:02,880 --> 00:05:08,580
每一批比特币都有它们自己的唯一参考编码，

00:05:08,580 --> 00:05:10,380
这样你就可以轻松地选中它们。

00:05:10,380 --> 00:05:12,720
在这个第一部分，

00:05:12,720 --> 00:05:16,260
你会选择你想要发送的那批比特币。

00:05:16,260 --> 00:05:17,850
我会在这里输入一些参考代码。

00:05:17,850 --> 00:05:19,530
选择了比特币批次之后，

00:05:19,530 --> 00:05:29,220
第二步是解锁这批比特币。

00:05:29,220 --> 00:05:38,760
你需要输入解锁代码或者使用你的私钥

00:05:38,760 --> 00:05:44,940
来证明你有权解锁这批比特币。

00:05:44,940 --> 00:05:47,010
完成了前半部分的操作，

00:05:47,010 --> 00:05:54,630
即选择并解锁了比特币之后，

00:05:54,630 --> 00:06:04,800
然后后一半的交易你只需创建一批新的比特币，

00:06:04,800 --> 00:06:10,530
从中分出了一部分创建了新的批次，

00:06:07,440 --> 00:06:10,530
并在上面放了一个新的锁。

00:06:10,530 --> 00:06:14,649
这个新锁是锁定给接收人的地址的，

00:06:14,649 --> 00:06:17,349
就像是一个账户号码一样。

00:06:17,349 --> 00:06:21,519
这是一个非常简单的交易过程：

00:06:21,519 --> 00:06:23,979
你只需选择一些比特币，

00:06:23,979 --> 00:06:26,709
用私钥解锁它们，再创建一个新的交易，

00:06:26,709 --> 00:06:29,109
为这些比特币设置一个新的锁，

00:06:29,109 --> 00:06:34,299
并将它们锁定给接收人。

00:06:34,299 --> 00:06:37,209
因此，当你想要进行交易时，

00:06:37,209 --> 00:06:39,069
最好不要将其想象为拥有一些比特币

00:06:39,069 --> 00:06:40,719
然后通过互联网直接转给别人，

00:06:40,719 --> 00:06:41,979
因为这并不是真正的交易方式。

00:06:41,979 --> 00:06:44,559
实际上，你拥有一组密钥，

00:06:44,559 --> 00:06:47,349
包括地址和私钥。

00:06:47,349 --> 00:06:49,719
接收方也有他们自己的地址和私钥。

00:06:49,719 --> 00:06:53,979
当你想要向他们发送比特币时，

00:06:51,729 --> 00:06:53,979
你只需通过区块链，

00:06:53,979 --> 00:06:58,419
选择那些你能用你的私钥解锁的比特币，

00:06:58,419 --> 00:07:00,159
然后将它们锁定到接收方的地址上，

00:07:00,159 --> 00:07:12,129
这样他们就可以使用他们的私钥来发送这些比特币。

00:07:12,129 --> 00:07:13,449
例如，

00:07:13,449 --> 00:07:15,069
如果他们想要将这些比特币发送给其他人，

00:07:15,069 --> 00:07:16,689
他们只需使用他们的私钥解锁你为他们设置的特定锁，

00:07:16,689 --> 00:07:18,339
然后就可以进行转账了。

00:07:18,339 --> 00:07:26,469
因此，你可以看到比特币交易实际上是形成了一个交易链，

00:07:26,469 --> 00:07:31,569
从一个人传递到另一个人。

00:07:31,569 --> 00:07:33,999
到目前为止，

00:07:33,999 --> 00:07:36,459
我一直将这些比特币的集合称为比特币，

00:07:36,459 --> 00:07:37,929
但它们的技术术语称为输出。

00:07:37,929 --> 00:07:40,569
所以从现在开始，

00:07:40,569 --> 00:07:43,329
我将使用“输出”这个词来描述这些比特币的集合。

00:07:43,329 --> 00:07:45,159
所有这些被锁定的比特币集合都被称为输出，

00:07:45,159 --> 00:07:48,639
这就是所有橙色框框里的内容。

00:07:48,639 --> 00:07:54,879
但需要明确的是，

00:07:54,879 --> 00:07:57,239
当我们在交易中花费一个输出时

00:07:57,239 --> 00:08:00,609
我们称之为输入。

00:08:00,609 --> 00:08:02,849
因此，每一笔交易都会消耗一个或多个输入，

00:08:02,849 --> 00:08:10,110
并创建一个或多个新的输出。

00:08:10,110 --> 00:08:12,300
然后，我们将这笔交易发送到比特币网络，

00:08:12,300 --> 00:08:15,509
希望它能被打包进区块链中的一个新区块。

00:08:15,509 --> 00:08:17,190
假设这是一个新的交易区块，

00:08:17,190 --> 00:08:20,910
那么我们的交易就被记录在区块链上了。

00:08:20,910 --> 00:08:23,400
如果我们将刚刚完成的交易可视化，

00:08:23,400 --> 00:08:28,139
能看到，我们已经花费了某个输出，

00:08:28,139 --> 00:08:29,699
因此我将其标记为灰色，

00:08:29,699 --> 00:08:31,470
表示它不能再被使用。

00:08:31,470 --> 00:08:35,250
在这个新的区块中，

00:08:35,250 --> 00:08:37,380
由于我的交易，

00:08:37,380 --> 00:08:41,070
我生成了一个新的输出，

00:08:41,070 --> 00:08:42,750
这个新的输出属于接收方。

00:08:42,750 --> 00:08:49,470
这就是交易在最基本层面上的工作原理。

00:08:49,470 --> 00:08:51,420
在上一个例子中，

00:08:51,420 --> 00:08:57,060
我发送了比特币，

00:08:57,060 --> 00:08:59,490
并且设定了十个比特币作为我要发送的金额。

00:08:59,490 --> 00:09:02,250
但实际上，你并不需要总是发送整批的比特币，

00:09:02,250 --> 00:09:04,920
如果你想发送的金额少于十个比特币，

00:09:04,920 --> 00:09:06,839
那么你可以这么做：

00:09:06,839 --> 00:09:11,459
你可以创建一个输出，

00:09:11,459 --> 00:09:14,580
向某人发送8-10个比特币，

00:09:14,580 --> 00:09:17,339
显然这样会有2个比特币剩余，

00:09:17,339 --> 00:09:19,650
因此你需要为自己创建一个找零的输出。

00:09:19,650 --> 00:09:24,570
我们已经使用了一个输入，

00:09:24,570 --> 00:09:27,779
建了一个值为8的输出，

00:09:27,779 --> 00:09:30,089
这个输出发送给了接收方，

00:09:30,089 --> 00:09:32,130
然后我们会处理剩余的找零部分，

00:09:32,130 --> 00:09:34,350
将其锁定到我们自己的地址上。

00:09:34,350 --> 00:09:39,959
这就是你在进行交易时如何处理找零的问题，

00:09:39,959 --> 00:09:47,850
基本上是你自己为自己找零。

00:09:47,850 --> 00:09:49,770
到目前为止，

00:09:49,770 --> 00:09:51,990
我一直在使用整数比特币作为例子，

00:09:51,990 --> 00:09:55,380
但实际上，比特币可以被分割成非常小的单位。

00:09:55,380 --> 00:09:57,360
例如，

00:09:57,360 --> 00:09:59,190
我可以发送一笔非常小的金额，

00:09:59,190 --> 00:10:01,290
并将剩余的部分作为找零返还给自己。

00:10:01,290 --> 00:10:05,130
这在比特币系统中是完全可行的，

00:10:05,130 --> 00:10:08,370
没有任何实质性的限制，

00:10:08,370 --> 00:10:11,459
也没有关于分割比特币的限制。

00:10:11,459 --> 00:10:14,010
比特币的最小单位被称为“Satoshi”，

00:10:14,010 --> 00:10:17,040
它等于比特币的十亿分之一。

00:10:17,040 --> 00:10:18,110
这就是你能将比特币分割的最小程度，

00:10:18,110 --> 00:10:20,060
无法再细分。

00:10:20,060 --> 00:10:22,090
同样，

00:10:23,500 --> 00:10:27,350
假设你拥有10个比特币，

00:10:27,350 --> 00:10:29,570
但你想向某人发送30个比特币。

00:10:29,570 --> 00:10:35,810
如果你有两个或更多的比特币输出归你所有，

00:10:35,810 --> 00:10:42,050
你可以将它们合并作为一笔交易的输入，

00:10:42,050 --> 00:10:45,260
来创建一个更大的输出，

00:10:45,260 --> 00:10:47,120
而不是分开进行两次交易。

00:10:47,120 --> 00:10:54,620
只要你有权解锁这些比特币，

00:10:54,620 --> 00:10:59,450
你就可以从区块链中选择任意数量的输入来进行你的交易。

00:10:59,450 --> 00:11:03,320
再次以10个和25个比特币为例，

00:11:03,320 --> 00:11:05,450
我想向某人发送30个比特币，

00:11:05,450 --> 00:11:08,330
所以在这笔交易中显然会有5个比特币的剩余。

00:11:08,330 --> 00:11:10,310
这个剩余5个比特币需要作为找零处理，

00:11:10,310 --> 00:11:12,200
归还给自己。

00:11:12,200 --> 00:11:14,840
正如我之前提到的，

00:11:14,840 --> 00:11:16,820
每一笔交易都需要处理自己的找零。

00:11:16,820 --> 00:11:22,520
当这笔交易被记录到区块链上时，

00:11:22,520 --> 00:11:24,200
会有一个30比特币的输出，

00:11:24,200 --> 00:11:27,080
锁定给接收人，

00:11:27,080 --> 00:11:29,210
同时还会有一个5个比特币的输出，

00:11:29,210 --> 00:11:32,480
锁定给发送人自己。

00:11:32,480 --> 00:11:34,310
而我们从区块链中选择的这两个输入

00:11:34,310 --> 00:11:37,400
在这笔交易后就会被标记为已花费，

00:11:37,400 --> 00:11:39,020
因为它们已经被用掉了。

00:11:39,020 --> 00:11:47,960
这就是比特币在区块链中的交易方式和工作原理。

00:11:47,960 --> 00:11:51,380
所以，

00:11:51,380 --> 00:11:53,810
你在最后一张幻灯片中说，

00:11:53,810 --> 00:12:00,560
你提到一笔交易可以有多个输入，是吗？

00:12:00,560 --> 00:12:04,250
你可以有任意多的输入，

00:12:04,250 --> 00:12:06,680
并创建一些输出。

00:12:06,680 --> 00:12:08,870
这些输入都必须是你自己的，是这样吗？

00:12:08,870 --> 00:12:11,510
是的，只要你能解锁它们就行。

00:12:11,510 --> 00:12:13,130
我想说的是，

00:12:13,130 --> 00:12:14,210
只要它们是你的，

00:12:14,210 --> 00:12:16,010
且你拥有解锁这些输入的密钥，

00:12:16,010 --> 00:12:18,350
那就没问题，我们就可以认为这些输入是你的。

00:12:18,350 --> 00:12:26,050
因此，你可以将别人转给你的多个交易作为输入。

00:12:26,050 --> 00:12:28,250
例如，

00:12:28,250 --> 00:12:31,340
如果有三个人各自给了我5美元，

00:12:31,340 --> 00:12:35,060
而我想支付给某人14美元，

00:12:35,060 --> 00:12:38,480
我可以将这三个交易作为输入，

00:12:38,480 --> 00:12:42,530
创建一个14美元的输出给对方，

00:12:42,530 --> 00:12:51,740
时创建一个1美元的输出退还给我自己。

00:12:51,740 --> 00:12:59,180
这里我仅展示了一个独立的交易案例。

00:12:59,180 --> 00:13:01,630
如果你回溯历史，，

00:13:01,630 --> 00:13:04,010
将所有交易都可视化，

00:13:04,010 --> 00:13:07,580
就像它们被添加到区块链上的样子，

00:13:07,580 --> 00:13:11,420
你会看到这是第一笔交易，

00:13:11,420 --> 00:13:16,730
然后有另一笔交易消费了这个输出，

00:13:16,730 --> 00:13:18,770
接着又有一个区块中的交易，

00:13:18,770 --> 00:13:25,220
每笔交易都会使用之前的输出，

00:13:25,220 --> 00:13:28,370
如此循环往复，

00:13:28,370 --> 00:13:31,130
每一笔新的交易都在构建这样一个图形结构。

00:13:31,130 --> 00:13:32,930
所以，

00:13:32,930 --> 00:13:35,540
正如你所问的，

00:13:35,540 --> 00:13:38,150
你确实可以从不同的交易中提取不同的输出，

00:13:38,150 --> 00:13:42,580
将它们组合在一起，形成一个新的单独交易。

00:13:42,580 --> 00:13:44,510
然而，正如你所见，

00:13:44,510 --> 00:13:47,030
每笔交易都是相互关联的，

00:13:47,030 --> 00:13:50,030
它们形成了一个直接的输出链条，

00:13:50,030 --> 00:13:55,640
包括输入和输出等。

00:13:55,640 --> 00:13:57,530
因此，当你执行比特币交易时，

00:13:57,530 --> 00:14:02,330
你只需要从区块链网络中选择任何未被使用的输出，

00:14:02,330 --> 00:14:04,610
然后基于这些输出创建新的输出。

00:14:04,610 --> 00:14:07,850
这样的一对一连接，

00:14:07,850 --> 00:14:12,290
一笔接一笔的交易，

00:14:12,290 --> 00:14:15,110
就构成了比特币交易网络的影响，

00:14:15,110 --> 00:14:20,810
就像这样的比特币交易图。

00:14:20,810 --> 00:14:25,580
这样的比特币交易网络图是理解区块链的一个很好的方式。

00:14:25,580 --> 00:14:26,990
我意思是，你可以将其想象为单一的输出，

00:14:26,990 --> 00:14:32,300
但实际上，这些输出是通过一系列交易相互连接的。

00:14:32,300 --> 00:14:35,060
区块链看起来就像这样的，

00:14:35,060 --> 00:14:39,220
当然实际上要复杂庞大得多。

00:14:40,910 --> 00:14:43,800
这些橙色的输出尚未被使用，

00:14:43,800 --> 00:14:46,079
因此它们被称为未花费的交易输出，

00:14:46,079 --> 00:14:49,230
或者被称为UTXO。

00:14:49,230 --> 00:14:54,839
所以，当你看到UTXO这个术语时，

00:14:54,839 --> 00:14:57,170
它指的就是这些未被使用的比特币。

00:14:57,170 --> 00:15:00,120
这些UTXO非常重要，

00:15:00,120 --> 00:15:07,199
因为它们通常被比特币客户端保存在内存中，

00:15:07,199 --> 00:15:16,019
以便可以快速访问。

00:15:16,019 --> 00:15:19,709
到目前为止，

00:15:19,709 --> 00:15:21,300
我一直在引用这些原始的交易。

00:15:21,300 --> 00:15:23,850
那么，最初的比特币是如何产生的呢？

00:15:23,850 --> 00:15:31,829
每当一个新的区块被挖掘出来并加入到区块链中时，

00:15:31,829 --> 00:15:39,510
就会产生一定数量的新比特币，

00:15:39,510 --> 00:15:41,399
这就是所谓的区块奖励。

00:15:41,399 --> 00:15:44,730
当矿工成功挖掘到一个区块时，

00:15:44,730 --> 00:15:48,110
他们会通过区块奖励创建一个输出，

00:15:48,110 --> 00:15:50,399
并将其锁定到自己的地址上。

00:15:50,399 --> 00:15:56,760
他们是如何做到这一点的呢？

00:15:56,760 --> 00:16:00,269
在每个区块中，

00:16:00,269 --> 00:16:02,579
矿工会构建多个交易块，

00:16:02,579 --> 00:16:04,170
但在这些交易的最顶端，

00:16:04,170 --> 00:16:06,480
有一个特殊的交易，

00:16:06,480 --> 00:16:08,339
就是所谓的coinbase交易，

00:16:08,339 --> 00:16:11,160
这是矿工的专有交易。

00:16:11,160 --> 00:16:12,480
通过coinbase交易，

00:16:12,480 --> 00:16:14,760
矿工可以领取区块奖励。

00:16:14,760 --> 00:16:18,000
正如我所提到的，

00:16:18,000 --> 00:16:19,610
每当一个新区块被挖出，

00:16:19,610 --> 00:16:25,170
就会生成一些之前不存在的新比特币。

00:16:25,170 --> 00:16:27,350
那么，

00:16:27,690 --> 00:16:36,030
比特币交易树的第一层只包含coinbase交易吗？

00:16:36,030 --> 00:16:40,800
是的，

00:16:40,800 --> 00:16:47,340
第一层仅包含coinbase交易，

00:16:47,340 --> 00:17:01,500
而coinbase交易本身就是这棵树的根。

00:17:01,500 --> 00:17:06,540
正如你在这个图表上看到，

00:17:06,540 --> 00:17:14,490
所有这些交易都有一个源头，

00:17:14,490 --> 00:17:18,569
都源自区块奖励。

00:17:18,569 --> 00:17:27,200
在这个简要介绍的最后，

00:17:27,200 --> 00:17:32,010
你可能对交易费用的工作原理感兴趣。

00:17:32,010 --> 00:17:36,660
当你发起一笔交易时，

00:17:36,660 --> 00:17:44,190
你想支付手续费，

00:17:44,190 --> 00:17:50,970
你通常不会花掉交易输入中的全部金额。

00:17:48,930 --> 00:17:50,970
例如，如果你有10个比特币作为输入，

00:17:50,970 --> 00:17:53,760
而你创建了一个8个比特币的输出，

00:17:53,760 --> 00:17:55,770
那么你就已经使用了全部金额。

00:17:55,770 --> 00:17:57,840
但是，如果你没有使用掉所有的输入金额，

00:17:57,840 --> 00:18:02,850
而是把剩余的部分自动地作为手续费。

00:18:02,850 --> 00:18:05,130
因此，

00:18:05,130 --> 00:18:07,380
当你想在交易中支付手续费时，

00:18:07,380 --> 00:18:09,450
你无需为其创建一个独立的输出，

00:18:09,450 --> 00:18:13,710
只需留下一部分未使用的输入即可。

00:18:13,710 --> 00:18:16,830
例如，

00:18:16,830 --> 00:18:18,720
如果一笔交易的手续费设定为0.1比特币，

00:18:18,720 --> 00:18:21,029
当我们将其广播到网络时，

00:18:21,029 --> 00:18:27,779
这笔交易会被加入到网络中所有节点的内存池中。

00:18:27,779 --> 00:18:30,690
之所以需要在交易中支付手续费，

00:18:30,690 --> 00:18:33,210
是因为矿工在创建新的区块候选时，

00:18:33,210 --> 00:18:34,799
只能包含有限数量或大小的交易。

00:18:34,799 --> 00:18:38,730
过去，

00:18:38,730 --> 00:18:42,600
这个限制基本上是1MB大小的交易，

00:18:42,600 --> 00:18:45,059
而现在这个限制已经转变为以“权重”计量，

00:18:45,059 --> 00:18:48,390
实际上大致相当于1.7MB的交易数据。

00:18:48,390 --> 00:18:49,799
因此，

00:18:49,799 --> 00:18:52,500
当内存池中的交易总量超过1.7MB时，

00:18:52,500 --> 00:18:54,240
矿工会优先选择

00:18:54,240 --> 00:18:58,559
那些提供更高手续费的交易进行打包。

00:18:58,559 --> 00:19:00,140
他们这么做的原因是，

00:19:00,140 --> 00:19:04,200
矿工可以收取这些交易的手续费。

00:19:04,200 --> 00:19:09,720
假设这些黄色的小圆盘代表高手续费的交易，

00:19:09,720 --> 00:19:11,820
矿工可以选择这些交易，

00:19:11,820 --> 00:19:14,520
并将它们的手续费收入自己的口袋，

00:19:14,520 --> 00:19:16,770
即放入coinbase交易中。

00:19:16,770 --> 00:19:19,620
因此，

00:19:19,620 --> 00:19:21,600
矿工在coinbase交易中

00:19:21,600 --> 00:19:26,690
不仅会给自己发送当前的区块奖励（目前为12.5比特币），

00:19:26,690 --> 00:19:34,919
还会包含他们所打包交易的所有手续费。

00:19:34,919 --> 00:19:37,980
接着，当这个区块被成功挖出后，

00:19:37,980 --> 00:19:40,230
coinbase交易就会回收所有的手续费，

00:19:40,230 --> 00:19:42,210
并且创建一批新的比特币，

00:19:42,210 --> 00:19:45,260
这批新比特币包括了区块奖励。

00:19:45,260 --> 00:19:48,720
这样解释是否清楚了呢？

00:19:48,720 --> 00:19:52,950
好的，那么我们已经讲解了所有基础知识，

00:19:52,950 --> 00:19:54,840
包括交易的结构，

00:19:54,840 --> 00:19:58,200
以及如何通过输入来创建输出的直观表示。

00:19:58,200 --> 00:20:04,710
接下来，我要讲解的内容是关于数据，

00:20:04,710 --> 00:20:08,190
如果我们查看内部数据，

00:20:08,190 --> 00:20:15,530
根据内部数据构建自己的交易策略。

00:20:15,530 --> 00:20:17,450
这部分内容会比较技术化，

00:20:17,450 --> 00:20:21,680
因此如果你是技术专业人士，

00:20:21,680 --> 00:20:25,550
应该能够满足你对交易内部机制的兴趣

00:20:25,550 --> 00:20:30,440
这对于程序员和技术人员来说尤其适用。

00:20:30,440 --> 00:20:36,440
从之前的图表中我们可以看到，

00:20:36,440 --> 00:20:38,540
我用绿线表示了数据，

00:20:38,540 --> 00:20:40,460
而这个黑色的框架就好比我的代码编辑器。

00:20:40,460 --> 00:20:44,150
我们将从头开始创建一个交易。

00:20:44,150 --> 00:20:46,100
每笔交易都是以一个版本号开头的，

00:20:46,100 --> 00:20:49,070
这个版本号定义了交易结构的格式。

00:20:49,070 --> 00:20:52,580
目前，版本号通常是1，

00:20:52,580 --> 00:20:57,560
我相信大多数交易都采用的是版本号1。

00:20:54,590 --> 00:20:57,560
因此，我们在这里输入1，

00:20:57,560 --> 00:20:59,180
这是没有问题的。

00:20:59,180 --> 00:21:06,650
但是，由于这是交易数据，

00:21:06,650 --> 00:21:10,130
它具有特定的结构，

00:21:10,130 --> 00:21:14,450
所以这个版本号实际上应该是四个字节的长度。

00:21:14,450 --> 00:21:16,520
因此，我们在这里输入1，

00:21:16,520 --> 00:21:17,690
但我们需要用零来填充它，

00:21:17,690 --> 00:21:19,250
以确保它的长度是四个字节。

00:21:19,250 --> 00:21:22,550
每两个字符代表一个字节，

00:21:22,550 --> 00:21:25,010
所以这里应该是八个字符的长度，

00:21:25,010 --> 00:21:28,220
即四个字节。

00:21:28,220 --> 00:21:32,510
之所以有这样的字段大小，

00:21:30,530 --> 00:21:36,980
是因为交易中的每个元素都有自己的字段大小，

00:21:36,980 --> 00:21:43,580
这样可以使得解码交易变得更加简单。

00:21:43,580 --> 00:21:45,050
其次，除了长度是四个字节之外，

00:21:45,050 --> 00:21:48,110
它还必须是十六进制表示的。

00:21:48,110 --> 00:21:49,340
这里的计数是1，在十六进制中也表示为1。

00:21:49,340 --> 00:21:53,570
最后，可能是最让人困惑的一点是，

00:21:53,570 --> 00:21:56,390
从我们人类的角度来看，

00:21:56,390 --> 00:22:00,890
这些数据必须采用网络字节顺序，

00:22:00,890 --> 00:22:03,670
也就是你需要反字节顺序反转过来。

00:22:05,479 --> 00:22:07,519
首先，

00:22:07,519 --> 00:22:12,889
你需要指定交易中要使用的输入数量。

00:22:12,889 --> 00:22:16,190
假设你有三个输入，

00:22:16,190 --> 00:22:18,320
我们在这有三个，

00:22:18,320 --> 00:22:21,349
但在这个例子中，我们只会使用一个输出，

00:22:21,349 --> 00:22:22,849
因此我在这里输入的是1，

00:22:22,849 --> 00:22:24,769
占用一个字节。

00:22:24,769 --> 00:22:31,209
这里有一个特殊的字段，

00:22:31,209 --> 00:22:41,749
叫做可变整数（varint），

00:22:41,749 --> 00:22:48,729
有时也被称为紧凑大小（compact size）。

00:22:48,729 --> 00:22:51,979
可变整数和变量是我习惯使用的。

00:22:51,979 --> 00:22:55,909
如果你要选择的输出数量小于252，

00:22:55,909 --> 00:23:02,149
或者用十六进制表示就是FC，

00:23:02,149 --> 00:23:04,159
那么你只需要一个字节，

00:23:04,159 --> 00:23:07,789
所以可以直接写在这里。

00:23:07,789 --> 00:23:12,169
如果你想发送超过252个输入，

00:23:12,169 --> 00:23:14,599
那么，

00:23:14,599 --> 00:23:17,389
你需要在前面加上FD标识，

00:23:17,389 --> 00:23:20,989
并在其后用两个字节以十六进制形式

00:23:20,989 --> 00:23:27,859
表示你使用了多少个输入。

00:23:27,859 --> 00:23:29,959
同样地，如果你需要的数字超过两个字节能表示的范围，

00:23:29,959 --> 00:23:31,669
你就在前面加上FE，

00:23:31,669 --> 00:23:33,649
这意味着接下来的四个字节会告诉你输入的具体数量。

00:23:33,649 --> 00:23:36,649
如果这个数字甚至比四个字节还要大，

00:23:36,649 --> 00:23:38,329
那么你就在前面加上FF，

00:23:38,329 --> 00:23:45,019
随后的八个字节将告诉你你想要使用的输入数量。

00:23:45,019 --> 00:23:49,429
但对于大多数交易来说，

00:23:49,429 --> 00:23:55,999
你不太可能会用到这么多输入，

00:23:55,999 --> 00:24:01,380
如果你是自己构建交易的话，

00:24:01,380 --> 00:24:03,299
你可能只会用到一个字节，

00:24:03,299 --> 00:24:05,250
因此大多数情况下，

00:24:05,250 --> 00:24:08,900
这个输入字段的大小仅为一个字节。

00:24:08,960 --> 00:24:12,690
好的，

00:24:12,690 --> 00:24:14,850
这是比较技术的部分，

00:24:14,850 --> 00:24:16,110
现在我们继续输入，

00:24:16,110 --> 00:24:21,360
这个步骤相对简单一些。

00:24:21,360 --> 00:24:24,059
我们需要从区块链中选择一个交易作为输入，

00:24:24,059 --> 00:24:26,610
这就需要我们获取该交易的交易ID。

00:24:26,610 --> 00:24:29,429
每个交易都有一个唯一的ID号，

00:24:29,429 --> 00:24:32,460
称为交易ID，

00:24:32,460 --> 00:24:38,390
你只需要把它放在输入代码的第一部分就可以选择它，

00:24:38,390 --> 00:24:44,880
这个ID是一个32字节长的十六进制数，

00:24:44,880 --> 00:24:47,070
按照网络字节顺序排列，

00:24:47,070 --> 00:24:49,830
因此在使用前需要将其字节序反转。

00:24:49,830 --> 00:24:52,260
你可以将这个ID输入到区块链浏览器中，

00:24:52,260 --> 00:24:54,419
由于它已经是反转后的形式，

00:24:54,419 --> 00:24:56,909
因为它已经被反转了。

00:24:56,909 --> 00:25:01,289
你可以很容易地找到对应的交易。

00:25:01,289 --> 00:25:05,010
我们需要选择交易中的一个特定输出

00:25:05,010 --> 00:25:11,669
一个交易正如我之前展示的，

00:25:11,669 --> 00:25:12,780
一笔交易可以有多个输出。

00:25:12,780 --> 00:25:15,570
你需要做的是使用Vout

00:25:15,570 --> 00:25:19,559
这是输出向量的简称，

00:25:19,559 --> 00:25:21,780
每个输出都有一个从0开始的索引号。

00:25:21,780 --> 00:25:24,360
如果交易只有一个输出，

00:25:24,360 --> 00:25:27,450
我在这里输入0，

00:25:27,450 --> 00:25:30,110
注意，这个索引号也是一个4字节长的十六进制数。

00:25:30,110 --> 00:25:34,100
输入后，我们就完成了输入部分的主要内容。

00:25:34,580 --> 00:25:38,280
接下来是下一个主要部分，

00:25:38,280 --> 00:25:41,340
基本上我们已经确认了。

00:25:41,340 --> 00:25:44,630
好的，快速提一个问题：

00:25:44,630 --> 00:25:48,690
假设我们有多个交易，

00:25:48,690 --> 00:25:51,150
每个交易都有多个输出，

00:25:51,150 --> 00:25:54,030
那是可能的，对吧？

00:25:54,030 --> 00:25:57,360
比如说，我们有两笔交易，

00:25:57,360 --> 00:25:59,850
每笔交易都有两个输出。

00:25:59,850 --> 00:26:04,230
在Z行中，

00:26:04,230 --> 00:26:11,490
其中一个输出会变成0。

00:26:11,490 --> 00:26:14,130
在填写输入字段时，

00:26:14,130 --> 00:26:17,280
前一个输入的输入计数将变为4。

00:26:17,280 --> 00:26:20,030
用8减去我们使用的所有交易的输入数量？

00:26:20,030 --> 00:26:24,630
是的，是的，是的，

00:26:24,630 --> 00:26:27,780
然后我们会列出所有的交易ID，

00:26:27,780 --> 00:26:30,240
这些ID会一个接一个地排列。

00:26:30,240 --> 00:26:30,630
好的，

00:26:30,630 --> 00:26:32,610
如果你想选择两个不同的输出，

00:26:32,610 --> 00:26:37,700
这段代码就是为了选择单个输出。

00:26:37,700 --> 00:26:40,350
就是这个，

00:26:40,350 --> 00:26:42,840
如果你需要两个输出，

00:26:42,840 --> 00:26:49,770
你只需在这段代码之后重复相同的步骤。

00:26:49,770 --> 00:26:51,659
那么我们在这里，

00:26:51,659 --> 00:26:53,460
已经成功地选择了这个特定的输出，

00:26:53,460 --> 00:26:54,480
通过交易ID可以找到这个交易，

00:26:54,480 --> 00:27:00,900
而特定的按钮则引用了这个输出，

00:27:00,900 --> 00:27:02,909
但显然它是有锁的。

00:27:02,909 --> 00:27:05,580
为了能够使用比特币并将其转发给他人，

00:27:05,580 --> 00:27:07,140
你必须先解锁它。

00:27:07,140 --> 00:27:10,890
在比特币交易中，

00:27:10,890 --> 00:27:15,360
你需要构建完整的交易结构才能解锁比特币。

00:27:15,360 --> 00:27:18,510
在解锁之前，你无法执行交易。

00:27:18,510 --> 00:27:19,950
现在我们不讨论这个环节。

00:27:19,950 --> 00:27:24,360
解锁所需的代码被称为签名脚本，

00:27:24,360 --> 00:27:28,770
这里的签名以及相关的所有代码都被称作脚本，

00:27:28,770 --> 00:27:30,270
因为它们是用比特币的脚本语言编写的。

00:27:30,270 --> 00:27:33,720
签名脚本也被称作第二脚本，

00:27:33,720 --> 00:27:35,010
你可以为它取一个更易懂的名字，

00:27:35,010 --> 00:27:39,600
比如“最终解锁代码”。

00:27:39,600 --> 00:27:44,100
每个交易输入都有一个序列号，

00:27:44,100 --> 00:27:46,470
这个序列号并不经常被使用。

00:27:46,470 --> 00:27:52,679
如果我将这个序列号设置为一个小于最大可能值的数字，

00:27:52,679 --> 00:27:58,169
那么在未来就有可能替换这笔交易。

00:27:58,169 --> 00:28:00,330
例如，

00:28:00,330 --> 00:28:02,130
如果你在一个交易中设置了很低的手续费，

00:28:02,130 --> 00:28:04,740
你可以创建一个新的交易，

00:28:04,740 --> 00:28:06,200
这个新交易具有更高的序列号，

00:28:06,200 --> 00:28:10,080
从而能够替代已经在网络中的那笔交易。

00:28:10,080 --> 00:28:13,770
我通常会把这个序列号设置为最大的十六进制值，

00:28:13,770 --> 00:28:17,580
我会这样做。

00:28:17,580 --> 00:28:21,370
从这里开始，

00:28:21,370 --> 00:28:24,350
我通常会全部将这个设置为FS，

00:28:24,350 --> 00:28:25,850
如果你需要选择另一个输入，

00:28:25,850 --> 00:28:29,660
只需在这段代码后重复相同的过程即可，

00:28:29,660 --> 00:28:34,990
这样可以快速完成解析。

00:28:34,990 --> 00:28:37,400
接下来，

00:28:37,400 --> 00:28:38,930
我们完成了输入的选择，

00:28:38,930 --> 00:28:42,560
现在要创建一些输出。

00:28:42,560 --> 00:28:44,330
输出的数量是一个可变的整数，

00:28:44,330 --> 00:28:48,500
所以如果你想创建超过252个输出，

00:28:48,500 --> 00:28:50,540
就必须使用可变整数的编码方式。

00:28:50,540 --> 00:28:52,430
但由于我这里只创建了两个输出，

00:28:52,430 --> 00:28:55,270
所以可以简单地使用一个字节来表示。

00:28:55,270 --> 00:28:57,680
我之前没说是想要在数据传输中节省空间，

00:28:57,680 --> 00:29:01,400
以便更高效地利用数据。

00:29:01,400 --> 00:29:08,840
在处理数据以确保输出结构良好时，

00:29:08,840 --> 00:29:11,030
首先你需要输入你想要发送的比特币数量。

00:29:11,030 --> 00:29:13,490
但是，你输入的不是比特币的数量，

00:29:13,490 --> 00:29:14,780
而是输入聪的数量。

00:29:14,780 --> 00:29:18,740
比如说，我想要发送大约0.02个比特币。

00:29:18,740 --> 00:29:20,300
你必须把它转换成聪，

00:29:20,300 --> 00:29:26,570
因为聪是比特币的最小单位。

00:29:26,570 --> 00:29:28,880
这段输出的第一部分，

00:29:28,880 --> 00:29:31,220
必须是一个有效的十进制数值，

00:29:31,220 --> 00:29:32,960
并且长度为8个字节。

00:29:32,960 --> 00:29:36,500
由于这些字节是以反字节排列的，

00:29:36,500 --> 00:29:41,630
所以在阅读代码时可能看起来像是乱码。

00:29:41,630 --> 00:29:43,730
但如果你把字节顺序反过来，

00:29:43,730 --> 00:29:47,000
并将其转换成十进制数，它就会显示出实际的数值。

00:29:47,000 --> 00:29:50,210
在这之后，

00:29:50,210 --> 00:29:53,150
你提到了这个8字节长度的数字，

00:29:53,150 --> 00:29:55,100
这让我想到可能存在一定的限制，

00:29:55,100 --> 00:29:58,880
即你在一次交易中能够发送的最大数额。

00:29:58,880 --> 00:30:01,700
这个交易数额是用8字节的十六进制表示的，

00:30:01,700 --> 00:30:03,470
我认为这是一个极大的数值。

00:30:03,470 --> 00:30:06,440
应该足以覆盖大多数情况。

00:30:06,440 --> 00:30:09,470
我感觉，

00:30:09,470 --> 00:30:13,460
如果真的遇到问题，

00:30:13,460 --> 00:30:16,060
那将是一个需要解决的大难题。

00:30:17,500 --> 00:30:22,730
在设定了金额之后，

00:30:22,730 --> 00:30:27,280
下一步就是对其进行加密锁定。

00:30:27,280 --> 00:30:30,440
锁定机制有自己的脚本语言，

00:30:30,440 --> 00:30:32,240
其大小是可变的。

00:30:32,240 --> 00:30:36,159
由于锁定脚本的大小是可变的，

00:30:34,450 --> 00:30:38,980
它们并没有像交易ID或版本号那样的固定大小，

00:30:38,980 --> 00:30:42,330
因此我们必须使用可变长度的整数来表示。

00:30:42,330 --> 00:30:50,679
大多数签名的典型长度大约是19到25字节，

00:30:50,679 --> 00:30:53,619
这个长度仅仅是为了告知接下来的锁定脚本的大小。

00:30:53,619 --> 00:30:58,869
然后你将锁定脚本放在相应的位置。

00:30:58,869 --> 00:31:00,759
这里包含了一些代码，

00:31:00,759 --> 00:31:04,720
用于创建一个脚本，

00:31:04,720 --> 00:31:06,639
将交易锁定到一个特定的地址。

00:31:06,639 --> 00:31:10,359
这是我们锁定的地址，

00:31:10,359 --> 00:31:13,269
我们在这里使用了公钥，

00:31:13,269 --> 00:31:16,869
但现在我不打算深入探讨这部分内容，

00:31:16,869 --> 00:31:22,029
只是说明这些代码与特定地址是相对应的。

00:31:22,029 --> 00:31:25,659
这些灰色的东西，

00:31:25,659 --> 00:31:28,359
它们只是锁定代码，

00:31:28,359 --> 00:31:31,090
锁定到这个特定公钥的代码。

00:31:31,090 --> 00:31:32,769
所以如果你想创建自己的锁，

00:31:32,769 --> 00:31:36,190
你可以复制粘贴这段代码，

00:31:36,190 --> 00:31:41,830
然后用你想发送的人的公钥替换这个公钥。

00:31:41,830 --> 00:31:48,999
这个公钥可以从这个地址派生出来。

00:31:48,999 --> 00:31:54,059
所以这个锁定代码显然会对不同的公钥有所不同。

00:31:54,059 --> 00:31:57,429
在典型的交易中

00:31:57,429 --> 00:31:59,639
7609编码会改变的只是这里的绿色部分，

00:31:59,639 --> 00:32:05,799
这个76 a 914 a a C指的是脚本中的特定代码。

00:32:05,799 --> 00:32:07,600
基本上就是说，

00:32:07,600 --> 00:32:12,100
当这个地址已经被锁定到这个公钥时，

00:32:12,100 --> 00:32:14,109
如果你想发送它，

00:32:14,109 --> 00:32:20,799
我必须提供一个签名。

00:32:20,799 --> 00:32:25,559
这基本上就是将要运行的脚本，

00:32:25,559 --> 00:32:27,909
你知道吗

00:32:27,909 --> 00:32:32,769
你把它放在堆栈上，

00:32:32,769 --> 00:32:34,570
检查它是否相等。

00:32:34,570 --> 00:32:37,509
这些是操作码，

00:32:37,509 --> 00:32:39,249
它们指的是OP重复，

00:32:39,249 --> 00:32:42,279
相信我，我在这里忽略了这些，

00:32:42,279 --> 00:32:44,450
我认为签名脚本和代码值得我后面单独解释一下。

00:32:44,450 --> 00:32:48,379
这是锁定代码，

00:32:48,379 --> 00:32:50,960
我并不期望你现在就能理解。

00:32:50,960 --> 00:32:55,669
就像你之前问的，

00:32:55,669 --> 00:32:58,580
因为我说了两个输出，

00:32:58,580 --> 00:33:03,980
我在这里创建了另一个输出，

00:33:03,980 --> 00:33:06,320
结构和上次一样。

00:33:06,320 --> 00:33:08,419
这部分是我发送的金额，

00:33:08,419 --> 00:33:11,389
然后这是即将出现的锁定代码的大小，

00:33:11,389 --> 00:33:14,659
这是实际的锁定代码，

00:33:14,659 --> 00:33:16,190
地址不同。

00:33:16,190 --> 00:33:18,230
你可以看到这个以8/8 AC结尾，

00:33:18,230 --> 00:33:20,359
就像那个一样，

00:33:20,359 --> 00:33:24,859
它以7 6 8 9开始。

00:33:24,859 --> 00:33:25,009
所以，我们在这里改变的只是我锁定的地址。

00:33:25,009 --> 00:33:32,239
我们在这里改变的只是我锁定的地址。

00:33:32,239 --> 00:33:33,950
最后，

00:33:33,950 --> 00:33:35,809
我们有所谓的时间锁，

00:33:35,809 --> 00:33:38,929
这是交易的最后部分。

00:33:38,929 --> 00:33:44,149
锁定时间基本上允许你对交易进行后期处理。

00:33:44,149 --> 00:33:49,460
你在这里设置的锁定时间小于5亿，

00:33:49,460 --> 00:33:51,649
那么这就是指一个特定的区块高度。

00:33:51,649 --> 00:33:54,320
如果你回到过去，

00:33:54,320 --> 00:33:56,629
我们说我们已经完成了14个区块，

00:33:56,629 --> 00:33:58,609
我们在这里设置的锁定时间是16，

00:33:58,609 --> 00:34:03,590
那么这意味着这个交易只能在：区块高度为16或更高的情况下被挖出。

00:34:03,590 --> 00:34:06,700
区块高度为16或更高的情况下被挖出。

00:34:07,389 --> 00:34:12,859
同样，如果你将锁定时间设定为大于500万，

00:34:12,859 --> 00:34:16,909
那么这里的500万表示的是最多500万个区块，

00:34:16,909 --> 00:34:18,770
如果超过这个数，

00:34:18,770 --> 00:34:23,960
那么你就在指定一个特定的Unix时间，

00:34:23,960 --> 00:34:29,330
也就是从1970年1月1日开始的秒数。

00:34:29,330 --> 00:34:32,960
无论如何，这个锁定时间都会将交易

00:34:32,960 --> 00:34:35,179
锁定到一个特定的区块或一个特定的时间点。

00:34:35,179 --> 00:34:38,449
但如果你不使用它，

00:34:38,449 --> 00:34:42,050
你可能就不会使用它，

00:34:42,050 --> 00:34:44,060
只需将其设定为零，

00:34:44,060 --> 00:34:47,889
这意味着它可以立即被挖掘。

00:34:47,889 --> 00:34:52,790
然后我们就有了一个交易。

00:34:52,790 --> 00:34:55,099
再次回顾一下，四个主要部分：

00:34:55,099 --> 00:34:58,700
你有一个版本号，

00:34:58,700 --> 00:35:01,130
通常是1，然后你有输入，

00:35:01,130 --> 00:35:03,920
你只选择一个输入，

00:35:03,920 --> 00:35:06,080
涉及到解锁代码的我还没有说，

00:35:06,080 --> 00:35:08,420
我们会回来的。

00:35:08,420 --> 00:35:10,280
在输入之后，你有输出，从中创建输出，

00:35:10,280 --> 00:35:12,530
然后你有一个锁定时间，

00:35:12,530 --> 00:35:14,960
这就是任何交易的四个主要部分。

00:35:14,960 --> 00:35:17,589
好的，

00:35:17,660 --> 00:35:22,089
现在进入这幻灯片的最后一部分，

00:35:22,089 --> 00:35:24,619
接下来，

00:35:24,619 --> 00:35:27,019
我将介绍这个签名的实际过程，

00:35:27,019 --> 00:35:28,700
以便能够解锁这个输出，

00:35:28,700 --> 00:35:31,640
也就是这个输入。

00:35:31,640 --> 00:35:34,640
在这部分，我会快速过一些东西，

00:35:34,640 --> 00:35:37,309
可能无法在时间内解释清楚，

00:35:37,309 --> 00:35:39,740
因为我认为签名本身可能还需要一些视频。

00:35:39,740 --> 00:35:42,769
但是，

00:35:42,769 --> 00:35:44,599
如果你正在重看这个视频，

00:35:44,599 --> 00:35:47,269
并且你想从头开始构建你自己的交易，

00:35:47,269 --> 00:35:50,059
我只是想涵盖你需要做的所有事情，

00:35:50,059 --> 00:35:52,750
以便能够创建签名，

00:35:51,200 --> 00:35:52,750
来签署这个交易。

00:35:52,750 --> 00:35:57,380
所以，如果有些东西不明白，

00:35:57,380 --> 00:35:59,269
不用担心，

00:35:59,269 --> 00:36:02,690
也许当你回来的时候就会明白了。

00:36:02,690 --> 00:36:07,670
所以，我们有这个交易，

00:36:07,670 --> 00:36:09,500
我们有这个需要解锁的输入。

00:36:09,500 --> 00:36:11,990
这个输入已经被锁定到我们的地址，

00:36:11,990 --> 00:36:16,400
我们有对应这个地址的私钥，

00:36:16,400 --> 00:36:23,000
我们需要使用私钥，

00:36:23,000 --> 00:36:28,940
来证明我们是这个地址的所有者。

00:36:28,940 --> 00:36:33,740
或者一个非常简单但不好的方法，

00:36:33,740 --> 00:36:37,369
就是将你的私钥直接塞入交易中，

00:36:37,369 --> 00:36:38,720
这样可以证明你拥有私钥，

00:36:38,720 --> 00:36:40,759
但问题在于，

00:36:40,759 --> 00:36:43,819
当你这样做发送到网络中时，

00:36:43,819 --> 00:36:47,329
你基本上就把你的私钥给了网络中的每一个人，

00:36:47,329 --> 00:36:49,519
因为你的私钥已经被暴露了。

00:36:49,519 --> 00:36:51,950
所以，如果你有其他的输出被锁定到这个地址，

00:36:51,950 --> 00:36:54,589
他们可以使用私钥解锁它们并花费它们，

00:36:54,589 --> 00:36:56,359
或者他们可以不转发这个交易，

00:36:56,359 --> 00:36:59,269
他们可以直接拿你的私钥并创建一个新的交易，

00:36:59,269 --> 00:37:03,410
然后发送到他们自己的地址，

00:37:03,410 --> 00:37:05,839
所以这是很不好的。

00:37:05,839 --> 00:37:08,390
所以我们需要一个更智能的方式来使用我们的私钥来解锁这个锁，

00:37:08,390 --> 00:37:11,509
来证明我们拥有这个地址，

00:37:11,509 --> 00:37:13,940
而不是真的给出私钥本身，

00:37:13,940 --> 00:37:18,079
这就是数字签名的作用。

00:37:18,079 --> 00:37:19,880
就像我说的，

00:37:19,880 --> 00:37:24,450
这个私钥和地址实际上是相互关联的，

00:37:24,450 --> 00:37:27,000
地址实际上是由你的私钥创建的，

00:37:27,000 --> 00:37:30,810
我现在不打算讲解这是如何工作的，

00:37:30,810 --> 00:37:32,070
但是私钥和数字签名，

00:37:32,070 --> 00:37:40,710
是通过一些数学运算使用椭圆曲线相互连接的。

00:37:40,710 --> 00:37:41,820
所以你可以做的是，

00:37:41,820 --> 00:37:44,150
因为这些是通过椭圆曲线连接的，

00:37:44,150 --> 00:37:48,810
你可以使用更多的数学运算从你的私钥创建一个签名，

00:37:48,810 --> 00:37:53,970
这将能够解锁这个地址。

00:37:53,970 --> 00:37:55,800
我会简单地介绍一下，

00:37:55,800 -->00:38:00,180
你如何为这个交易创建一个数字签名，

00:38:00,180 --> 00:38:04,430
你需要拿到私钥和你想要签名的交易，

00:38:04,430 --> 00:38:08,490
然后将它们放入这个椭圆曲线中。

00:38:08,490 --> 00:38:10,470
你使用了一些椭圆曲线数学，

00:38:10,470 --> 00:38:13,790
这将给你一个签名。

00:38:13,790 --> 00:38:16,320
目前，

00:38:16,320 --> 00:38:21,360
右侧的输入只有屏幕上显示的信息

00:38:21,360 --> 00:38:27,030
对，就像它仍然在那里，

00:38:27,030 --> 00:38:32,700
对，是的，

00:38:32,700 --> 00:38:38,460
然后你使用这个未签名的交易和你的私钥放入这个函数，

00:38:37,110 --> 00:38:38,460
和你的私钥放入这个函数，

00:38:38,460 --> 00:38:40,410
这将给你一个签名。

00:38:40,410 --> 00:38:44,040
这个签名将被放入交易中。

00:38:44,040 --> 00:38:45,660
我简化了这一点，

00:38:45,660 --> 00:38:48,840
这可能是你想忽略的部分，

00:38:48,840 --> 00:38:51,720
因为它很难保留。

00:38:51,720 --> 00:38:53,040
但是，如果你以技术思维观看这个，

00:38:53,040 --> 00:38:55,590
或者实际在做这个，

00:38:55,590 --> 00:38:58,140
你需要做的是，

00:38:58,140 --> 00:39:01,740
首先，当你想要签名一个交易时，

00:39:01,740 --> 00:39:03,180
你必须先剔除任何已存在的签名。

00:39:03,180 --> 00:39:04,890
如果你已经签名了一个输入，

00:39:04,890 --> 00:39:07,470
就把签名去掉。

00:39:07,470 --> 00:39:19,020
然后你需要在脚本签名将要放置的地方放置一个占位符代码，

00:39:19,020 --> 00:39:29,559
这个占位符代码是我们试图解锁的输入的锁定代码或脚本公钥。

00:39:23,820 --> 00:39:25,950
这只是一个占位符，

00:39:25,950 --> 00:39:27,720
所以我们知道要签名哪个输入。

00:39:27,720 --> 00:39:29,559
然后，

00:39:29,559 --> 00:39:34,970
你将所谓的sig hash类型附加到交易数据的末尾，

00:39:34,970 --> 00:39:38,239
我不完全确定这是用来做什么的，

00:39:38,239 --> 00:39:41,989
但对于典型的签名，

00:39:41,989 --> 00:39:43,640
你只需要在这里输入数字1，

00:39:43,640 --> 00:39:45,380
这显然是一个网络字节或字节顺序，

00:39:45,380 --> 00:39:45,980
bytes long

00:39:45,980 --> 00:39:48,619
长度为4字节。

00:39:48,619 --> 00:39:52,099
然后你把所有这些都通过hash256进行两次哈希，

00:39:52,099 --> 00:39:54,980
你会得到这个摘要，

00:39:54,980 --> 00:40:01,489
然后这个消息会进入这个椭圆曲线，

00:40:01,489 --> 00:40:03,289
然后它会输出一个签名，

00:40:03,289 --> 00:40:10,670
你需要将这个签名编码成DER格式，

00:40:10,670 --> 00:40:12,890
我认为大多数库都会给你这种编码签名的选项，

00:40:12,890 --> 00:40:15,769
然后最后你需要将相同的哈希类型附加到实际的签名本身，

00:40:15,769 --> 00:40:18,259
所以这只是一个哈希类型，

00:40:18,259 --> 00:40:22,009
我们将其放入数学运算中，

00:40:22,009 --> 00:40:29,299
然后我们在末尾附加相同的数字，

00:40:29,299 --> 00:40:31,730
这是4字节，

00:40:31,730 --> 00:40:32,599
这是1字节，

00:40:32,599 --> 00:40:35,420
我认为这是一个错误，

00:40:35,420 --> 00:40:37,039
当帐户正在开发时，

00:40:37,039 --> 00:40:40,460
有这些不同大小的字节，

00:40:40,460 --> 00:40:43,700
但它们都是相同的数字，

00:40:43,700 --> 00:40:44,930
在这个数字的末尾。

00:40:44,930 --> 00:40:48,079
所以这就是如果你在做技术性的工作，

00:40:48,079 --> 00:40:49,309
但我只是简化了这个，

00:40:49,309 --> 00:40:53,119
只是为了向你展示交易数据进入这个曲线。

00:40:53,119 --> 00:40:55,789
所以当你创建这个签名时，

00:40:55,789 --> 00:40:58,609
你使用了这个椭圆曲线，

00:40:58,609 --> 00:41:01,369
地址上就可以看到这个签名，

00:41:01,369 --> 00:41:04,579
然后，好的，

00:41:04,579 --> 00:41:11,509
这个签名只能由我从中创建的公钥的所有者创建。

00:41:11,509 --> 00:41:14,630
那么这就足够了，

00:41:14,630 --> 00:41:16,249
足够解锁这个输入，

00:41:16,249 --> 00:41:20,930
通过这样做，

00:41:20,930 --> 00:41:22,640
我们可以把这个签名放在这里，

00:41:22,640 --> 00:41:24,529
我们不会泄露我们的公钥或私钥。

00:41:24,529 --> 00:41:30,289
这个签名过程的另一个好处是，

00:41:30,289 --> 00:41:37,430
因为这个签名是由我们创建的这个交易结构制作的，

00:41:37,430 --> 00:41:39,890
当我们把这个签名放在这里时，

00:41:39,890 --> 00:41:42,859
如果我们把这个交易发送到网络中，

00:41:42,859 --> 00:41:51,380
有人试图修改交易的结构，

00:41:51,380 --> 00:41:58,549
比如改变比特币的地址，

00:41:58,549 --> 00:42:00,170
试图偷走你的比特币，

00:42:00,170 --> 00:42:02,450
那么这个签名就不再有效，

00:42:02,450 --> 00:42:06,799
这个交易就不再有效。

00:42:06,799 --> 00:42:13,369
因为这个签名只适用于产生它的交易。

00:42:13,369 --> 00:42:19,069
这个签名保护了你创建的交易的结构，

00:42:19,069 --> 00:42:21,079
它只能用于这个特定的交易。

00:42:21,079 --> 00:42:28,509
这就是你如何创建一个签名来

00:42:28,509 --> 00:42:32,710
解锁一个输入的基本方法，

00:42:32,710 --> 00:42:35,619
这被称为脚本签名。

00:42:35,619 --> 00:42:38,359
但在脚本签名中，

00:42:38,359 --> 00:42:41,569
你不仅仅放入签名，

00:42:41,569 --> 00:42:48,799
我之前给你展示的锁定代码中

00:42:48,799 --> 00:42:57,829
也需要你将公钥（也就是地址的原始版本）放入脚本签名中。

00:42:57,829 --> 00:42:59,749
虽然它被称为脚本签名，

00:42:59,749 --> 00:43:03,650
但它也需要一个公钥才能使解锁代码工作。

00:43:03,650 --> 00:43:09,799
显然，这个公钥的大小可以改变，

00:43:09,799 --> 00:43:15,920
所以你需要在这里放一个可变整数来描述它的长度。

00:43:15,920 --> 00:43:17,660
签名的大小也可以变化，

00:43:17,660 --> 00:43:21,200
所以它有自己的可变整数。

00:43:21,200 --> 00:43:24,650
在整个脚本签名之前，

00:43:24,650 --> 00:43:28,400
你需要放一个可变整数。

00:43:28,400 --> 00:43:31,039
通过这样，

00:43:31,039 --> 00:43:33,890
我们可以固定的字段大小和可变的字段大小，

00:43:33,890 --> 00:43:37,819
这意味着你可以解码这个交易并获取正确的数据量，

00:43:37,819 --> 00:43:40,420
所以你知道哪部分是哪部分。

00:43:41,050 --> 00:43:43,190
再次，

00:43:43,190 --> 00:43:44,600
我们将其发送到网络中，

00:43:44,600 --> 00:43:46,610
因为你已经放入了解锁它的签名，

00:43:46,610 --> 00:43:47,960
它们将发送到网络中，

00:43:47,960 --> 00:43:50,840
最终交易将被挖掘出来，

00:43:50,840 --> 00:43:55,040
从而形成这样的图。

00:43:55,040 --> 00:43:58,130
在这个过程中，

00:43:58,130 --> 00:44:06,140
每个网络节点都负责检查交易的有效性。

00:44:06,140 --> 00:44:07,460
好的，

00:44:07,460 --> 00:44:14,000
所以如果我篡改了Cynthia的脚本，

00:44:14,000 --> 00:44:21,020
节点会标记出来并切忽略这个交易。

00:44:21,020 --> 00:44:34,940
如果你试图发送一个错误的脚本，

00:44:34,940 --> 00:44:44,570
它事实上是一个数字签名，

00:44:44,570 --> 00:44:46,640
它只不过是由私钥签署的交易的哈希。

00:44:49,370 --> 00:44:50,560
这是对的。

00:44:50,560 --> 00:44:58,070
我的感觉是，

00:44:58,070 --> 00:45:02,360
节点可能会使用公钥重新签署，

00:45:02,360 --> 00:45:07,940
并检查两者是否一致。

00:45:07,940 --> 00:45:10,010
是的，

00:45:10,010 --> 00:45:15,920
你已经弄清楚了。

00:45:15,920 --> 00:45:18,500
回到这个幻灯片，

00:45:18,500 --> 00:45:23,150
你在之前的一个幻灯片中提到了占位符，

00:45:23,150 --> 00:45:25,880
你能再重复一下吗？

00:45:25,880 --> 00:45:30,710
我是说，会不会是一些占位符文本，

00:45:30,710 --> 00:45:33,020
或者它只是一个占位符？

00:45:33,020 --> 00:45:43,040
占位符是当我们之前创建这个锁，

00:45:43,040 --> 00:45:49,010
并放入一些锁定代码时的代码。

00:45:49,010 --> 00:45:50,299
例如，

00:45:50,299 --> 00:45:54,270
假设你想花费这个输入，

00:45:54,270 --> 00:46:05,789
这里的占位符就是这个锁内的代码。

00:46:05,789 --> 00:46:08,849
这有点混乱，

00:46:08,849 --> 00:46:12,569
我不知道为什么它必须是锁内的代码，

00:46:12,569 --> 00:46:14,670
但我相信它可以是任何其他东西，

00:46:14,670 --> 00:46:16,380
但它只需要是这个输入的实际锁定代码，

00:46:16,380 --> 00:46:17,520
老实说，

00:46:17,520 --> 00:46:19,230
这使得创建交易变得有些尴尬，

00:46:19,230 --> 00:46:24,329
需要回去获取这个输入的实际锁定代码，

00:46:24,329 --> 00:46:27,030
并将其作为占位符使用，

00:46:27,030 --> 00:46:32,430
但这就是它的工作方式。

00:46:32,430 --> 00:46:34,349
让我们再次概述一下整个过程，

00:46:34,349 --> 00:46:38,579
我们对整个块进行哈希处理，

00:46:38,579 --> 00:46:40,200
这就是我们要签名的内容。

00:46:40,200 --> 00:46:41,460
我简化了这个过程，

00:46:41,460 --> 00:46:44,369
说你只需要将交易数据放入椭圆曲线，

00:46:44,369 --> 00:46:46,680
这在某种程度上你是是正确的，

00:46:46,680 --> 00:46:48,690
但更准确的说法是，

00:46:48,690 --> 00:46:51,180
你实际上是附加了一个哈希类型，

00:46:51,180 --> 00:46:53,420
然后哈希它，

00:46:53,420 --> 00:46:58,099
最后将其放入这个椭圆曲线数学公式中。

00:46:58,609 --> 00:47:05,940
通常你可以找到一个叫做ECDSA的库，

00:47:05,940 --> 00:47:11,160
也就是椭圆曲线数字签名算法，

00:47:11,160 --> 00:47:16,529
我们通常可以用它来进行签名。

00:47:16,529 --> 00:47:19,470
还有一个问题是，

00:47:19,470 --> 00:47:22,170
我们是否需要对每一个我们试图花费的输出进行这个操作？

00:47:22,170 --> 00:47:25,579
对于每一个输入，

00:47:25,579 --> 00:47:29,430
我们都会重复这个过程。

00:47:29,430 --> 00:47:32,609

大致上，

00:47:32,609 --> 00:47:35,339
你不能忘记移除所有已存在的签名，

00:47:35,339 --> 00:47:40,500
然后对于每一个你想要的空白结构，

00:47:40,500 --> 00:47:45,930
你需要对其进行签名。

00:47:45,930 --> 00:47:47,819
最后，

00:47:47,819 --> 00:47:49,890
我们会插入所有的签名。

00:47:49,890 --> 00:47:53,190
喔，不好意思，

00:47:53,190 --> 00:47:55,319
在这个例子中，

00:47:55,319 --> 00:47:57,329
我们有多个输入，

00:47:57,329 --> 00:48:00,119
这是其中一个，

00:48:00,119 --> 00:48:01,470
然后如果我有另一个输入，

00:48:01,470 --> 00:48:02,670
我只需要取出所有这些签名，

00:48:02,670 --> 00:48:04,290
然后签名下一个，

00:48:04,290 --> 00:48:05,430
将占位符放入下一个，

00:48:05,430 --> 00:48:07,470
然后签名，

00:48:07,470 --> 00:48:09,390
以此类推，直到最后，

00:48:09,390 --> 00:48:12,390
你只需要在最后插入D。

00:48:12,390 --> 00:48:14,280
最后，

00:48:14,280 --> 00:48:21,120
你只需要将所有的脚本SIG插入回去。

00:48:21,120 --> 00:48:23,160
总结一下，

00:48:23,160 --> 00:48:25,350
这是我们的交易，

00:48:25,350 --> 00:48:30,660
我们创建了签名并将其放入。

00:48:30,660 --> 00:48:32,730
如我之前所说，

00:48:32,730 --> 00:48:35,460
一个交易有四个主要部分，

00:48:35,460 --> 00:48:38,070
有版本，有输入，输入有自己的结构或子结构，

00:48:38,070 --> 00:48:41,700
它引用一个交易ID，

00:48:41,700 --> 00:48:44,000
然后引用一个特定的输出，

00:48:44,000 --> 00:48:51,330
然后你有一个变量整数来告诉你即将到来的脚本sig的大小，

00:48:51,330 --> 00:48:54,360
然后在那之后你有一个序列。

00:48:54,360 --> 00:48:56,730
这就是输入。

00:48:56,730 --> 00:48:58,140
下一步我们有输出，

00:48:58,140 --> 00:49:00,510
它们也有自己的结构，

00:49:00,510 --> 00:49:02,250
但它们相当简单，

00:49:02,250 --> 00:49:04,500
它们只有一个8字节的值，

00:49:04,500 --> 00:49:08,250
然后你有一个可变整数来告诉你即将到来的解锁代码的大小，

00:49:08,250 --> 00:49:11,310
这被称为脚本公钥，

00:49:11,310 --> 00:49:14,300
最后你有锁定时间。

00:49:14,300 --> 00:49:17,490
这就是一个交易，

00:49:17,490 --> 00:49:19,260
它们都是一样的，

00:49:19,260 --> 00:49:21,150
唯一的区别是它们有不同数量的输入，

00:49:21,150 --> 00:49:24,270
不同数量的输出，

00:49:24,270 --> 00:49:26,910
它们显然引用了不同的交易，

00:49:26,910 --> 00:49:29,820
并有不同的签名，

00:49:29,820 --> 00:49:31,620
但如果你理解了结构，

00:49:31,620 --> 00:49:33,420
那么你就理解了所有可能的比特币交易的结构，

00:49:33,420 --> 00:49:35,060
他们可能会进行的任何交易

00:49:35,060 --> 00:49:39,570
除了一个seg，这就像是一个旧的交易

00:49:39,570 --> 00:49:42,840
你现在有隔离见证，

00:49:42,840 --> 00:49:46,830
基本上在一个非常基本的层面上，

00:49:46,830 --> 00:49:52,860
不再将签名代码放在交易的中间，

00:49:52,860 --> 00:49:55,440
而是将其移动到交易的末尾，

00:49:55,440 --> 00:50:04,740
这就是所谓的见证。

00:50:04,740 --> 00:50:10,860
因为它是在将签名从交易中分离出来，

00:50:10,860 --> 00:50:14,250
为什么被称为隔离见证，

00:50:14,250 --> 00:50:17,369
因为它将见证签名从交易结构中分离出来。

00:50:17,369 --> 00:50:18,030
我认为这涵盖了隔离见证的内容。

00:50:18,030 --> 00:50:23,160
我认为覆盖和隔离见证将是他自己的视频，

00:50:23,160 --> 00:50:26,339
但我想做这个或者至少这是一个基本的交易，

00:50:26,339 --> 00:50:30,869
这些仍然是有效的，

00:50:30,869 --> 00:50:42,920
你仍然可以在网络上一切正常地进行这些交易。

00:50:44,300 --> 00:50:48,059
所以可能只是一种，

00:50:48,059 --> 00:50:51,390
或者它根本上只是一个比特币提案，哦，是的没错。

00:50:51,390 --> 00:50:57,119
隔离见证是一个改变交易数据结构的比特币提案，

00:50:57,119 --> 00:50:59,339
好的，所以对的，

00:50:59,339 --> 00:51:02,520
这是个典型的基本交易，

00:51:02,520 --> 00:51:06,450
我是隔离见证将有另一个字段或者叫做见证区域的部分，

00:51:06,450 --> 00:51:11,130
签名基本上被移到了交易的末尾，

00:51:11,130 --> 00:51:15,359
那就叫做见证区域。

00:51:15,359 --> 00:51:16,740
让我重新表述一下这个问题，

00:51:16,740 --> 00:51:19,980
这是一个比特币核心的改变吗？

00:51:19,980 --> 00:51:23,970
还是说这是为了交易所需要做的改变，？

00:51:23,970 --> 00:51:30,390
我一直在关注这个，

00:51:30,390 --> 00:51:32,010
你知道这个人必须实施segwit，

00:51:32,010 --> 00:51:35,400
那个人必须实施segwit，

00:51:35,400 --> 00:51:38,940
他们还没有做，

00:51:38,940 --> 00:51:41,220
我仍然有点困惑，

00:51:41,220 --> 00:51:43,980
如果你没有创建自己的软件

00:51:43,980 --> 00:51:47,849
那只能创建这种类型的交易，

00:51:47,849 --> 00:51:53,790
除非你使用比特币核心软件来创建你的交易，

00:51:53,790 --> 00:51:56,640
否则你需要编写自己的软件，

00:51:56,640 --> 00:51:59,910
来创建你自己的隔离见证交易。

00:51:59,910 --> 00:52:02,190
自己创建得的隔离见证更有意义，

00:52:02,190 --> 00:52:05,099
安全也更有保障。

00:52:05,099 --> 00:52:12,030
这在技术上并不难，

00:52:12,030 --> 00:52:13,260
我知道为什么这有些地方花了这么长时间，

00:52:13,260 --> 00:52:19,530
我想可能是出于谨慎的考虑。

00:52:19,530 --> 00:52:24,059
如果我发送一个带有隔离见证的交易，

00:52:24,059 --> 00:52:27,450
比特币核心会会理解吗？是的，他会的。

00:52:27,450 --> 00:52:34,140
好的，我们已经把基础给完成了。

00:52:34,140 --> 00:52:36,329
beta版本完成了，接下来我会做一些示例，

00:52:36,329 --> 00:52:37,859
我从头开始创建一个交易

00:52:37,859 --> 00:52:47,490
好的，这是我在创建交易之前的网站

00:52:47,490 --> 00:52:50,119
在这里，

00:52:50,119 --> 00:52:54,240
我演示了交易从零开始。

00:52:54,240 --> 00:52:55,740
我查看了词汇表，

00:52:55,740 --> 00:52:59,880
去看交易数据，

00:52:59,880 --> 00:53:02,490
我在这里分析了交易，

00:53:02,490 --> 00:53:04,530
如果你想解码你自己的交易，

00:53:04,530 --> 00:53:05,460
我认为这是个很棒的主意。

00:53:05,460 --> 00:53:09,390
我认为解码这个交易数据是一个很好的开始，

00:53:09,390 --> 00:53:10,650
一开始尝试构建一个签名是会有点棘手，

00:53:10,650 --> 00:53:13,349
你可能会在某个地方卡住，

00:53:13,349 --> 00:53:16,829
但解码它我认为会是一个理解交易如何工作的好开始，

00:53:16,829 --> 00:53:22,290
你会开始理解交易是如何运作的，

00:53:22,290 --> 00:53:27,390
我发现拥有自己的解码器仅仅为了自己的参考目的是非常方便的，

00:53:27,390 --> 00:53:30,030
但如果你想深入了解交易数据，

00:53:30,030 --> 00:53:34,940
这是我网站上的页面，

00:53:34,940 --> 00:53:40,650
或者你可以在浏览器上查看任何区块的交易，

00:53:40,650 --> 00:53:43,349
例如这个，这个有点复杂，

00:53:43,349 --> 00:53:46,230
它接收了大量的输入并吐出了大量的输出，

00:53:46,230 --> 00:53:48,480
但如果你点击查看实际的，

00:53:48,480 --> 00:53:52,109
你可以将交易分解成它的组成部分，

00:53:52,109 --> 00:53:55,380
所以当你想了解交易的结构时，

00:53:55,380 --> 00:54:03,900
这可能会对你有帮助，

00:54:03,900 --> 00:54:05,420
但我现在要做的是，

00:54:05,420 --> 00:54:11,450
我要构建我自己的交易。

00:54:11,450 --> 00:54:15,349
我发誓我不能放弃，我要摆脱这个小东西。

00:54:15,349 --> 00:54:18,109
噢对不起，我不知道怎么做，兄弟。

00:54:18,109 --> 00:54:27,799
所以我有一些我做了一个小脚本叫做交易构建器，

00:54:27,799 --> 00:54:30,440
我将构建我自己的交易，

00:54:30,440 --> 00:54:39,049
首先我需要能够知道我可以花费哪些输出，

00:54:39,049 --> 00:54:41,869
我很幸运，我之前创建了一个交易，

00:54:41,869 --> 00:54:46,430
并且我提前锁定了这些输出到地址的价值，

00:54:46,430 --> 00:54:49,910
所以我要花费其中一个输出，

00:54:49,910 --> 00:54:54,380
所以我会花费这个，

00:54:54,380 --> 00:54:55,849
这是我想要花费的，

00:54:55,849 --> 00:54:57,549
并发送到其他地方，

00:54:57,549 --> 00:55:00,170
所以首先在交易构建器中，

00:55:00,170 --> 00:55:01,549
我还需要一个版本号，

00:55:01,549 --> 00:55:03,589
我会把版本1放在那里，

00:55:03,589 --> 00:55:11,359
把那个数字1转换成了十六进制网络字节顺序，

00:55:11,359 --> 00:55:15,980
并把它转换成了一个4字节的字段，

00:55:15,980 --> 00:55:17,930
接下来我们需要选择输入，

00:55:17,930 --> 00:55:20,720
我需要一个交易ID和一个输出编号。

00:55:20,720 --> 00:55:23,020
这是交易ID，

00:55:23,020 --> 00:55:26,270
我将它放在这里，

00:55:26,270 --> 00:55:30,280
我想让这个输出为0，

00:55:30,280 --> 00:55:36,380
这就是唯一一个我想要花费的。

00:55:36,380 --> 00:55:40,460
如果你看这里，

00:55:40,460 --> 00:55:44,000
这是输入的数量，

00:55:44,000 --> 00:55:50,530
这是以反向字节顺序的交易ID，

00:55:54,090 --> 00:55:59,460
所以4a4，是4字节的输出，

00:55:59,460 --> 00:56:02,550
这是变量整数，

00:56:02,550 --> 00:56:04,080
用来告诉我即将出现的签名大小，

00:56:04,080 --> 00:56:05,730
但我还没有把它放进去，

00:56:05,730 --> 00:56:07,500
所以是0，

00:56:07,500 --> 00:56:11,120
这是我没有使用的序列号。

00:56:11,120 --> 00:56:13,650
接下来我需要创建我的输出，

00:56:13,650 --> 00:56:16,970
在这里

00:56:16,970 --> 00:56:20,910
这是0.005比特币，

00:56:20,910 --> 00:56:23,520
但我希望这是以聪为单位，

00:56:23,520 --> 00:56:28,350
所以我在这里配置一下，

00:56:28,350 --> 00:56:33,090
这是0.0051，我在这里输入值，

00:56:33,090 --> 00:56:36,840
我想发送到的地址，

00:56:36,840 --> 00:56:40,230
我想我会把它发送到我的捐赠地址，

00:56:40,230 --> 00:56:41,760
地址这在网站的顶部。

00:56:41,760 --> 00:56:47,310
好了，

00:56:47,310 --> 00:56:51,630
但是因为我希望这个被挖掘，

00:56:51,630 --> 00:56:53,880
我没有在这个上面放费用，

00:56:53,880 --> 00:57:00,990
我将发送整个金额给c49，

00:57:00,990 --> 00:57:02,490
这会产生一些费用，

00:57:02,490 --> 00:57:03,960
我不知道每字节的费用是多少，

00:57:03,960 --> 00:57:06,120
但这将在交易中留下一些余额。

00:57:06,120 --> 00:57:09,570
再次输入地址，

00:57:09,570 --> 00:57:12,450
这交易已经创建了，

00:57:12,450 --> 00:57:17,910
这里输出已经被添加到交易代码，

00:57:17,910 --> 00:57:22,190
当我放入这个的时候，

00:57:22,190 --> 00:57:26,180
这是对的，我在这里有个问题，

00:57:26,180 --> 00:57:39,090
这个时候它是已经签名的还是还需要签名？

00:57:31,260 --> 00:57:35,070
你需要之前创建整个结构，

00:57:35,070 --> 00:57:39,090
然后才能签名。

00:57:39,090 --> 00:57:46,020
所以它已经把你的代码插入到了这个地方，

00:57:46,020 --> 00:57:48,510
最后一步是签名，

00:57:48,510 --> 00:57:50,850
现在我们已经创建了结构，

00:57:50,850 --> 00:57:52,410
我们选择了输入，并创建了输出，

00:57:52,410 --> 00:57:54,060
现在我们已经有了整个结构，

00:57:54,060 --> 00:57:56,010
你已经有了需要的数据，

00:57:56,010 --> 00:57:59,370
就能够签名，

00:57:59,370 --> 00:58:00,330
我需要这个地址的私钥。

00:58:00,330 -->00:58:06,300
你永远不应该暴露你的私钥。

00:58:06,300 --> 00:58:08,970
但在这个例子中，

00:58:08,970 --> 00:58:12,690
这就是我输出的私钥，

00:58:12,690 --> 00:58:13,710
对应于这个输出。

00:58:13,710 --> 00:58:16,680
但是，正如我所说，

00:58:16,680 --> 00:58:21,180
我们需要获取锁定代码，

00:58:21,180 --> 00:58:22,710
以便在签名时使用占位符。

00:58:22,710 --> 00:58:25,080
这有点烦人，

00:58:25,080 --> 00:58:26,250
但是你可以在浏览器上点击这个小锁，

00:58:26,250 --> 00:58:29,970
这就是锁定代码，

00:58:29,970 --> 00:58:34,160
你可以看到这些对应于操作码，

00:58:34,160 --> 00:58:37,950
这是公钥，

00:58:37,950 --> 00:58:41,120
这是地址。

00:58:41,120 --> 00:58:47,550
我需要这个锁定代码作为签名交易时的占位符。

00:58:47,550 --> 00:58:47,700
现在我将签名，

00:58:47,700 --> 00:58:50,640
这是已完成的交易数据，

00:58:50,640 --> 00:58:54,330
它已经全部签名，

00:58:54,330 --> 00:58:55,770
好了，已经准备好了，

00:58:55,770 --> 00:58:59,370
可以使用，如果我想的话，

00:58:59,370 --> 00:59:01,760
我可以快速解码它，

00:59:01,760 --> 00:59:03,470
我已经写了我自己的交易解码器，

00:59:03,470 --> 00:59:05,700
是非常方便的，

00:59:05,700 --> 00:59:08,370
我可以看到这个，

00:59:08,370 --> 00:59:11,370
它显示了输入，

00:59:11,370 --> 00:59:15,000
这里有一个交易ID和一个输出，

00:59:15,000 --> 00:59:16,440
可以解锁到这个地址，

00:59:16,440 --> 00:59:21,600
这是我的捐赠地址。

00:59:21,600 --> 00:59:23,580
如果你下载了比特币核心，
它有自己的解码器，

00:59:23,580 --> 00:59:25,670
它有自己的解码器，

00:59:25,670 --> 00:59:27,829
你可以做同样的事情，

00:59:27,829 --> 00:59:32,650
它也会为你解码。

00:59:33,190 --> 00:59:35,450
现在我们有了交易，

00:59:35,450 --> 00:59:37,609
它已经签名，准备好了，

00:59:37,609 --> 00:59:41,829
我可以做的是去比特币CLI发送你的交易，

00:59:41,829 --> 00:59:45,200
所以我把那个放在那里，

00:59:45,200 --> 0:59:48,589
它会给我一个交易ID，

00:59:48,589 --> 00:59:51,230
这就是交易，这是交易ID。

00:59:51,230 --> 00:59:54,079
我可以拿这个交易ID，

00:59:54,079 --> 00:59:56,859
进入我的区块链浏览器，

00:59:56,859 --> 00:59:59,660
输入交易ID试图找到它，

00:59:59,660 --> 01:00:01,640
好吧，它还没有找到，

01:00:01,640 --> 01:00:05,900
可能还需要一些时间来传播网络，

01:00:05,900 --> 01:00:12,589
那我继续刷新，

01:00:12,589 --> 01:00:16,039
好吧，我给它十秒钟，

01:00:16,039 --> 01:00:20,450
是的，我们正在寻找这个在men buoy或者在黑名单中已经走了。

01:00:20,450 --> 01:00:22,730
所以我创建了这个交易，

01:00:22,730 --> 01:00:25,160
我发送到一个节点，

01:00:25,160 --> 01:00:25,549
现在它将被发送到网络上，

01:00:25,549 --> 01:00:28,809
它将进入这个节点的mempool，

01:00:28,809 --> 01:00:31,759
以它应该是一个普通的循环，

01:00:31,759 --> 01:00:33,710
如果我点击这个内存池，

01:00:33,710 --> 01:00:36,470
它应该会出现在这里，

01:00:36,470 --> 01:00:41,539
我刚刚删除了页面，它在那里，

01:00:41,539 --> 01:00:42,890
好吧，他们五秒钟前收到了，

01:00:42,890 --> 01:00:46,069
那么我可以点击这个，

01:00:46,069 --> 01:00:48,319
这就是我刚刚做的交易，

01:00:48,319 --> 01:00:51,349
我正在查看浏览器，现在它在网络上，

01:00:51,349 --> 01:00:53,089
我知道它已经被发送到网络上，

01:00:53,089 --> 01:00:56,059
这是一个非常低的费用，

01:00:56,059 --> 01:01:00,410
我不认为它会被挖掘，

01:01:00,410 --> 01:01:01,970
但是我可以查看代码，

01:01:01,970 --> 01:01:04,549
这应该是我创建的完全相同的代码，

01:01:04,549 --> 01:01:07,519
基本上你将代码发送到网络，

01:01:07,519 --> 01:01:12,589
这描述了输入到输出的交易。

01:01:12,589 --> 01:01:18,769
是的，这是更好的转换器，

01:01:18,769 --> 01:01:21,170
在这里要两美元，

01:01:21,170 --> 01:01:22,880
我没有，

01:01:22,880 --> 01:01:25,069
我想我可以请求我的兄弟，

01:01:25,069 --> 01:01:26,420
我还得继续努力，

01:01:26,420 --> 01:01:30,559
是的，我认为这大约是80美元，

01:01:30,559 --> 01:01:42,150
所以我可能想要确保这笔交易在我发布视频之前得到确认，

01:01:42,150 --> 01:01:49,440
因为确切的私钥和费用大约是0.0002，

01:01:49,440 --> 01:01:52,950
节点只能用这么多字节来填充他们的块，

01:01:52,950 --> 01:01:55,230
那么它就会按字节收费，

01:01:55,230 --> 01:02:00,600
但我还没有更新Explorer来使用权重，

01:02:00,600 --> 01:02:02,010
这是一个更复杂的事情，

01:02:02,010 --> 01:02:05,400
但如果我们看一下所有的交易，

01:02:05,400 --> 01:02:10,170
你看到底部的那些，

01:02:10,170 --> 01:02:13,290
它们通常是按照他们的费用来排序的，

01:02:13,290 --> 01:02:15,480
最小的大约是100个，

01:02:15,480 --> 01:02:17,490
对，要100个聪，

01:02:17,490 --> 01:02:19,530
所以有些人可能会被收取更少的费用，

01:02:19,530 --> 01:02:24,780
但这只是一个粗略的估计，

01:02:24,780 --> 01:02:28,620
看起来我的交易费用稍微低了一点，

01:02:28,620 --> 01:02:32,130
还不能显示我的，

01:02:32,130 --> 01:02:35,760
所以我可能会创建另一个，

01:02:35,760 --> 01:02:36,990
为了向你展示，

01:02:36,990 --> 01:02:39,750
我认为这已经足够了，

01:02:39,750 --> 01:02:47,730
当你得到一个交易时，

01:02:47,730 --> 01:02:49,620
它就会进入内存池，

01:02:49,620 --> 01:02:52,610
所以我已经把这段代码放在网站上了，

01:02:52,610 --> 01:02:55,650
如果你去看交易构建器.rb，

01:02:55,650 --> 01:02:59,280
代码都在这里，我用Ruby写的，

01:02:59,280 --> 01:03:00,440
尽可能地简单化，

01:03:00,440 --> 01:03:03,570
我本来想用过程式的方式来做，

01:03:03,570 --> 01:03:04,680
因为我觉得那样会更容易，

01:03:04,680 --> 01:03:06,630
但我不能那样做，

01:03:06,630 --> 01:03:08,250
用面向对象的方式会更容易，

01:03:08,250 --> 01:03:12,360
且代码并不是很长，

01:03:12,360 --> 01:03:14,460
大约有300行，

01:03:14,460 --> 01:03:18,870
但主要的部分是你要有一些工具，

01:03:18,870 --> 01:03:26,310
用于获取正确格式的所有数据，

01:03:26,310 --> 01:03:28,920
主要的交易，

01:03:28,920 --> 01:03:31,110
它有版本、输入、输出和锁定时间，

01:03:31,110 --> 01:03:34,350
有一个输入数组和一个输出数组，

01:03:34,350 --> 01:03:35,790
还有一个输入类，

01:03:35,790 --> 01:03:40,040
包含了交易ID，V out脚本等等，

01:03:40,040 --> 01:03:43,550
然后你有一个输出对象，

01:03:43,550 --> 01:03:45,320
它只有价值和脚本公钥。

01:03:45,320 --> 01:03:52,940
所以如果你想从头开始创建你自己的交易构建器，

01:03:52,940 --> 01:03:54,560
我认为这是一个好方法

01:03:54,560 --> 01:03:57,650
你可以用你自己的编程语言来做

01:03:57,650 --> 01:03:59,030
如果你想看看你是否犯了一些错误，

01:03:59,030 --> 01:04:00,110
你想看看哪里出了问题，

01:04:00,110 --> 01:04:03,320
你可以随时来这里查看。

01:04:03,320 --> 01:04:07,030
例如，可能最棘手的部分就是签名部分，

01:04:07,030 --> 01:04:10,310
这里有签名方法，

01:04:10,310 --> 01:04:12,860
有点长，

01:04:12,860 --> 01:04:14,300
但基本上就是按正确的顺序获取所有数据，

01:04:14,300 --> 01:04:17,300
我已经对它进行了注释，

01:04:17,300 --> 01:04:18,530
所以你试图找出可能遗漏缺失的部分时，

01:04:18,530 --> 01:04:24,880
它可能会有所帮助。

01:04:24,940 --> 01:04:29,990
如果你有任何问题，可以随时提问。

01:04:29,990 --> 01:04:39,920
我认为这个网站对于想要创建自己的交易的人来说非常有帮助，

01:04:39,920 --> 01:04:47,750
或者浏览并了解正在发生的情况非常有帮助。

01:04:47,750 --> 01:04:49,850
这个网站是通过一个实时的比特币核心节点运行的，

01:04:49,850 --> 01:04:52,280
所以当你进行交易时，

01:04:52,280 --> 01:04:54,440
它会实时更新。

01:04:54,440 --> 01:04:58,060
我把数据存储在我自己的数据库中，

01:04:58,060 --> 01:05:00,740
但它基本上是在运行的比特币核心节点里

01:05:00,740 --> 01:05:02,990
所以当你做一个交易，

01:05:02,990 --> 01:05:04,940
一个新的区块刚刚被添加，

01:05:04,940 --> 01:05:10,490
是的，这一切都是实时的。

01:05:10,490 --> 01:05:17,180
你是在同一节点上托管网站，

01:05:17,180 --> 01:05:19,100
或是在另一台机器上将数据拉入数据库，

01:05:19,100 --> 01:05:22,070
然后让网站从中读取数据，

01:05:22,070 --> 01:05:23,510
实际上它在同一台机器上，

01:05:23,510 --> 01:05:25,010
更有意义的是将节点放在另一台机器上，

01:05:25,010 --> 01:05:27,980
然后他们如何

01:05:27,980 --> 01:05:29,150
-我会让这个网站只是数据库，

01:05:29,150 --> 01:05:35,600
但我不希望机器需要处理处理它。

01:05:35,600 --> 01:05:40,640
但这个网站实际上是在瑞士的一台机器上运行的。

01:05:40,640 --> 01:05:41,990
我在英国，

01:05:41,990 --> 01:05:47,910
所以我从我的本地节点发送交易，

01:05:47,910 --> 01:05:55,650
可能需要几秒钟的时间能传播到整个网络，

01:05:55,650 --> 01:05:59,699
所以我的网站在解码交易时有点慢。

01:05:59,699 --> 01:06:03,259
然后将其存储在数据库中

01:06:04,039 --> 01:06:08,369
比特币CLI给你提供了所有这些数据，

01:06:08,369 --> 01:06:11,279
可以访问这些所有数据，

01:06:11,279 --> 01:06:13,679
比如内存池和内存池中的交易

01:06:13,679 --> 01:06:16,199
是的，它确实提供了所有的数据。

01:06:16,199 --> 01:06:19,019
所以你可以使用这个网站

01:06:19,019 --> 01:06:21,989
但你实际上可以从比特币CLI获取所有这些数据。

01:06:21,989 --> 01:06:25,939
我不确定是什么。

01:06:25,939 --> 01:06:28,650
最后是内存池，

01:06:28,650 --> 01:06:31,469
比特币CLI获取更多的内存池，

01:06:31,469 --> 01:06:33,779
这些都是交易ID，

01:06:33,779 --> 01:06:37,439
如果你想要获取比特币交易信息，

01:06:37,439 --> 01:06:47,519
就在这里。

01:06:47,519 --> 01:06:48,809
我刚刚选择的那个的交易数据，

01:06:48,809 --> 01:06:50,729
所有的东西都在那里，

01:06:50,729 --> 01:06:53,269
你知道，你可以从内存池中获取所有的数据。

01:06:53,269 --> 01:07:00,119
我认为比特币看起来很不错，

01:07:00,119 --> 01:07:03,630
所以我想我已经涵盖了我想要讲的所有内容。

01:07:03,630 --> 01:07:07,859
是的，这就是全部。

01:07:07,859 --> 01:07:13,670
非常感谢。

01:07:13,670 --> 01:07:16,679
我期待着下一次的讲解。

01:07:16,679 --> 01:07:25,650
接下来我们可能会讨论公钥和地址。

01:07:25,650 --> 01:07:29,789
这些公钥可能会涵盖每个密钥和地址，

01:07:29,789 --> 01:07:33,059
和它们如何通过这个lip decay创建的方式相互连接。

01:07:33,059 --> 01:07:34,529
我将解释很多关于这个签名如何工作的问题。

01:07:34,529 --> 01:07:35,910
目前我只是说这是一个签名，

01:07:35,910 --> 01:07:38,489
它是有效的，

01:07:38,489 --> 01:07:40,049
但我可以使用数学方法，

01:07:40,049 --> 01:07:44,730
来解释它是如何真正工作的，

01:07:44,730 --> 01:07:47,040
是的，我很期待

01:07:47,040 --> 01:07:48,810
只要你准备好了，

01:07:48,810 --> 01:07:51,119
就告诉我。

01:07:51,119 --> 01:07:52,500
我就停下来，

01:07:52,500 --> 01:07:54,390
我开始研究一些密钥和地址的东西。

01:07:54,390 --> 01:07:56,310
我过一段时间给你发邮件，

01:07:56,310 --> 01:07:59,550
让你知道我什么时候可能准备好了。

01:07:59,550 --> 01:08:02,250
非常感谢你。

01:08:02,250 --> 01:08:04,550
谢谢你，这真的很好。